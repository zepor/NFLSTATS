{
  "resolvedId": "/app/node_modules/.vite/deps/react-router-dom.js?v=a66dbd78",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process.title = \"browser\";\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = \"\";\n      process.versions = {};\n      function noop() {\n      }\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function(name) {\n        return [];\n      };\n      process.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process.cwd = function() {\n        return \"/\";\n      };\n      process.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process.umask = function() {\n        return 0;\n      };\n    }\n  });\n\n  // shims/dist/index.js\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\n      import_process = __toESM(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n\n  // shims/banner/index.cjs\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n\nimport {\n  require_react_dom\n} from \"./chunk-ODZQOPX5.js\";\nimport {\n  require_react\n} from \"./chunk-DMLNAHRU.js\";\nimport {\n  __toESM,\n  require_dist\n} from \"./chunk-4KAQPM64.js\";\n\n// node_modules/react-router-dom/dist/index.js\nvar import_dist3 = __toESM(require_dist());\nvar React2 = __toESM(require_react());\nvar ReactDOM = __toESM(require_react_dom());\n\n// node_modules/react-router/dist/index.js\nvar import_dist2 = __toESM(require_dist());\nvar React = __toESM(require_react());\n\n// node_modules/@remix-run/router/dist/router.js\nvar import_dist = __toESM(require_dist());\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar Action;\n(function(Action2) {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries;\n  entries = initialEntries.map((entry, index2) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window2, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window2.location;\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substr(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\")\n      console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window: window2 = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window2.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    let base = window2.location.origin !== \"null\" ? window2.location.origin : window2.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\nvar ResultType;\n(function(ResultType2) {\n  ResultType2[\"data\"] = \"data\";\n  ResultType2[\"deferred\"] = \"deferred\";\n  ResultType2[\"redirect\"] = \"redirect\";\n  ResultType2[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nvar immutableRouteKeys = /* @__PURE__ */ new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], 'Found a route id collision on id \"' + id + `\".  Route id's must be globally unique within Data Router usages`);\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties2(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties2(route), {\n        id,\n        children: void 0\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".')\n      );\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0)\n    return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(...restExploded.map((subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map((exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match)\n      return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n      return stringify(param);\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match)\n    return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = void 0;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else\n    ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\")\n    return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1)\n        segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n  let pathMatches = getPathContributingMatches(matches);\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n  }\n  return pathMatches.map((match) => match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames.length === 0 ? [] : routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar json = function json2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nvar AbortedDeferredError = class extends Error {\n};\nvar DeferredData = class {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = /* @__PURE__ */ new Set();\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, void 0, data), (error) => this.onSettle(promise, key, error));\n    promise.catch(() => {\n    });\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    if (error === void 0 && data === void 0) {\n      let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === void 0) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted2) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted2 || this.done) {\n            resolve(aborted2);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n};\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nvar defer = function defer2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\nvar redirect = function redirect2(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nvar validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser2;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties2;\n  if (init.mapRouteProperties) {\n    mapRouteProperties2 = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties2 = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties2 = defaultMapRouteProperties;\n  }\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false\n  }, init.future);\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    initialized = false;\n  } else if (!hasLoaders) {\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    initialized = initialMatches.every((m) => m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== void 0 || errors && errors[m.route.id] !== void 0));\n  } else {\n    initialized = init.hydrationData != null;\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = Action.Pop;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledDeferredRoutes = [];\n  let cancelledFetcherLoads = [];\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let deletedFetchers = /* @__PURE__ */ new Set();\n  let activeDeferreds = /* @__PURE__ */ new Map();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let ignoreNextHistoryUpdate = false;\n  function initialize() {\n    unlistenHistory = init.history.listen((_ref) => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: void 0,\n              reset: void 0,\n              location\n            });\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            deletedFetchersKeys.push(key);\n          } else {\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    [...subscribers].forEach((subscriber) => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation)\n      ;\n    else if (pendingAction === Action.Pop)\n      ;\n    else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === Action.Pop) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false)\n      ;\n    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers2 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect3.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key))\n      abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      {\n        [match.route.id]: actionResult.data\n      },\n      void 0\n      // No need to send through errors since we short circuit above\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect3.result);\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (isDeferredResult(result)) {\n      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n    }\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(state2, redirect3, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect3.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state2.location, redirect3.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect3.reloadDocument) {\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect3.location)) {\n        const url = init.history.createURL(redirect3.location);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect3.location);\n        } else {\n          routerWindow.location.assign(redirect3.location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state2.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state2.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect3.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect3.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map((f) => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f) => f.match), fetcherResults, fetchersToLoad.map((f) => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\nvar UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n          let [name, value] = _ref3;\n          return \"\" + acc + name + \"=\" + value + \"\\n\";\n        }, \"\")\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json3 = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json: json3,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (isInitialLoad) {\n      return isUnhydratedRoute(state, match.route);\n    }\n    if (match.route.lazy) {\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id)) {\n      return true;\n    }\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate: (\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n      )\n    }));\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (isInitialLoad || !matches.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0) {\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isUnhydratedRoute(state, route) {\n  if (!route.loader) {\n    return false;\n  }\n  if (route.loader.hydrate) {\n    return true;\n  }\n  return state.loaderData[route.id] === void 0 && (!state.errors || // Loader ran but errored - don't re-run\n  state.errors[route.id] === void 0);\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = currentLoaderData[match.route.id] === void 0;\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nasync function loadLazyRouteModule(route, mapRouteProperties2, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  Object.assign(routeToUpdate, routeUpdates);\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties2(routeToUpdate), {\n    lazy: void 0\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename, v7_relativeSplatPath, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        let handlerError;\n        let values = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties2, manifest)\n        ]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);\n        handler = match.route[type];\n        if (handler) {\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return {\n            type: ResultType.data,\n            data: void 0\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== void 0, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n      } else if (!opts.isStaticRequest) {\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        data = await result.json();\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      loaderData[id] = void 0;\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = void 0;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    if (controller && controller.signal.aborted) {\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== void 0) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== void 0 && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = 'No route matches URL \"' + pathname + '\"';\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find((m) => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then((result2) => {\n        if (result2) {\n          results[index] = result2 || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json: json3\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json3 !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: json3,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json3 = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json3 || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json3 = {};\n    for (let [k, v] of transitions) {\n      json3[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json3));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n\n// node_modules/react-router/dist/index.js\nfunction _extends2() {\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nvar DataRouterContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\nvar NavigationContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nvar RouteContext = React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\nvar navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\";\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    React.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    future,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nvar OutletContext = React.createContext(null);\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    future\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (process.env.NODE_ENV !== \"production\") {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + `parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n` + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? warning(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : void 0;\n    process.env.NODE_ENV !== \"production\" ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.') : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n    ]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n    ])\n  })), parentMatches, dataRouterState, future);\n  if (locationArg && renderedMatches) {\n    return React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends2({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = React.createElement(React.Fragment, null, React.createElement(\"p\", null, \" Hey developer \"), React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return React.createElement(React.Fragment, null, React.createElement(\"h2\", null, \"Unexpected Application Error!\"), React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nvar defaultErrorElement = React.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error !== void 0 ? React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n};\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.loader && match.route.id && dataRouterState.loaderData[match.route.id] === void 0 && (!dataRouterState.errors || dataRouterState.errors[match.route.id] === void 0)) {\n        renderFallback = true;\n        if (fallbackIndex >= 0) {\n          renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n        } else {\n          renderedMatches = [renderedMatches[0]];\n        }\n        break;\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : void 0;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        children = React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return React.createElement(RenderedRoute, {\n        match,\n        routeContext: {\n          outlet,\n          matches: matches2,\n          isDataRoute: dataRouterState != null\n        },\n        children\n      });\n    };\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches: matches2,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = function(DataRouterHook3) {\n  DataRouterHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook3;\n}(DataRouterHook || {});\nvar DataRouterStateHook = function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook3[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook3[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook3[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook3[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook3[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook3[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook3[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook3;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? invariant(false, hookName + ' can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return void 0;\n  }\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n  if (error !== void 0) {\n    return error;\n  }\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback((arg) => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends2({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends2({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends2({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = React[START_TRANSITION];\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    future,\n    static: isStatic\n  } = React.useContext(NavigationContext);\n  process.env.NODE_ENV !== \"production\" ? warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false);\n}\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false,\n    future\n  } = _ref5;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.\") : invariant(false) : void 0;\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp,\n    future: _extends2({\n      v7_relativeSplatPath: false\n    }, future)\n  }), [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  process.env.NODE_ENV !== \"production\" ? warning(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, React.createElement(LocationContext.Provider, {\n    children,\n    value: locationContext\n  }));\n}\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return React.createElement(AwaitErrorBoundary, {\n    resolve,\n    errorElement\n  }, React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = function(AwaitRenderStatus2) {\n  AwaitRenderStatus2[AwaitRenderStatus2[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus2;\n}(AwaitRenderStatus || {});\nvar neverSettledPromise = new Promise(() => {\n});\nvar AwaitErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then((data) => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), (error) => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children\n      });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return React.createElement(React.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"An index route cannot have child routes.\") : invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.element) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: React.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.hydrateFallbackElement) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: React.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.errorElement) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends2({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\n\n// node_modules/react-router-dom/dist/index.js\nfunction _extends3() {\n  _extends3 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends3.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error('Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">');\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\nvar _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"];\nvar _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"];\nvar _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends3({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors)\n    return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nvar ViewTransitionContext = React2.createContext({\n  isTransitioning: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nvar FetchersContext = React2.createContext(/* @__PURE__ */ new Map());\nif (process.env.NODE_ENV !== \"production\") {\n  FetchersContext.displayName = \"Fetchers\";\n}\nvar START_TRANSITION2 = \"startTransition\";\nvar startTransitionImpl2 = React2[START_TRANSITION2];\nvar FLUSH_SYNC = \"flushSync\";\nvar flushSyncImpl = ReactDOM[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl2) {\n    startTransitionImpl2(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React2.useState(router.state);\n  let [pendingState, setPendingState] = React2.useState();\n  let [vtContext, setVtContext] = React2.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React2.useState();\n  let [transition, setTransition] = React2.useState();\n  let [interruption, setInterruption] = React2.useState();\n  let fetcherData = React2.useRef(/* @__PURE__ */ new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React2.useCallback((cb) => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React2.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== void 0) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    if (flushSync) {\n      flushSyncSafe(() => {\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(void 0);\n          setTransition(void 0);\n          setPendingState(void 0);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    if (transition) {\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  React2.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React2.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition2);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  React2.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  React2.useEffect(() => {\n    process.env.NODE_ENV !== \"production\" ? warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n  }, []);\n  let navigator = React2.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React2.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  return React2.createElement(React2.Fragment, null, React2.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, React2.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, React2.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, React2.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, React2.createElement(Router, {\n    basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? React2.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref4;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref5;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React2.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n    onClick,\n    relative,\n    reloadDocument,\n    replace,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to)) {\n    absoluteHref = to;\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;\n      }\n    }\n  }\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick)\n      onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React2.createElement(\"a\", _extends3({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref,\n      target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\nvar NavLink = React2.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    unstable_viewTransition,\n    children\n  } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React2.useContext(DataRouterStateContext);\n  let {\n    navigator\n  } = React2.useContext(NavigationContext);\n  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return React2.createElement(Link, _extends3({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className,\n    ref,\n    style,\n    to,\n    unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\nvar Form = React2.forwardRef((_ref9, forwardedRef) => {\n  let {\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = (event) => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented)\n      return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return React2.createElement(\"form\", _extends3({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\nvar DataRouterHook2;\n(function(DataRouterHook3) {\n  DataRouterHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook3[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook3[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook3[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook2 || (DataRouterHook2 = {}));\nvar DataRouterStateHook2;\n(function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook3[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));\nfunction getDataRouterConsoleError2(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext2(hookName) {\n  let ctx = React2.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = React2.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React2.useCallback((event) => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\\n\\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.\") : void 0;\n  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React2.useRef(false);\n  let location = useLocation();\n  let searchParams = React2.useMemo(() => (\n    // Only merge in the defaults if we haven't yet called setSearchParams.\n    // Once we call that we want those to take precedence, otherwise you can't\n    // remove a param with setSearchParams({}) if it has an initial value\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)\n  ), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React2.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseSubmit);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return React2.useCallback(function(target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let routeContext = React2.useContext(RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFormAction must be used inside a RouteContext\") : invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  let path = _extends3({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseFetcher);\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetcher);\n  let fetcherData = React2.useContext(FetchersContext);\n  let route = React2.useContext(RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher must be used inside a FetchersContext\") : invariant(false) : void 0;\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher must be used inside a RouteContext\") : invariant(false) : void 0;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  let [fetcherKey, setFetcherKey] = React2.useState(key || \"\");\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  React2.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  let load = React2.useCallback((href, opts) => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for fetcher.load()\") : invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React2.useCallback((target, opts) => {\n    submitImpl(target, _extends3({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React2.useMemo(() => {\n    let FetcherForm2 = React2.forwardRef((props, ref) => {\n      return React2.createElement(Form, _extends3({}, props, {\n        navigate: false,\n        fetcherKey,\n        ref\n      }));\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      FetcherForm2.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React2.useMemo(() => _extends3({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetchers);\n  return Array.from(state.fetchers.entries()).map((_ref11) => {\n    let [key, fetcher] = _ref11;\n    return _extends3({}, fetcher, {\n      key\n    });\n  });\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  React2.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(React2.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  if (typeof document !== \"undefined\") {\n    React2.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    React2.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location2, matches2) => getKey(\n        // Strip the basename to match useLocation()\n        _extends3({}, location2, {\n          pathname: stripBasename(location2.pathname, basename) || location2.pathname\n        }),\n        matches2\n      ) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    React2.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React2.useContext(ViewTransitionContext);\n  !(vtContext != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\") : invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\nexport {\n  AbortedDeferredError,\n  Await,\n  BrowserRouter,\n  Form,\n  HashRouter,\n  Link,\n  MemoryRouter,\n  NavLink,\n  Navigate,\n  Action as NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  ScrollRestoration,\n  DataRouterContext as UNSAFE_DataRouterContext,\n  DataRouterStateContext as UNSAFE_DataRouterStateContext,\n  FetchersContext as UNSAFE_FetchersContext,\n  LocationContext as UNSAFE_LocationContext,\n  NavigationContext as UNSAFE_NavigationContext,\n  RouteContext as UNSAFE_RouteContext,\n  ViewTransitionContext as UNSAFE_ViewTransitionContext,\n  useRouteId as UNSAFE_useRouteId,\n  useScrollRestoration as UNSAFE_useScrollRestoration,\n  createBrowserRouter,\n  createHashRouter,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromChildren as createRoutesFromElements,\n  createSearchParams,\n  defer,\n  generatePath,\n  isRouteErrorResponse,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  redirectDocument,\n  renderMatches,\n  resolvePath,\n  HistoryRouter as unstable_HistoryRouter,\n  usePrompt as unstable_usePrompt,\n  useViewTransitionState as unstable_useViewTransitionState,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useBeforeUnload,\n  useBlocker,\n  useFetcher,\n  useFetchers,\n  useFormAction,\n  useHref,\n  useInRouterContext,\n  useLinkClickHandler,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n  useSearchParams,\n  useSubmit\n};\n/*! Bundled license information:\n\n@remix-run/router/dist/router.js:\n  (**\n   * @remix-run/router v1.14.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router/dist/index.js:\n  (**\n   * React Router v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router-dom/dist/index.js:\n  (**\n   * React Router DOM v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n*/\n//# sourceMappingURL=react-router-dom.js.map\n",
      "start": 1703474738440,
      "end": 1703474742326,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1703474742326,
      "end": 1703474742326,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process2 = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process2.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process2.title = \"browser\";\n      process2.browser = true;\n      process2.env = {};\n      process2.argv = [];\n      process2.version = \"\";\n      process2.versions = {};\n      function noop() {\n      }\n      process2.on = noop;\n      process2.addListener = noop;\n      process2.once = noop;\n      process2.off = noop;\n      process2.removeListener = noop;\n      process2.removeAllListeners = noop;\n      process2.emit = noop;\n      process2.prependListener = noop;\n      process2.prependOnceListener = noop;\n      process2.listeners = function(name) {\n        return [];\n      };\n      process2.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process2.cwd = function() {\n        return \"/\";\n      };\n      process2.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process2.umask = function() {\n        return 0;\n      };\n    }\n  });\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM2(require_buffer(), 1);\n      import_process = __toESM2(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\nimport {\n  require_react_dom\n} from \"./chunk-ODZQOPX5.js\";\nimport {\n  require_react\n} from \"./chunk-DMLNAHRU.js\";\nimport {\n  __toESM,\n  require_dist\n} from \"./chunk-4KAQPM64.js\";\nvar import_dist3 = __toESM(require_dist());\nvar React2 = __toESM(require_react());\nvar ReactDOM = __toESM(require_react_dom());\nvar import_dist2 = __toESM(require_dist());\nvar React = __toESM(require_react());\nvar import_dist = __toESM(require_dist());\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar Action;\n(function(Action2) {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries;\n  entries = initialEntries.map((entry, index2) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window2, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window2.location;\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substr(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\")\n      console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window: window2 = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window2.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    let base = window2.location.origin !== \"null\" ? window2.location.origin : window2.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\nvar ResultType;\n(function(ResultType2) {\n  ResultType2[\"data\"] = \"data\";\n  ResultType2[\"deferred\"] = \"deferred\";\n  ResultType2[\"redirect\"] = \"redirect\";\n  ResultType2[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nvar immutableRouteKeys = /* @__PURE__ */ new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], 'Found a route id collision on id \"' + id + `\".  Route id's must be globally unique within Data Router usages`);\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties2(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties2(route), {\n        id,\n        children: void 0\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".')\n      );\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0)\n    return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(...restExploded.map((subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map((exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match)\n      return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n      return stringify(param);\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match)\n    return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = void 0;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else\n    ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\")\n    return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1)\n        segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n  let pathMatches = getPathContributingMatches(matches);\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n  }\n  return pathMatches.map((match) => match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames.length === 0 ? [] : routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar json = function json2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nvar AbortedDeferredError = class extends Error {\n};\nvar DeferredData = class {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = /* @__PURE__ */ new Set();\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, void 0, data), (error) => this.onSettle(promise, key, error));\n    promise.catch(() => {\n    });\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    if (error === void 0 && data === void 0) {\n      let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === void 0) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted2) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted2 || this.done) {\n            resolve(aborted2);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n};\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nvar defer = function defer2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\nvar redirect = function redirect2(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nvar validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser2;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties2;\n  if (init.mapRouteProperties) {\n    mapRouteProperties2 = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties2 = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties2 = defaultMapRouteProperties;\n  }\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false\n  }, init.future);\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    initialized = false;\n  } else if (!hasLoaders) {\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    initialized = initialMatches.every((m) => m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== void 0 || errors && errors[m.route.id] !== void 0));\n  } else {\n    initialized = init.hydrationData != null;\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = Action.Pop;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledDeferredRoutes = [];\n  let cancelledFetcherLoads = [];\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let deletedFetchers = /* @__PURE__ */ new Set();\n  let activeDeferreds = /* @__PURE__ */ new Map();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let ignoreNextHistoryUpdate = false;\n  function initialize() {\n    unlistenHistory = init.history.listen((_ref) => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: void 0,\n              reset: void 0,\n              location\n            });\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            deletedFetchersKeys.push(key);\n          } else {\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    [...subscribers].forEach((subscriber) => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation)\n      ;\n    else if (pendingAction === Action.Pop)\n      ;\n    else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === Action.Pop) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false)\n      ;\n    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers2 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect3.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key))\n      abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      {\n        [match.route.id]: actionResult.data\n      },\n      void 0\n      // No need to send through errors since we short circuit above\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect3.result);\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (isDeferredResult(result)) {\n      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n    }\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(state2, redirect3, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect3.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state2.location, redirect3.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect3.reloadDocument) {\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect3.location)) {\n        const url = init.history.createURL(redirect3.location);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect3.location);\n        } else {\n          routerWindow.location.assign(redirect3.location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state2.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state2.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect3.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect3.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map((f) => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f) => f.match), fetcherResults, fetchersToLoad.map((f) => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\nvar UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n          let [name, value] = _ref3;\n          return \"\" + acc + name + \"=\" + value + \"\\n\";\n        }, \"\")\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json3 = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json: json3,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (isInitialLoad) {\n      return isUnhydratedRoute(state, match.route);\n    }\n    if (match.route.lazy) {\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id)) {\n      return true;\n    }\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate: (\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n      )\n    }));\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (isInitialLoad || !matches.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0) {\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isUnhydratedRoute(state, route) {\n  if (!route.loader) {\n    return false;\n  }\n  if (route.loader.hydrate) {\n    return true;\n  }\n  return state.loaderData[route.id] === void 0 && (!state.errors || // Loader ran but errored - don't re-run\n  state.errors[route.id] === void 0);\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = currentLoaderData[match.route.id] === void 0;\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nasync function loadLazyRouteModule(route, mapRouteProperties2, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  Object.assign(routeToUpdate, routeUpdates);\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties2(routeToUpdate), {\n    lazy: void 0\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename, v7_relativeSplatPath, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        let handlerError;\n        let values = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties2, manifest)\n        ]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);\n        handler = match.route[type];\n        if (handler) {\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return {\n            type: ResultType.data,\n            data: void 0\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== void 0, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n      } else if (!opts.isStaticRequest) {\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        data = await result.json();\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      loaderData[id] = void 0;\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = void 0;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    if (controller && controller.signal.aborted) {\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== void 0) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== void 0 && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = 'No route matches URL \"' + pathname + '\"';\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find((m) => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then((result2) => {\n        if (result2) {\n          results[index] = result2 || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json: json3\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json3 !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: json3,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json3 = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json3 || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json3 = {};\n    for (let [k, v] of transitions) {\n      json3[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json3));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\nfunction _extends2() {\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nvar DataRouterContext = React.createContext(null);\nif (true) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = React.createContext(null);\nif (true) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = React.createContext(null);\nif (true) {\n  AwaitContext.displayName = \"Await\";\n}\nvar NavigationContext = React.createContext(null);\nif (true) {\n  NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = React.createContext(null);\nif (true) {\n  LocationContext.displayName = \"Location\";\n}\nvar RouteContext = React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (true) {\n  RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = React.createContext(null);\nif (true) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\nvar navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\";\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    React.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    future,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    true ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nvar OutletContext = React.createContext(null);\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    future\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (true) {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + `parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n` + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (true) {\n    true ? warning(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : void 0;\n    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.') : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n    ]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n    ])\n  })), parentMatches, dataRouterState, future);\n  if (locationArg && renderedMatches) {\n    return React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends2({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (true) {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = React.createElement(React.Fragment, null, React.createElement(\"p\", null, \" Hey developer \"), React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return React.createElement(React.Fragment, null, React.createElement(\"h2\", null, \"Unexpected Application Error!\"), React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nvar defaultErrorElement = React.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error !== void 0 ? React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n};\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? true ? invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.loader && match.route.id && dataRouterState.loaderData[match.route.id] === void 0 && (!dataRouterState.errors || dataRouterState.errors[match.route.id] === void 0)) {\n        renderFallback = true;\n        if (fallbackIndex >= 0) {\n          renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n        } else {\n          renderedMatches = [renderedMatches[0]];\n        }\n        break;\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : void 0;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        children = React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return React.createElement(RenderedRoute, {\n        match,\n        routeContext: {\n          outlet,\n          matches: matches2,\n          isDataRoute: dataRouterState != null\n        },\n        children\n      });\n    };\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches: matches2,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = function(DataRouterHook3) {\n  DataRouterHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook3;\n}(DataRouterHook || {});\nvar DataRouterStateHook = function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook3[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook3[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook3[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook3[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook3[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook3[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook3[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook3;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return void 0;\n  }\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n  if (error !== void 0) {\n    return error;\n  }\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback((arg) => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends2({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends2({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    true ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends2({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    true ? warning(false, message) : void 0;\n  }\n}\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = React[START_TRANSITION];\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    future,\n    static: isStatic\n  } = React.useContext(NavigationContext);\n  true ? warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(_props) {\n  true ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false);\n}\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false,\n    future\n  } = _ref5;\n  !!useInRouterContext() ? true ? invariant(false, \"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.\") : invariant(false) : void 0;\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp,\n    future: _extends2({\n      v7_relativeSplatPath: false\n    }, future)\n  }), [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  true ? warning(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, React.createElement(LocationContext.Provider, {\n    children,\n    value: locationContext\n  }));\n}\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return React.createElement(AwaitErrorBoundary, {\n    resolve,\n    errorElement\n  }, React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = function(AwaitRenderStatus2) {\n  AwaitRenderStatus2[AwaitRenderStatus2[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus2;\n}(AwaitRenderStatus || {});\nvar neverSettledPromise = new Promise(() => {\n});\nvar AwaitErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then((data) => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), (error) => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children\n      });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return React.createElement(React.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? true ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? true ? invariant(false, \"An index route cannot have child routes.\") : invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (true) {\n      if (route.element) {\n        true ? warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: React.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (true) {\n      if (route.hydrateFallbackElement) {\n        true ? warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: React.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (true) {\n      if (route.errorElement) {\n        true ? warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends2({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\nfunction _extends3() {\n  _extends3 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends3.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    true ? warning(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error('Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">');\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\nvar _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"];\nvar _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"];\nvar _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends3({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors)\n    return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nvar ViewTransitionContext = React2.createContext({\n  isTransitioning: false\n});\nif (true) {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nvar FetchersContext = React2.createContext(/* @__PURE__ */ new Map());\nif (true) {\n  FetchersContext.displayName = \"Fetchers\";\n}\nvar START_TRANSITION2 = \"startTransition\";\nvar startTransitionImpl2 = React2[START_TRANSITION2];\nvar FLUSH_SYNC = \"flushSync\";\nvar flushSyncImpl = ReactDOM[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl2) {\n    startTransitionImpl2(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React2.useState(router.state);\n  let [pendingState, setPendingState] = React2.useState();\n  let [vtContext, setVtContext] = React2.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React2.useState();\n  let [transition, setTransition] = React2.useState();\n  let [interruption, setInterruption] = React2.useState();\n  let fetcherData = React2.useRef(/* @__PURE__ */ new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React2.useCallback((cb) => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React2.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== void 0) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    if (flushSync) {\n      flushSyncSafe(() => {\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(void 0);\n          setTransition(void 0);\n          setPendingState(void 0);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    if (transition) {\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  React2.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React2.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition2);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  React2.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  React2.useEffect(() => {\n    true ? warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n  }, []);\n  let navigator = React2.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React2.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  return React2.createElement(React2.Fragment, null, React2.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, React2.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, React2.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, React2.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, React2.createElement(Router, {\n    basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? React2.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref4;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref5;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nif (true) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React2.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n    onClick,\n    relative,\n    reloadDocument,\n    replace,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to)) {\n    absoluteHref = to;\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        true ? warning(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;\n      }\n    }\n  }\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick)\n      onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React2.createElement(\"a\", _extends3({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref,\n      target\n    }))\n  );\n});\nif (true) {\n  Link.displayName = \"Link\";\n}\nvar NavLink = React2.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    unstable_viewTransition,\n    children\n  } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React2.useContext(DataRouterStateContext);\n  let {\n    navigator\n  } = React2.useContext(NavigationContext);\n  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return React2.createElement(Link, _extends3({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className,\n    ref,\n    style,\n    to,\n    unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n  NavLink.displayName = \"NavLink\";\n}\nvar Form = React2.forwardRef((_ref9, forwardedRef) => {\n  let {\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = (event) => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented)\n      return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return React2.createElement(\"form\", _extends3({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (true) {\n  Form.displayName = \"Form\";\n}\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (true) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\nvar DataRouterHook2;\n(function(DataRouterHook3) {\n  DataRouterHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook3[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook3[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook3[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook2 || (DataRouterHook2 = {}));\nvar DataRouterStateHook2;\n(function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook3[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));\nfunction getDataRouterConsoleError2(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext2(hookName) {\n  let ctx = React2.useContext(DataRouterContext);\n  !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = React2.useContext(DataRouterStateContext);\n  !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React2.useCallback((event) => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\nfunction useSearchParams(defaultInit) {\n  true ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\\n\\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.\") : void 0;\n  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React2.useRef(false);\n  let location = useLocation();\n  let searchParams = React2.useMemo(() => (\n    // Only merge in the defaults if we haven't yet called setSearchParams.\n    // Once we call that we want those to take precedence, otherwise you can't\n    // remove a param with setSearchParams({}) if it has an initial value\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)\n  ), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React2.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseSubmit);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return React2.useCallback(function(target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let routeContext = React2.useContext(RouteContext);\n  !routeContext ? true ? invariant(false, \"useFormAction must be used inside a RouteContext\") : invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  let path = _extends3({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseFetcher);\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetcher);\n  let fetcherData = React2.useContext(FetchersContext);\n  let route = React2.useContext(RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? true ? invariant(false, \"useFetcher must be used inside a FetchersContext\") : invariant(false) : void 0;\n  !route ? true ? invariant(false, \"useFetcher must be used inside a RouteContext\") : invariant(false) : void 0;\n  !(routeId != null) ? true ? invariant(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  let [fetcherKey, setFetcherKey] = React2.useState(key || \"\");\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  React2.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  let load = React2.useCallback((href, opts) => {\n    !routeId ? true ? invariant(false, \"No routeId available for fetcher.load()\") : invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React2.useCallback((target, opts) => {\n    submitImpl(target, _extends3({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React2.useMemo(() => {\n    let FetcherForm2 = React2.forwardRef((props, ref) => {\n      return React2.createElement(Form, _extends3({}, props, {\n        navigate: false,\n        fetcherKey,\n        ref\n      }));\n    });\n    if (true) {\n      FetcherForm2.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React2.useMemo(() => _extends3({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetchers);\n  return Array.from(state.fetchers.entries()).map((_ref11) => {\n    let [key, fetcher] = _ref11;\n    return _extends3({}, fetcher, {\n      key\n    });\n  });\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  React2.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(React2.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      true ? warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  if (typeof document !== \"undefined\") {\n    React2.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    React2.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location2, matches2) => getKey(\n        // Strip the basename to match useLocation()\n        _extends3({}, location2, {\n          pathname: stripBasename(location2.pathname, basename) || location2.pathname\n        }),\n        matches2\n      ) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    React2.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React2.useContext(ViewTransitionContext);\n  !(vtContext != null) ? true ? invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\") : invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\nexport {\n  AbortedDeferredError,\n  Await,\n  BrowserRouter,\n  Form,\n  HashRouter,\n  Link,\n  MemoryRouter,\n  NavLink,\n  Navigate,\n  Action as NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  ScrollRestoration,\n  DataRouterContext as UNSAFE_DataRouterContext,\n  DataRouterStateContext as UNSAFE_DataRouterStateContext,\n  FetchersContext as UNSAFE_FetchersContext,\n  LocationContext as UNSAFE_LocationContext,\n  NavigationContext as UNSAFE_NavigationContext,\n  RouteContext as UNSAFE_RouteContext,\n  ViewTransitionContext as UNSAFE_ViewTransitionContext,\n  useRouteId as UNSAFE_useRouteId,\n  useScrollRestoration as UNSAFE_useScrollRestoration,\n  createBrowserRouter,\n  createHashRouter,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromChildren as createRoutesFromElements,\n  createSearchParams,\n  defer,\n  generatePath,\n  isRouteErrorResponse,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  redirectDocument,\n  renderMatches,\n  resolvePath,\n  HistoryRouter as unstable_HistoryRouter,\n  usePrompt as unstable_usePrompt,\n  useViewTransitionState as unstable_useViewTransitionState,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useBeforeUnload,\n  useBlocker,\n  useFetcher,\n  useFetchers,\n  useFormAction,\n  useHref,\n  useInRouterContext,\n  useLinkClickHandler,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n  useSearchParams,\n  useSubmit\n};\n/*! Bundled license information:\n\n@remix-run/router/dist/router.js:\n  (**\n   * @remix-run/router v1.14.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router/dist/index.js:\n  (**\n   * React Router v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router-dom/dist/index.js:\n  (**\n   * React Router DOM v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n*/\n",
      "start": 1703474742326,
      "end": 1703474742428,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/app/node_modules/.vite/deps/react-router-dom.js?v=a66dbd78\"],\n  \"sourcesContent\": [\"\\\"use strict\\\";\\n(() => {\\n  var __create = Object.create;\\n  var __defProp = Object.defineProperty;\\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\\n  var __getOwnPropNames = Object.getOwnPropertyNames;\\n  var __getProtoOf = Object.getPrototypeOf;\\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\\n  var __esm = (fn, res) => function __init() {\\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\\n  };\\n  var __commonJS = (cb, mod) => function __require() {\\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\\n  };\\n  var __copyProps = (to, from, except, desc) => {\\n    if (from && typeof from === \\\"object\\\" || typeof from === \\\"function\\\") {\\n      for (let key of __getOwnPropNames(from))\\n        if (!__hasOwnProp.call(to, key) && key !== except)\\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\\n    }\\n    return to;\\n  };\\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\\n    // If the importer is in node compatibility mode or this is not an ESM\\n    // file that has been converted to a CommonJS file using a Babel-\\n    // compatible transform (i.e. \\\"__esModule\\\" has not been set), then set\\n    // \\\"default\\\" to the CommonJS \\\"module.exports\\\" for node compatibility.\\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\\"default\\\", { value: mod, enumerable: true }) : target,\\n    mod\\n  ));\\n\\n  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\\n  var require_base64_js = __commonJS({\\n    \\\"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\\\"(exports) {\\n      \\\"use strict\\\";\\n      init_dist();\\n      exports.byteLength = byteLength;\\n      exports.toByteArray = toByteArray;\\n      exports.fromByteArray = fromByteArray;\\n      var lookup = [];\\n      var revLookup = [];\\n      var Arr = typeof Uint8Array !== \\\"undefined\\\" ? Uint8Array : Array;\\n      var code = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n      for (i = 0, len = code.length; i < len; ++i) {\\n        lookup[i] = code[i];\\n        revLookup[code.charCodeAt(i)] = i;\\n      }\\n      var i;\\n      var len;\\n      revLookup[\\\"-\\\".charCodeAt(0)] = 62;\\n      revLookup[\\\"_\\\".charCodeAt(0)] = 63;\\n      function getLens(b64) {\\n        var len2 = b64.length;\\n        if (len2 % 4 > 0) {\\n          throw new Error(\\\"Invalid string. Length must be a multiple of 4\\\");\\n        }\\n        var validLen = b64.indexOf(\\\"=\\\");\\n        if (validLen === -1)\\n          validLen = len2;\\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\\n        return [validLen, placeHoldersLen];\\n      }\\n      function byteLength(b64) {\\n        var lens = getLens(b64);\\n        var validLen = lens[0];\\n        var placeHoldersLen = lens[1];\\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\\n      }\\n      function _byteLength(b64, validLen, placeHoldersLen) {\\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\\n      }\\n      function toByteArray(b64) {\\n        var tmp;\\n        var lens = getLens(b64);\\n        var validLen = lens[0];\\n        var placeHoldersLen = lens[1];\\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\\n        var curByte = 0;\\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\\n        var i2;\\n        for (i2 = 0; i2 < len2; i2 += 4) {\\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\\n          arr[curByte++] = tmp >> 16 & 255;\\n          arr[curByte++] = tmp >> 8 & 255;\\n          arr[curByte++] = tmp & 255;\\n        }\\n        if (placeHoldersLen === 2) {\\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\\n          arr[curByte++] = tmp & 255;\\n        }\\n        if (placeHoldersLen === 1) {\\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\\n          arr[curByte++] = tmp >> 8 & 255;\\n          arr[curByte++] = tmp & 255;\\n        }\\n        return arr;\\n      }\\n      function tripletToBase64(num) {\\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\\n      }\\n      function encodeChunk(uint8, start, end) {\\n        var tmp;\\n        var output = [];\\n        for (var i2 = start; i2 < end; i2 += 3) {\\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\\n          output.push(tripletToBase64(tmp));\\n        }\\n        return output.join(\\\"\\\");\\n      }\\n      function fromByteArray(uint8) {\\n        var tmp;\\n        var len2 = uint8.length;\\n        var extraBytes = len2 % 3;\\n        var parts = [];\\n        var maxChunkLength = 16383;\\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\\n        }\\n        if (extraBytes === 1) {\\n          tmp = uint8[len2 - 1];\\n          parts.push(\\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \\\"==\\\"\\n          );\\n        } else if (extraBytes === 2) {\\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\\n          parts.push(\\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \\\"=\\\"\\n          );\\n        }\\n        return parts.join(\\\"\\\");\\n      }\\n    }\\n  });\\n\\n  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\\n  var require_ieee754 = __commonJS({\\n    \\\"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\\\"(exports) {\\n      init_dist();\\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\\n        var e, m;\\n        var eLen = nBytes * 8 - mLen - 1;\\n        var eMax = (1 << eLen) - 1;\\n        var eBias = eMax >> 1;\\n        var nBits = -7;\\n        var i = isLE ? nBytes - 1 : 0;\\n        var d = isLE ? -1 : 1;\\n        var s2 = buffer[offset + i];\\n        i += d;\\n        e = s2 & (1 << -nBits) - 1;\\n        s2 >>= -nBits;\\n        nBits += eLen;\\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\\n        }\\n        m = e & (1 << -nBits) - 1;\\n        e >>= -nBits;\\n        nBits += mLen;\\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\\n        }\\n        if (e === 0) {\\n          e = 1 - eBias;\\n        } else if (e === eMax) {\\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\\n        } else {\\n          m = m + Math.pow(2, mLen);\\n          e = e - eBias;\\n        }\\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\\n      };\\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\\n        var e, m, c;\\n        var eLen = nBytes * 8 - mLen - 1;\\n        var eMax = (1 << eLen) - 1;\\n        var eBias = eMax >> 1;\\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\\n        var i = isLE ? 0 : nBytes - 1;\\n        var d = isLE ? 1 : -1;\\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\\n        value = Math.abs(value);\\n        if (isNaN(value) || value === Infinity) {\\n          m = isNaN(value) ? 1 : 0;\\n          e = eMax;\\n        } else {\\n          e = Math.floor(Math.log(value) / Math.LN2);\\n          if (value * (c = Math.pow(2, -e)) < 1) {\\n            e--;\\n            c *= 2;\\n          }\\n          if (e + eBias >= 1) {\\n            value += rt / c;\\n          } else {\\n            value += rt * Math.pow(2, 1 - eBias);\\n          }\\n          if (value * c >= 2) {\\n            e++;\\n            c /= 2;\\n          }\\n          if (e + eBias >= eMax) {\\n            m = 0;\\n            e = eMax;\\n          } else if (e + eBias >= 1) {\\n            m = (value * c - 1) * Math.pow(2, mLen);\\n            e = e + eBias;\\n          } else {\\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\\n            e = 0;\\n          }\\n        }\\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\\n        }\\n        e = e << mLen | m;\\n        eLen += mLen;\\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\\n        }\\n        buffer[offset + i - d] |= s2 * 128;\\n      };\\n    }\\n  });\\n\\n  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\\n  var require_buffer = __commonJS({\\n    \\\"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\\\"(exports) {\\n      \\\"use strict\\\";\\n      init_dist();\\n      var base64 = require_base64_js();\\n      var ieee754 = require_ieee754();\\n      var customInspectSymbol = typeof Symbol === \\\"function\\\" && typeof Symbol[\\\"for\\\"] === \\\"function\\\" ? Symbol[\\\"for\\\"](\\\"nodejs.util.inspect.custom\\\") : null;\\n      exports.Buffer = Buffer2;\\n      exports.SlowBuffer = SlowBuffer;\\n      exports.INSPECT_MAX_BYTES = 50;\\n      var K_MAX_LENGTH = 2147483647;\\n      exports.kMaxLength = K_MAX_LENGTH;\\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \\\"undefined\\\" && typeof console.error === \\\"function\\\") {\\n        console.error(\\n          \\\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\\\"\\n        );\\n      }\\n      function typedArraySupport() {\\n        try {\\n          const arr = new GlobalUint8Array(1);\\n          const proto = { foo: function() {\\n            return 42;\\n          } };\\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\\n          Object.setPrototypeOf(arr, proto);\\n          return arr.foo() === 42;\\n        } catch (e) {\\n          return false;\\n        }\\n      }\\n      Object.defineProperty(Buffer2.prototype, \\\"parent\\\", {\\n        enumerable: true,\\n        get: function() {\\n          if (!Buffer2.isBuffer(this))\\n            return void 0;\\n          return this.buffer;\\n        }\\n      });\\n      Object.defineProperty(Buffer2.prototype, \\\"offset\\\", {\\n        enumerable: true,\\n        get: function() {\\n          if (!Buffer2.isBuffer(this))\\n            return void 0;\\n          return this.byteOffset;\\n        }\\n      });\\n      function createBuffer(length) {\\n        if (length > K_MAX_LENGTH) {\\n          throw new RangeError('The value \\\"' + length + '\\\" is invalid for option \\\"size\\\"');\\n        }\\n        const buf = new GlobalUint8Array(length);\\n        Object.setPrototypeOf(buf, Buffer2.prototype);\\n        return buf;\\n      }\\n      function Buffer2(arg, encodingOrOffset, length) {\\n        if (typeof arg === \\\"number\\\") {\\n          if (typeof encodingOrOffset === \\\"string\\\") {\\n            throw new TypeError(\\n              'The \\\"string\\\" argument must be of type string. Received type number'\\n            );\\n          }\\n          return allocUnsafe(arg);\\n        }\\n        return from(arg, encodingOrOffset, length);\\n      }\\n      Buffer2.poolSize = 8192;\\n      function from(value, encodingOrOffset, length) {\\n        if (typeof value === \\\"string\\\") {\\n          return fromString(value, encodingOrOffset);\\n        }\\n        if (GlobalArrayBuffer.isView(value)) {\\n          return fromArrayView(value);\\n        }\\n        if (value == null) {\\n          throw new TypeError(\\n            \\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\\" + typeof value\\n          );\\n        }\\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\\n          return fromArrayBuffer(value, encodingOrOffset, length);\\n        }\\n        if (typeof GlobalSharedArrayBuffer !== \\\"undefined\\\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\\n          return fromArrayBuffer(value, encodingOrOffset, length);\\n        }\\n        if (typeof value === \\\"number\\\") {\\n          throw new TypeError(\\n            'The \\\"value\\\" argument must not be of type number. Received type number'\\n          );\\n        }\\n        const valueOf = value.valueOf && value.valueOf();\\n        if (valueOf != null && valueOf !== value) {\\n          return Buffer2.from(valueOf, encodingOrOffset, length);\\n        }\\n        const b = fromObject(value);\\n        if (b)\\n          return b;\\n        if (typeof Symbol !== \\\"undefined\\\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \\\"function\\\") {\\n          return Buffer2.from(value[Symbol.toPrimitive](\\\"string\\\"), encodingOrOffset, length);\\n        }\\n        throw new TypeError(\\n          \\\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \\\" + typeof value\\n        );\\n      }\\n      Buffer2.from = function(value, encodingOrOffset, length) {\\n        return from(value, encodingOrOffset, length);\\n      };\\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\\n      function assertSize(size) {\\n        if (typeof size !== \\\"number\\\") {\\n          throw new TypeError('\\\"size\\\" argument must be of type number');\\n        } else if (size < 0) {\\n          throw new RangeError('The value \\\"' + size + '\\\" is invalid for option \\\"size\\\"');\\n        }\\n      }\\n      function alloc(size, fill, encoding) {\\n        assertSize(size);\\n        if (size <= 0) {\\n          return createBuffer(size);\\n        }\\n        if (fill !== void 0) {\\n          return typeof encoding === \\\"string\\\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\\n        }\\n        return createBuffer(size);\\n      }\\n      Buffer2.alloc = function(size, fill, encoding) {\\n        return alloc(size, fill, encoding);\\n      };\\n      function allocUnsafe(size) {\\n        assertSize(size);\\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\\n      }\\n      Buffer2.allocUnsafe = function(size) {\\n        return allocUnsafe(size);\\n      };\\n      Buffer2.allocUnsafeSlow = function(size) {\\n        return allocUnsafe(size);\\n      };\\n      function fromString(string, encoding) {\\n        if (typeof encoding !== \\\"string\\\" || encoding === \\\"\\\") {\\n          encoding = \\\"utf8\\\";\\n        }\\n        if (!Buffer2.isEncoding(encoding)) {\\n          throw new TypeError(\\\"Unknown encoding: \\\" + encoding);\\n        }\\n        const length = byteLength(string, encoding) | 0;\\n        let buf = createBuffer(length);\\n        const actual = buf.write(string, encoding);\\n        if (actual !== length) {\\n          buf = buf.slice(0, actual);\\n        }\\n        return buf;\\n      }\\n      function fromArrayLike(array) {\\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\\n        const buf = createBuffer(length);\\n        for (let i = 0; i < length; i += 1) {\\n          buf[i] = array[i] & 255;\\n        }\\n        return buf;\\n      }\\n      function fromArrayView(arrayView) {\\n        if (isInstance(arrayView, GlobalUint8Array)) {\\n          const copy = new GlobalUint8Array(arrayView);\\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\\n        }\\n        return fromArrayLike(arrayView);\\n      }\\n      function fromArrayBuffer(array, byteOffset, length) {\\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\\n          throw new RangeError('\\\"offset\\\" is outside of buffer bounds');\\n        }\\n        if (array.byteLength < byteOffset + (length || 0)) {\\n          throw new RangeError('\\\"length\\\" is outside of buffer bounds');\\n        }\\n        let buf;\\n        if (byteOffset === void 0 && length === void 0) {\\n          buf = new GlobalUint8Array(array);\\n        } else if (length === void 0) {\\n          buf = new GlobalUint8Array(array, byteOffset);\\n        } else {\\n          buf = new GlobalUint8Array(array, byteOffset, length);\\n        }\\n        Object.setPrototypeOf(buf, Buffer2.prototype);\\n        return buf;\\n      }\\n      function fromObject(obj) {\\n        if (Buffer2.isBuffer(obj)) {\\n          const len = checked(obj.length) | 0;\\n          const buf = createBuffer(len);\\n          if (buf.length === 0) {\\n            return buf;\\n          }\\n          obj.copy(buf, 0, 0, len);\\n          return buf;\\n        }\\n        if (obj.length !== void 0) {\\n          if (typeof obj.length !== \\\"number\\\" || numberIsNaN(obj.length)) {\\n            return createBuffer(0);\\n          }\\n          return fromArrayLike(obj);\\n        }\\n        if (obj.type === \\\"Buffer\\\" && Array.isArray(obj.data)) {\\n          return fromArrayLike(obj.data);\\n        }\\n      }\\n      function checked(length) {\\n        if (length >= K_MAX_LENGTH) {\\n          throw new RangeError(\\\"Attempt to allocate Buffer larger than maximum size: 0x\\\" + K_MAX_LENGTH.toString(16) + \\\" bytes\\\");\\n        }\\n        return length | 0;\\n      }\\n      function SlowBuffer(length) {\\n        if (+length != length) {\\n          length = 0;\\n        }\\n        return Buffer2.alloc(+length);\\n      }\\n      Buffer2.isBuffer = function isBuffer(b) {\\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\\n      };\\n      Buffer2.compare = function compare(a, b) {\\n        if (isInstance(a, GlobalUint8Array))\\n          a = Buffer2.from(a, a.offset, a.byteLength);\\n        if (isInstance(b, GlobalUint8Array))\\n          b = Buffer2.from(b, b.offset, b.byteLength);\\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\\n          throw new TypeError(\\n            'The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array'\\n          );\\n        }\\n        if (a === b)\\n          return 0;\\n        let x = a.length;\\n        let y = b.length;\\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\\n          if (a[i] !== b[i]) {\\n            x = a[i];\\n            y = b[i];\\n            break;\\n          }\\n        }\\n        if (x < y)\\n          return -1;\\n        if (y < x)\\n          return 1;\\n        return 0;\\n      };\\n      Buffer2.isEncoding = function isEncoding(encoding) {\\n        switch (String(encoding).toLowerCase()) {\\n          case \\\"hex\\\":\\n          case \\\"utf8\\\":\\n          case \\\"utf-8\\\":\\n          case \\\"ascii\\\":\\n          case \\\"latin1\\\":\\n          case \\\"binary\\\":\\n          case \\\"base64\\\":\\n          case \\\"ucs2\\\":\\n          case \\\"ucs-2\\\":\\n          case \\\"utf16le\\\":\\n          case \\\"utf-16le\\\":\\n            return true;\\n          default:\\n            return false;\\n        }\\n      };\\n      Buffer2.concat = function concat(list, length) {\\n        if (!Array.isArray(list)) {\\n          throw new TypeError('\\\"list\\\" argument must be an Array of Buffers');\\n        }\\n        if (list.length === 0) {\\n          return Buffer2.alloc(0);\\n        }\\n        let i;\\n        if (length === void 0) {\\n          length = 0;\\n          for (i = 0; i < list.length; ++i) {\\n            length += list[i].length;\\n          }\\n        }\\n        const buffer = Buffer2.allocUnsafe(length);\\n        let pos = 0;\\n        for (i = 0; i < list.length; ++i) {\\n          let buf = list[i];\\n          if (isInstance(buf, GlobalUint8Array)) {\\n            if (pos + buf.length > buffer.length) {\\n              if (!Buffer2.isBuffer(buf))\\n                buf = Buffer2.from(buf);\\n              buf.copy(buffer, pos);\\n            } else {\\n              GlobalUint8Array.prototype.set.call(\\n                buffer,\\n                buf,\\n                pos\\n              );\\n            }\\n          } else if (!Buffer2.isBuffer(buf)) {\\n            throw new TypeError('\\\"list\\\" argument must be an Array of Buffers');\\n          } else {\\n            buf.copy(buffer, pos);\\n          }\\n          pos += buf.length;\\n        }\\n        return buffer;\\n      };\\n      function byteLength(string, encoding) {\\n        if (Buffer2.isBuffer(string)) {\\n          return string.length;\\n        }\\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\\n          return string.byteLength;\\n        }\\n        if (typeof string !== \\\"string\\\") {\\n          throw new TypeError(\\n            'The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\\n          );\\n        }\\n        const len = string.length;\\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\\n        if (!mustMatch && len === 0)\\n          return 0;\\n        let loweredCase = false;\\n        for (; ; ) {\\n          switch (encoding) {\\n            case \\\"ascii\\\":\\n            case \\\"latin1\\\":\\n            case \\\"binary\\\":\\n              return len;\\n            case \\\"utf8\\\":\\n            case \\\"utf-8\\\":\\n              return utf8ToBytes(string).length;\\n            case \\\"ucs2\\\":\\n            case \\\"ucs-2\\\":\\n            case \\\"utf16le\\\":\\n            case \\\"utf-16le\\\":\\n              return len * 2;\\n            case \\\"hex\\\":\\n              return len >>> 1;\\n            case \\\"base64\\\":\\n              return base64ToBytes(string).length;\\n            default:\\n              if (loweredCase) {\\n                return mustMatch ? -1 : utf8ToBytes(string).length;\\n              }\\n              encoding = (\\\"\\\" + encoding).toLowerCase();\\n              loweredCase = true;\\n          }\\n        }\\n      }\\n      Buffer2.byteLength = byteLength;\\n      function slowToString(encoding, start, end) {\\n        let loweredCase = false;\\n        if (start === void 0 || start < 0) {\\n          start = 0;\\n        }\\n        if (start > this.length) {\\n          return \\\"\\\";\\n        }\\n        if (end === void 0 || end > this.length) {\\n          end = this.length;\\n        }\\n        if (end <= 0) {\\n          return \\\"\\\";\\n        }\\n        end >>>= 0;\\n        start >>>= 0;\\n        if (end <= start) {\\n          return \\\"\\\";\\n        }\\n        if (!encoding)\\n          encoding = \\\"utf8\\\";\\n        while (true) {\\n          switch (encoding) {\\n            case \\\"hex\\\":\\n              return hexSlice(this, start, end);\\n            case \\\"utf8\\\":\\n            case \\\"utf-8\\\":\\n              return utf8Slice(this, start, end);\\n            case \\\"ascii\\\":\\n              return asciiSlice(this, start, end);\\n            case \\\"latin1\\\":\\n            case \\\"binary\\\":\\n              return latin1Slice(this, start, end);\\n            case \\\"base64\\\":\\n              return base64Slice(this, start, end);\\n            case \\\"ucs2\\\":\\n            case \\\"ucs-2\\\":\\n            case \\\"utf16le\\\":\\n            case \\\"utf-16le\\\":\\n              return utf16leSlice(this, start, end);\\n            default:\\n              if (loweredCase)\\n                throw new TypeError(\\\"Unknown encoding: \\\" + encoding);\\n              encoding = (encoding + \\\"\\\").toLowerCase();\\n              loweredCase = true;\\n          }\\n        }\\n      }\\n      Buffer2.prototype._isBuffer = true;\\n      function swap(b, n, m) {\\n        const i = b[n];\\n        b[n] = b[m];\\n        b[m] = i;\\n      }\\n      Buffer2.prototype.swap16 = function swap16() {\\n        const len = this.length;\\n        if (len % 2 !== 0) {\\n          throw new RangeError(\\\"Buffer size must be a multiple of 16-bits\\\");\\n        }\\n        for (let i = 0; i < len; i += 2) {\\n          swap(this, i, i + 1);\\n        }\\n        return this;\\n      };\\n      Buffer2.prototype.swap32 = function swap32() {\\n        const len = this.length;\\n        if (len % 4 !== 0) {\\n          throw new RangeError(\\\"Buffer size must be a multiple of 32-bits\\\");\\n        }\\n        for (let i = 0; i < len; i += 4) {\\n          swap(this, i, i + 3);\\n          swap(this, i + 1, i + 2);\\n        }\\n        return this;\\n      };\\n      Buffer2.prototype.swap64 = function swap64() {\\n        const len = this.length;\\n        if (len % 8 !== 0) {\\n          throw new RangeError(\\\"Buffer size must be a multiple of 64-bits\\\");\\n        }\\n        for (let i = 0; i < len; i += 8) {\\n          swap(this, i, i + 7);\\n          swap(this, i + 1, i + 6);\\n          swap(this, i + 2, i + 5);\\n          swap(this, i + 3, i + 4);\\n        }\\n        return this;\\n      };\\n      Buffer2.prototype.toString = function toString() {\\n        const length = this.length;\\n        if (length === 0)\\n          return \\\"\\\";\\n        if (arguments.length === 0)\\n          return utf8Slice(this, 0, length);\\n        return slowToString.apply(this, arguments);\\n      };\\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\\n      Buffer2.prototype.equals = function equals(b) {\\n        if (!Buffer2.isBuffer(b))\\n          throw new TypeError(\\\"Argument must be a Buffer\\\");\\n        if (this === b)\\n          return true;\\n        return Buffer2.compare(this, b) === 0;\\n      };\\n      Buffer2.prototype.inspect = function inspect() {\\n        let str = \\\"\\\";\\n        const max = exports.INSPECT_MAX_BYTES;\\n        str = this.toString(\\\"hex\\\", 0, max).replace(/(.{2})/g, \\\"$1 \\\").trim();\\n        if (this.length > max)\\n          str += \\\" ... \\\";\\n        return \\\"<Buffer \\\" + str + \\\">\\\";\\n      };\\n      if (customInspectSymbol) {\\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\\n      }\\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\\n        if (isInstance(target, GlobalUint8Array)) {\\n          target = Buffer2.from(target, target.offset, target.byteLength);\\n        }\\n        if (!Buffer2.isBuffer(target)) {\\n          throw new TypeError(\\n            'The \\\"target\\\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\\n          );\\n        }\\n        if (start === void 0) {\\n          start = 0;\\n        }\\n        if (end === void 0) {\\n          end = target ? target.length : 0;\\n        }\\n        if (thisStart === void 0) {\\n          thisStart = 0;\\n        }\\n        if (thisEnd === void 0) {\\n          thisEnd = this.length;\\n        }\\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\n          throw new RangeError(\\\"out of range index\\\");\\n        }\\n        if (thisStart >= thisEnd && start >= end) {\\n          return 0;\\n        }\\n        if (thisStart >= thisEnd) {\\n          return -1;\\n        }\\n        if (start >= end) {\\n          return 1;\\n        }\\n        start >>>= 0;\\n        end >>>= 0;\\n        thisStart >>>= 0;\\n        thisEnd >>>= 0;\\n        if (this === target)\\n          return 0;\\n        let x = thisEnd - thisStart;\\n        let y = end - start;\\n        const len = Math.min(x, y);\\n        const thisCopy = this.slice(thisStart, thisEnd);\\n        const targetCopy = target.slice(start, end);\\n        for (let i = 0; i < len; ++i) {\\n          if (thisCopy[i] !== targetCopy[i]) {\\n            x = thisCopy[i];\\n            y = targetCopy[i];\\n            break;\\n          }\\n        }\\n        if (x < y)\\n          return -1;\\n        if (y < x)\\n          return 1;\\n        return 0;\\n      };\\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\\n        if (buffer.length === 0)\\n          return -1;\\n        if (typeof byteOffset === \\\"string\\\") {\\n          encoding = byteOffset;\\n          byteOffset = 0;\\n        } else if (byteOffset > 2147483647) {\\n          byteOffset = 2147483647;\\n        } else if (byteOffset < -2147483648) {\\n          byteOffset = -2147483648;\\n        }\\n        byteOffset = +byteOffset;\\n        if (numberIsNaN(byteOffset)) {\\n          byteOffset = dir ? 0 : buffer.length - 1;\\n        }\\n        if (byteOffset < 0)\\n          byteOffset = buffer.length + byteOffset;\\n        if (byteOffset >= buffer.length) {\\n          if (dir)\\n            return -1;\\n          else\\n            byteOffset = buffer.length - 1;\\n        } else if (byteOffset < 0) {\\n          if (dir)\\n            byteOffset = 0;\\n          else\\n            return -1;\\n        }\\n        if (typeof val === \\\"string\\\") {\\n          val = Buffer2.from(val, encoding);\\n        }\\n        if (Buffer2.isBuffer(val)) {\\n          if (val.length === 0) {\\n            return -1;\\n          }\\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\\n        } else if (typeof val === \\\"number\\\") {\\n          val = val & 255;\\n          if (typeof GlobalUint8Array.prototype.indexOf === \\\"function\\\") {\\n            if (dir) {\\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\\n            } else {\\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\\n            }\\n          }\\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\\n        }\\n        throw new TypeError(\\\"val must be string, number or Buffer\\\");\\n      }\\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\\n        let indexSize = 1;\\n        let arrLength = arr.length;\\n        let valLength = val.length;\\n        if (encoding !== void 0) {\\n          encoding = String(encoding).toLowerCase();\\n          if (encoding === \\\"ucs2\\\" || encoding === \\\"ucs-2\\\" || encoding === \\\"utf16le\\\" || encoding === \\\"utf-16le\\\") {\\n            if (arr.length < 2 || val.length < 2) {\\n              return -1;\\n            }\\n            indexSize = 2;\\n            arrLength /= 2;\\n            valLength /= 2;\\n            byteOffset /= 2;\\n          }\\n        }\\n        function read(buf, i2) {\\n          if (indexSize === 1) {\\n            return buf[i2];\\n          } else {\\n            return buf.readUInt16BE(i2 * indexSize);\\n          }\\n        }\\n        let i;\\n        if (dir) {\\n          let foundIndex = -1;\\n          for (i = byteOffset; i < arrLength; i++) {\\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\n              if (foundIndex === -1)\\n                foundIndex = i;\\n              if (i - foundIndex + 1 === valLength)\\n                return foundIndex * indexSize;\\n            } else {\\n              if (foundIndex !== -1)\\n                i -= i - foundIndex;\\n              foundIndex = -1;\\n            }\\n          }\\n        } else {\\n          if (byteOffset + valLength > arrLength)\\n            byteOffset = arrLength - valLength;\\n          for (i = byteOffset; i >= 0; i--) {\\n            let found = true;\\n            for (let j = 0; j < valLength; j++) {\\n              if (read(arr, i + j) !== read(val, j)) {\\n                found = false;\\n                break;\\n              }\\n            }\\n            if (found)\\n              return i;\\n          }\\n        }\\n        return -1;\\n      }\\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\\n        return this.indexOf(val, byteOffset, encoding) !== -1;\\n      };\\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\\n      };\\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\\n      };\\n      function hexWrite(buf, string, offset, length) {\\n        offset = Number(offset) || 0;\\n        const remaining = buf.length - offset;\\n        if (!length) {\\n          length = remaining;\\n        } else {\\n          length = Number(length);\\n          if (length > remaining) {\\n            length = remaining;\\n          }\\n        }\\n        const strLen = string.length;\\n        if (length > strLen / 2) {\\n          length = strLen / 2;\\n        }\\n        let i;\\n        for (i = 0; i < length; ++i) {\\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\\n          if (numberIsNaN(parsed))\\n            return i;\\n          buf[offset + i] = parsed;\\n        }\\n        return i;\\n      }\\n      function utf8Write(buf, string, offset, length) {\\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\\n      }\\n      function asciiWrite(buf, string, offset, length) {\\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\\n      }\\n      function base64Write(buf, string, offset, length) {\\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\\n      }\\n      function ucs2Write(buf, string, offset, length) {\\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\\n      }\\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\\n        if (offset === void 0) {\\n          encoding = \\\"utf8\\\";\\n          length = this.length;\\n          offset = 0;\\n        } else if (length === void 0 && typeof offset === \\\"string\\\") {\\n          encoding = offset;\\n          length = this.length;\\n          offset = 0;\\n        } else if (isFinite(offset)) {\\n          offset = offset >>> 0;\\n          if (isFinite(length)) {\\n            length = length >>> 0;\\n            if (encoding === void 0)\\n              encoding = \\\"utf8\\\";\\n          } else {\\n            encoding = length;\\n            length = void 0;\\n          }\\n        } else {\\n          throw new Error(\\n            \\\"Buffer.write(string, encoding, offset[, length]) is no longer supported\\\"\\n          );\\n        }\\n        const remaining = this.length - offset;\\n        if (length === void 0 || length > remaining)\\n          length = remaining;\\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\\n          throw new RangeError(\\\"Attempt to write outside buffer bounds\\\");\\n        }\\n        if (!encoding)\\n          encoding = \\\"utf8\\\";\\n        let loweredCase = false;\\n        for (; ; ) {\\n          switch (encoding) {\\n            case \\\"hex\\\":\\n              return hexWrite(this, string, offset, length);\\n            case \\\"utf8\\\":\\n            case \\\"utf-8\\\":\\n              return utf8Write(this, string, offset, length);\\n            case \\\"ascii\\\":\\n            case \\\"latin1\\\":\\n            case \\\"binary\\\":\\n              return asciiWrite(this, string, offset, length);\\n            case \\\"base64\\\":\\n              return base64Write(this, string, offset, length);\\n            case \\\"ucs2\\\":\\n            case \\\"ucs-2\\\":\\n            case \\\"utf16le\\\":\\n            case \\\"utf-16le\\\":\\n              return ucs2Write(this, string, offset, length);\\n            default:\\n              if (loweredCase)\\n                throw new TypeError(\\\"Unknown encoding: \\\" + encoding);\\n              encoding = (\\\"\\\" + encoding).toLowerCase();\\n              loweredCase = true;\\n          }\\n        }\\n      };\\n      Buffer2.prototype.toJSON = function toJSON() {\\n        return {\\n          type: \\\"Buffer\\\",\\n          data: Array.prototype.slice.call(this._arr || this, 0)\\n        };\\n      };\\n      function base64Slice(buf, start, end) {\\n        if (start === 0 && end === buf.length) {\\n          return base64.fromByteArray(buf);\\n        } else {\\n          return base64.fromByteArray(buf.slice(start, end));\\n        }\\n      }\\n      function utf8Slice(buf, start, end) {\\n        end = Math.min(buf.length, end);\\n        const res = [];\\n        let i = start;\\n        while (i < end) {\\n          const firstByte = buf[i];\\n          let codePoint = null;\\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\\n          if (i + bytesPerSequence <= end) {\\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\\n            switch (bytesPerSequence) {\\n              case 1:\\n                if (firstByte < 128) {\\n                  codePoint = firstByte;\\n                }\\n                break;\\n              case 2:\\n                secondByte = buf[i + 1];\\n                if ((secondByte & 192) === 128) {\\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\\n                  if (tempCodePoint > 127) {\\n                    codePoint = tempCodePoint;\\n                  }\\n                }\\n                break;\\n              case 3:\\n                secondByte = buf[i + 1];\\n                thirdByte = buf[i + 2];\\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\\n                    codePoint = tempCodePoint;\\n                  }\\n                }\\n                break;\\n              case 4:\\n                secondByte = buf[i + 1];\\n                thirdByte = buf[i + 2];\\n                fourthByte = buf[i + 3];\\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\\n                    codePoint = tempCodePoint;\\n                  }\\n                }\\n            }\\n          }\\n          if (codePoint === null) {\\n            codePoint = 65533;\\n            bytesPerSequence = 1;\\n          } else if (codePoint > 65535) {\\n            codePoint -= 65536;\\n            res.push(codePoint >>> 10 & 1023 | 55296);\\n            codePoint = 56320 | codePoint & 1023;\\n          }\\n          res.push(codePoint);\\n          i += bytesPerSequence;\\n        }\\n        return decodeCodePointsArray(res);\\n      }\\n      var MAX_ARGUMENTS_LENGTH = 4096;\\n      function decodeCodePointsArray(codePoints) {\\n        const len = codePoints.length;\\n        if (len <= MAX_ARGUMENTS_LENGTH) {\\n          return String.fromCharCode.apply(String, codePoints);\\n        }\\n        let res = \\\"\\\";\\n        let i = 0;\\n        while (i < len) {\\n          res += String.fromCharCode.apply(\\n            String,\\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\n          );\\n        }\\n        return res;\\n      }\\n      function asciiSlice(buf, start, end) {\\n        let ret = \\\"\\\";\\n        end = Math.min(buf.length, end);\\n        for (let i = start; i < end; ++i) {\\n          ret += String.fromCharCode(buf[i] & 127);\\n        }\\n        return ret;\\n      }\\n      function latin1Slice(buf, start, end) {\\n        let ret = \\\"\\\";\\n        end = Math.min(buf.length, end);\\n        for (let i = start; i < end; ++i) {\\n          ret += String.fromCharCode(buf[i]);\\n        }\\n        return ret;\\n      }\\n      function hexSlice(buf, start, end) {\\n        const len = buf.length;\\n        if (!start || start < 0)\\n          start = 0;\\n        if (!end || end < 0 || end > len)\\n          end = len;\\n        let out = \\\"\\\";\\n        for (let i = start; i < end; ++i) {\\n          out += hexSliceLookupTable[buf[i]];\\n        }\\n        return out;\\n      }\\n      function utf16leSlice(buf, start, end) {\\n        const bytes = buf.slice(start, end);\\n        let res = \\\"\\\";\\n        for (let i = 0; i < bytes.length - 1; i += 2) {\\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\\n        }\\n        return res;\\n      }\\n      Buffer2.prototype.slice = function slice(start, end) {\\n        const len = this.length;\\n        start = ~~start;\\n        end = end === void 0 ? len : ~~end;\\n        if (start < 0) {\\n          start += len;\\n          if (start < 0)\\n            start = 0;\\n        } else if (start > len) {\\n          start = len;\\n        }\\n        if (end < 0) {\\n          end += len;\\n          if (end < 0)\\n            end = 0;\\n        } else if (end > len) {\\n          end = len;\\n        }\\n        if (end < start)\\n          end = start;\\n        const newBuf = this.subarray(start, end);\\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\\n        return newBuf;\\n      };\\n      function checkOffset(offset, ext, length) {\\n        if (offset % 1 !== 0 || offset < 0)\\n          throw new RangeError(\\\"offset is not uint\\\");\\n        if (offset + ext > length)\\n          throw new RangeError(\\\"Trying to access beyond buffer length\\\");\\n      }\\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, byteLength2, this.length);\\n        let val = this[offset];\\n        let mul = 1;\\n        let i = 0;\\n        while (++i < byteLength2 && (mul *= 256)) {\\n          val += this[offset + i] * mul;\\n        }\\n        return val;\\n      };\\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert) {\\n          checkOffset(offset, byteLength2, this.length);\\n        }\\n        let val = this[offset + --byteLength2];\\n        let mul = 1;\\n        while (byteLength2 > 0 && (mul *= 256)) {\\n          val += this[offset + --byteLength2] * mul;\\n        }\\n        return val;\\n      };\\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 1, this.length);\\n        return this[offset];\\n      };\\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 2, this.length);\\n        return this[offset] | this[offset + 1] << 8;\\n      };\\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 2, this.length);\\n        return this[offset] << 8 | this[offset + 1];\\n      };\\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\\n      };\\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\\n      };\\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\\n        offset = offset >>> 0;\\n        validateNumber(offset, \\\"offset\\\");\\n        const first = this[offset];\\n        const last = this[offset + 7];\\n        if (first === void 0 || last === void 0) {\\n          boundsError(offset, this.length - 8);\\n        }\\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\\n      });\\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\\n        offset = offset >>> 0;\\n        validateNumber(offset, \\\"offset\\\");\\n        const first = this[offset];\\n        const last = this[offset + 7];\\n        if (first === void 0 || last === void 0) {\\n          boundsError(offset, this.length - 8);\\n        }\\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\\n      });\\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, byteLength2, this.length);\\n        let val = this[offset];\\n        let mul = 1;\\n        let i = 0;\\n        while (++i < byteLength2 && (mul *= 256)) {\\n          val += this[offset + i] * mul;\\n        }\\n        mul *= 128;\\n        if (val >= mul)\\n          val -= Math.pow(2, 8 * byteLength2);\\n        return val;\\n      };\\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, byteLength2, this.length);\\n        let i = byteLength2;\\n        let mul = 1;\\n        let val = this[offset + --i];\\n        while (i > 0 && (mul *= 256)) {\\n          val += this[offset + --i] * mul;\\n        }\\n        mul *= 128;\\n        if (val >= mul)\\n          val -= Math.pow(2, 8 * byteLength2);\\n        return val;\\n      };\\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 1, this.length);\\n        if (!(this[offset] & 128))\\n          return this[offset];\\n        return (255 - this[offset] + 1) * -1;\\n      };\\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 2, this.length);\\n        const val = this[offset] | this[offset + 1] << 8;\\n        return val & 32768 ? val | 4294901760 : val;\\n      };\\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 2, this.length);\\n        const val = this[offset + 1] | this[offset] << 8;\\n        return val & 32768 ? val | 4294901760 : val;\\n      };\\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\\n      };\\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\\n      };\\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\\n        offset = offset >>> 0;\\n        validateNumber(offset, \\\"offset\\\");\\n        const first = this[offset];\\n        const last = this[offset + 7];\\n        if (first === void 0 || last === void 0) {\\n          boundsError(offset, this.length - 8);\\n        }\\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\\n      });\\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\\n        offset = offset >>> 0;\\n        validateNumber(offset, \\\"offset\\\");\\n        const first = this[offset];\\n        const last = this[offset + 7];\\n        if (first === void 0 || last === void 0) {\\n          boundsError(offset, this.length - 8);\\n        }\\n        const val = (first << 24) + // Overflow\\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\\n      });\\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return ieee754.read(this, offset, true, 23, 4);\\n      };\\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 4, this.length);\\n        return ieee754.read(this, offset, false, 23, 4);\\n      };\\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 8, this.length);\\n        return ieee754.read(this, offset, true, 52, 8);\\n      };\\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkOffset(offset, 8, this.length);\\n        return ieee754.read(this, offset, false, 52, 8);\\n      };\\n      function checkInt(buf, value, offset, ext, max, min) {\\n        if (!Buffer2.isBuffer(buf))\\n          throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance');\\n        if (value > max || value < min)\\n          throw new RangeError('\\\"value\\\" argument is out of bounds');\\n        if (offset + ext > buf.length)\\n          throw new RangeError(\\\"Index out of range\\\");\\n      }\\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert) {\\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\\n        }\\n        let mul = 1;\\n        let i = 0;\\n        this[offset] = value & 255;\\n        while (++i < byteLength2 && (mul *= 256)) {\\n          this[offset + i] = value / mul & 255;\\n        }\\n        return offset + byteLength2;\\n      };\\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        byteLength2 = byteLength2 >>> 0;\\n        if (!noAssert) {\\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\\n        }\\n        let i = byteLength2 - 1;\\n        let mul = 1;\\n        this[offset + i] = value & 255;\\n        while (--i >= 0 && (mul *= 256)) {\\n          this[offset + i] = value / mul & 255;\\n        }\\n        return offset + byteLength2;\\n      };\\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 1, 255, 0);\\n        this[offset] = value & 255;\\n        return offset + 1;\\n      };\\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 2, 65535, 0);\\n        this[offset] = value & 255;\\n        this[offset + 1] = value >>> 8;\\n        return offset + 2;\\n      };\\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 2, 65535, 0);\\n        this[offset] = value >>> 8;\\n        this[offset + 1] = value & 255;\\n        return offset + 2;\\n      };\\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 4, 4294967295, 0);\\n        this[offset + 3] = value >>> 24;\\n        this[offset + 2] = value >>> 16;\\n        this[offset + 1] = value >>> 8;\\n        this[offset] = value & 255;\\n        return offset + 4;\\n      };\\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 4, 4294967295, 0);\\n        this[offset] = value >>> 24;\\n        this[offset + 1] = value >>> 16;\\n        this[offset + 2] = value >>> 8;\\n        this[offset + 3] = value & 255;\\n        return offset + 4;\\n      };\\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\\n        checkIntBI(value, min, max, buf, offset, 7);\\n        let lo = Number(value & BigInt(4294967295));\\n        buf[offset++] = lo;\\n        lo = lo >> 8;\\n        buf[offset++] = lo;\\n        lo = lo >> 8;\\n        buf[offset++] = lo;\\n        lo = lo >> 8;\\n        buf[offset++] = lo;\\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\\n        buf[offset++] = hi;\\n        hi = hi >> 8;\\n        buf[offset++] = hi;\\n        hi = hi >> 8;\\n        buf[offset++] = hi;\\n        hi = hi >> 8;\\n        buf[offset++] = hi;\\n        return offset;\\n      }\\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\\n        checkIntBI(value, min, max, buf, offset, 7);\\n        let lo = Number(value & BigInt(4294967295));\\n        buf[offset + 7] = lo;\\n        lo = lo >> 8;\\n        buf[offset + 6] = lo;\\n        lo = lo >> 8;\\n        buf[offset + 5] = lo;\\n        lo = lo >> 8;\\n        buf[offset + 4] = lo;\\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\\n        buf[offset + 3] = hi;\\n        hi = hi >> 8;\\n        buf[offset + 2] = hi;\\n        hi = hi >> 8;\\n        buf[offset + 1] = hi;\\n        hi = hi >> 8;\\n        buf[offset] = hi;\\n        return offset + 8;\\n      }\\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\\\"0xffffffffffffffff\\\"));\\n      });\\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\\\"0xffffffffffffffff\\\"));\\n      });\\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert) {\\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\\n        }\\n        let i = 0;\\n        let mul = 1;\\n        let sub = 0;\\n        this[offset] = value & 255;\\n        while (++i < byteLength2 && (mul *= 256)) {\\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\n            sub = 1;\\n          }\\n          this[offset + i] = (value / mul >> 0) - sub & 255;\\n        }\\n        return offset + byteLength2;\\n      };\\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert) {\\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\\n        }\\n        let i = byteLength2 - 1;\\n        let mul = 1;\\n        let sub = 0;\\n        this[offset + i] = value & 255;\\n        while (--i >= 0 && (mul *= 256)) {\\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\n            sub = 1;\\n          }\\n          this[offset + i] = (value / mul >> 0) - sub & 255;\\n        }\\n        return offset + byteLength2;\\n      };\\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 1, 127, -128);\\n        if (value < 0)\\n          value = 255 + value + 1;\\n        this[offset] = value & 255;\\n        return offset + 1;\\n      };\\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 2, 32767, -32768);\\n        this[offset] = value & 255;\\n        this[offset + 1] = value >>> 8;\\n        return offset + 2;\\n      };\\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 2, 32767, -32768);\\n        this[offset] = value >>> 8;\\n        this[offset + 1] = value & 255;\\n        return offset + 2;\\n      };\\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\\n        this[offset] = value & 255;\\n        this[offset + 1] = value >>> 8;\\n        this[offset + 2] = value >>> 16;\\n        this[offset + 3] = value >>> 24;\\n        return offset + 4;\\n      };\\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert)\\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\\n        if (value < 0)\\n          value = 4294967295 + value + 1;\\n        this[offset] = value >>> 24;\\n        this[offset + 1] = value >>> 16;\\n        this[offset + 2] = value >>> 8;\\n        this[offset + 3] = value & 255;\\n        return offset + 4;\\n      };\\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\\\"0x8000000000000000\\\"), BigInt(\\\"0x7fffffffffffffff\\\"));\\n      });\\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\\\"0x8000000000000000\\\"), BigInt(\\\"0x7fffffffffffffff\\\"));\\n      });\\n      function checkIEEE754(buf, value, offset, ext, max, min) {\\n        if (offset + ext > buf.length)\\n          throw new RangeError(\\\"Index out of range\\\");\\n        if (offset < 0)\\n          throw new RangeError(\\\"Index out of range\\\");\\n      }\\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert) {\\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\\n        }\\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\\n        return offset + 4;\\n      }\\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\\n        return writeFloat(this, value, offset, true, noAssert);\\n      };\\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\\n        return writeFloat(this, value, offset, false, noAssert);\\n      };\\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\\n        value = +value;\\n        offset = offset >>> 0;\\n        if (!noAssert) {\\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\\n        }\\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\\n        return offset + 8;\\n      }\\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\\n        return writeDouble(this, value, offset, true, noAssert);\\n      };\\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\\n        return writeDouble(this, value, offset, false, noAssert);\\n      };\\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\\n        if (!Buffer2.isBuffer(target))\\n          throw new TypeError(\\\"argument should be a Buffer\\\");\\n        if (!start)\\n          start = 0;\\n        if (!end && end !== 0)\\n          end = this.length;\\n        if (targetStart >= target.length)\\n          targetStart = target.length;\\n        if (!targetStart)\\n          targetStart = 0;\\n        if (end > 0 && end < start)\\n          end = start;\\n        if (end === start)\\n          return 0;\\n        if (target.length === 0 || this.length === 0)\\n          return 0;\\n        if (targetStart < 0) {\\n          throw new RangeError(\\\"targetStart out of bounds\\\");\\n        }\\n        if (start < 0 || start >= this.length)\\n          throw new RangeError(\\\"Index out of range\\\");\\n        if (end < 0)\\n          throw new RangeError(\\\"sourceEnd out of bounds\\\");\\n        if (end > this.length)\\n          end = this.length;\\n        if (target.length - targetStart < end - start) {\\n          end = target.length - targetStart + start;\\n        }\\n        const len = end - start;\\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \\\"function\\\") {\\n          this.copyWithin(targetStart, start, end);\\n        } else {\\n          GlobalUint8Array.prototype.set.call(\\n            target,\\n            this.subarray(start, end),\\n            targetStart\\n          );\\n        }\\n        return len;\\n      };\\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\\n        if (typeof val === \\\"string\\\") {\\n          if (typeof start === \\\"string\\\") {\\n            encoding = start;\\n            start = 0;\\n            end = this.length;\\n          } else if (typeof end === \\\"string\\\") {\\n            encoding = end;\\n            end = this.length;\\n          }\\n          if (encoding !== void 0 && typeof encoding !== \\\"string\\\") {\\n            throw new TypeError(\\\"encoding must be a string\\\");\\n          }\\n          if (typeof encoding === \\\"string\\\" && !Buffer2.isEncoding(encoding)) {\\n            throw new TypeError(\\\"Unknown encoding: \\\" + encoding);\\n          }\\n          if (val.length === 1) {\\n            const code = val.charCodeAt(0);\\n            if (encoding === \\\"utf8\\\" && code < 128 || encoding === \\\"latin1\\\") {\\n              val = code;\\n            }\\n          }\\n        } else if (typeof val === \\\"number\\\") {\\n          val = val & 255;\\n        } else if (typeof val === \\\"boolean\\\") {\\n          val = Number(val);\\n        }\\n        if (start < 0 || this.length < start || this.length < end) {\\n          throw new RangeError(\\\"Out of range index\\\");\\n        }\\n        if (end <= start) {\\n          return this;\\n        }\\n        start = start >>> 0;\\n        end = end === void 0 ? this.length : end >>> 0;\\n        if (!val)\\n          val = 0;\\n        let i;\\n        if (typeof val === \\\"number\\\") {\\n          for (i = start; i < end; ++i) {\\n            this[i] = val;\\n          }\\n        } else {\\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\\n          const len = bytes.length;\\n          if (len === 0) {\\n            throw new TypeError('The value \\\"' + val + '\\\" is invalid for argument \\\"value\\\"');\\n          }\\n          for (i = 0; i < end - start; ++i) {\\n            this[i + start] = bytes[i % len];\\n          }\\n        }\\n        return this;\\n      };\\n      var errors = {};\\n      function E(sym, getMessage, Base) {\\n        errors[sym] = class NodeError extends Base {\\n          constructor() {\\n            super();\\n            Object.defineProperty(this, \\\"message\\\", {\\n              value: getMessage.apply(this, arguments),\\n              writable: true,\\n              configurable: true\\n            });\\n            this.name = `${this.name} [${sym}]`;\\n            this.stack;\\n            delete this.name;\\n          }\\n          get code() {\\n            return sym;\\n          }\\n          set code(value) {\\n            Object.defineProperty(this, \\\"code\\\", {\\n              configurable: true,\\n              enumerable: true,\\n              value,\\n              writable: true\\n            });\\n          }\\n          toString() {\\n            return `${this.name} [${sym}]: ${this.message}`;\\n          }\\n        };\\n      }\\n      E(\\n        \\\"ERR_BUFFER_OUT_OF_BOUNDS\\\",\\n        function(name) {\\n          if (name) {\\n            return `${name} is outside of buffer bounds`;\\n          }\\n          return \\\"Attempt to access memory outside buffer bounds\\\";\\n        },\\n        RangeError\\n      );\\n      E(\\n        \\\"ERR_INVALID_ARG_TYPE\\\",\\n        function(name, actual) {\\n          return `The \\\"${name}\\\" argument must be of type number. Received type ${typeof actual}`;\\n        },\\n        TypeError\\n      );\\n      E(\\n        \\\"ERR_OUT_OF_RANGE\\\",\\n        function(str, range, input) {\\n          let msg = `The value of \\\"${str}\\\" is out of range.`;\\n          let received = input;\\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\\n            received = addNumericalSeparator(String(input));\\n          } else if (typeof input === \\\"bigint\\\") {\\n            received = String(input);\\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\\n              received = addNumericalSeparator(received);\\n            }\\n            received += \\\"n\\\";\\n          }\\n          msg += ` It must be ${range}. Received ${received}`;\\n          return msg;\\n        },\\n        RangeError\\n      );\\n      function addNumericalSeparator(val) {\\n        let res = \\\"\\\";\\n        let i = val.length;\\n        const start = val[0] === \\\"-\\\" ? 1 : 0;\\n        for (; i >= start + 4; i -= 3) {\\n          res = `_${val.slice(i - 3, i)}${res}`;\\n        }\\n        return `${val.slice(0, i)}${res}`;\\n      }\\n      function checkBounds(buf, offset, byteLength2) {\\n        validateNumber(offset, \\\"offset\\\");\\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\\n          boundsError(offset, buf.length - (byteLength2 + 1));\\n        }\\n      }\\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\\n        if (value > max || value < min) {\\n          const n = typeof min === \\\"bigint\\\" ? \\\"n\\\" : \\\"\\\";\\n          let range;\\n          if (byteLength2 > 3) {\\n            if (min === 0 || min === BigInt(0)) {\\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\\n            } else {\\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\\n            }\\n          } else {\\n            range = `>= ${min}${n} and <= ${max}${n}`;\\n          }\\n          throw new errors.ERR_OUT_OF_RANGE(\\\"value\\\", range, value);\\n        }\\n        checkBounds(buf, offset, byteLength2);\\n      }\\n      function validateNumber(value, name) {\\n        if (typeof value !== \\\"number\\\") {\\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \\\"number\\\", value);\\n        }\\n      }\\n      function boundsError(value, length, type) {\\n        if (Math.floor(value) !== value) {\\n          validateNumber(value, type);\\n          throw new errors.ERR_OUT_OF_RANGE(type || \\\"offset\\\", \\\"an integer\\\", value);\\n        }\\n        if (length < 0) {\\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\\n        }\\n        throw new errors.ERR_OUT_OF_RANGE(\\n          type || \\\"offset\\\",\\n          `>= ${type ? 1 : 0} and <= ${length}`,\\n          value\\n        );\\n      }\\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\\n      function base64clean(str) {\\n        str = str.split(\\\"=\\\")[0];\\n        str = str.trim().replace(INVALID_BASE64_RE, \\\"\\\");\\n        if (str.length < 2)\\n          return \\\"\\\";\\n        while (str.length % 4 !== 0) {\\n          str = str + \\\"=\\\";\\n        }\\n        return str;\\n      }\\n      function utf8ToBytes(string, units) {\\n        units = units || Infinity;\\n        let codePoint;\\n        const length = string.length;\\n        let leadSurrogate = null;\\n        const bytes = [];\\n        for (let i = 0; i < length; ++i) {\\n          codePoint = string.charCodeAt(i);\\n          if (codePoint > 55295 && codePoint < 57344) {\\n            if (!leadSurrogate) {\\n              if (codePoint > 56319) {\\n                if ((units -= 3) > -1)\\n                  bytes.push(239, 191, 189);\\n                continue;\\n              } else if (i + 1 === length) {\\n                if ((units -= 3) > -1)\\n                  bytes.push(239, 191, 189);\\n                continue;\\n              }\\n              leadSurrogate = codePoint;\\n              continue;\\n            }\\n            if (codePoint < 56320) {\\n              if ((units -= 3) > -1)\\n                bytes.push(239, 191, 189);\\n              leadSurrogate = codePoint;\\n              continue;\\n            }\\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\\n          } else if (leadSurrogate) {\\n            if ((units -= 3) > -1)\\n              bytes.push(239, 191, 189);\\n          }\\n          leadSurrogate = null;\\n          if (codePoint < 128) {\\n            if ((units -= 1) < 0)\\n              break;\\n            bytes.push(codePoint);\\n          } else if (codePoint < 2048) {\\n            if ((units -= 2) < 0)\\n              break;\\n            bytes.push(\\n              codePoint >> 6 | 192,\\n              codePoint & 63 | 128\\n            );\\n          } else if (codePoint < 65536) {\\n            if ((units -= 3) < 0)\\n              break;\\n            bytes.push(\\n              codePoint >> 12 | 224,\\n              codePoint >> 6 & 63 | 128,\\n              codePoint & 63 | 128\\n            );\\n          } else if (codePoint < 1114112) {\\n            if ((units -= 4) < 0)\\n              break;\\n            bytes.push(\\n              codePoint >> 18 | 240,\\n              codePoint >> 12 & 63 | 128,\\n              codePoint >> 6 & 63 | 128,\\n              codePoint & 63 | 128\\n            );\\n          } else {\\n            throw new Error(\\\"Invalid code point\\\");\\n          }\\n        }\\n        return bytes;\\n      }\\n      function asciiToBytes(str) {\\n        const byteArray = [];\\n        for (let i = 0; i < str.length; ++i) {\\n          byteArray.push(str.charCodeAt(i) & 255);\\n        }\\n        return byteArray;\\n      }\\n      function utf16leToBytes(str, units) {\\n        let c, hi, lo;\\n        const byteArray = [];\\n        for (let i = 0; i < str.length; ++i) {\\n          if ((units -= 2) < 0)\\n            break;\\n          c = str.charCodeAt(i);\\n          hi = c >> 8;\\n          lo = c % 256;\\n          byteArray.push(lo);\\n          byteArray.push(hi);\\n        }\\n        return byteArray;\\n      }\\n      function base64ToBytes(str) {\\n        return base64.toByteArray(base64clean(str));\\n      }\\n      function blitBuffer(src, dst, offset, length) {\\n        let i;\\n        for (i = 0; i < length; ++i) {\\n          if (i + offset >= dst.length || i >= src.length)\\n            break;\\n          dst[i + offset] = src[i];\\n        }\\n        return i;\\n      }\\n      function isInstance(obj, type) {\\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\\n      }\\n      function numberIsNaN(obj) {\\n        return obj !== obj;\\n      }\\n      var hexSliceLookupTable = function() {\\n        const alphabet = \\\"0123456789abcdef\\\";\\n        const table = new Array(256);\\n        for (let i = 0; i < 16; ++i) {\\n          const i16 = i * 16;\\n          for (let j = 0; j < 16; ++j) {\\n            table[i16 + j] = alphabet[i] + alphabet[j];\\n          }\\n        }\\n        return table;\\n      }();\\n      function defineBigIntMethod(fn) {\\n        return typeof BigInt === \\\"undefined\\\" ? BufferBigIntNotDefined : fn;\\n      }\\n      function BufferBigIntNotDefined() {\\n        throw new Error(\\\"BigInt not supported\\\");\\n      }\\n    }\\n  });\\n\\n  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\\n  var require_browser = __commonJS({\\n    \\\"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\\\"(exports, module) {\\n      init_dist();\\n      var process = module.exports = {};\\n      var cachedSetTimeout;\\n      var cachedClearTimeout;\\n      function defaultSetTimout() {\\n        throw new Error(\\\"setTimeout has not been defined\\\");\\n      }\\n      function defaultClearTimeout() {\\n        throw new Error(\\\"clearTimeout has not been defined\\\");\\n      }\\n      (function() {\\n        try {\\n          if (typeof setTimeout === \\\"function\\\") {\\n            cachedSetTimeout = setTimeout;\\n          } else {\\n            cachedSetTimeout = defaultSetTimout;\\n          }\\n        } catch (e) {\\n          cachedSetTimeout = defaultSetTimout;\\n        }\\n        try {\\n          if (typeof clearTimeout === \\\"function\\\") {\\n            cachedClearTimeout = clearTimeout;\\n          } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n          }\\n        } catch (e) {\\n          cachedClearTimeout = defaultClearTimeout;\\n        }\\n      })();\\n      function runTimeout(fun) {\\n        if (cachedSetTimeout === setTimeout) {\\n          return setTimeout(fun, 0);\\n        }\\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n          cachedSetTimeout = setTimeout;\\n          return setTimeout(fun, 0);\\n        }\\n        try {\\n          return cachedSetTimeout(fun, 0);\\n        } catch (e) {\\n          try {\\n            return cachedSetTimeout.call(null, fun, 0);\\n          } catch (e2) {\\n            return cachedSetTimeout.call(this, fun, 0);\\n          }\\n        }\\n      }\\n      function runClearTimeout(marker) {\\n        if (cachedClearTimeout === clearTimeout) {\\n          return clearTimeout(marker);\\n        }\\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n          cachedClearTimeout = clearTimeout;\\n          return clearTimeout(marker);\\n        }\\n        try {\\n          return cachedClearTimeout(marker);\\n        } catch (e) {\\n          try {\\n            return cachedClearTimeout.call(null, marker);\\n          } catch (e2) {\\n            return cachedClearTimeout.call(this, marker);\\n          }\\n        }\\n      }\\n      var queue = [];\\n      var draining = false;\\n      var currentQueue;\\n      var queueIndex = -1;\\n      function cleanUpNextTick() {\\n        if (!draining || !currentQueue) {\\n          return;\\n        }\\n        draining = false;\\n        if (currentQueue.length) {\\n          queue = currentQueue.concat(queue);\\n        } else {\\n          queueIndex = -1;\\n        }\\n        if (queue.length) {\\n          drainQueue();\\n        }\\n      }\\n      function drainQueue() {\\n        if (draining) {\\n          return;\\n        }\\n        var timeout = runTimeout(cleanUpNextTick);\\n        draining = true;\\n        var len = queue.length;\\n        while (len) {\\n          currentQueue = queue;\\n          queue = [];\\n          while (++queueIndex < len) {\\n            if (currentQueue) {\\n              currentQueue[queueIndex].run();\\n            }\\n          }\\n          queueIndex = -1;\\n          len = queue.length;\\n        }\\n        currentQueue = null;\\n        draining = false;\\n        runClearTimeout(timeout);\\n      }\\n      process.nextTick = function(fun) {\\n        var args = new Array(arguments.length - 1);\\n        if (arguments.length > 1) {\\n          for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n          }\\n        }\\n        queue.push(new Item(fun, args));\\n        if (queue.length === 1 && !draining) {\\n          runTimeout(drainQueue);\\n        }\\n      };\\n      function Item(fun, array) {\\n        this.fun = fun;\\n        this.array = array;\\n      }\\n      Item.prototype.run = function() {\\n        this.fun.apply(null, this.array);\\n      };\\n      process.title = \\\"browser\\\";\\n      process.browser = true;\\n      process.env = {};\\n      process.argv = [];\\n      process.version = \\\"\\\";\\n      process.versions = {};\\n      function noop() {\\n      }\\n      process.on = noop;\\n      process.addListener = noop;\\n      process.once = noop;\\n      process.off = noop;\\n      process.removeListener = noop;\\n      process.removeAllListeners = noop;\\n      process.emit = noop;\\n      process.prependListener = noop;\\n      process.prependOnceListener = noop;\\n      process.listeners = function(name) {\\n        return [];\\n      };\\n      process.binding = function(name) {\\n        throw new Error(\\\"process.binding is not supported\\\");\\n      };\\n      process.cwd = function() {\\n        return \\\"/\\\";\\n      };\\n      process.chdir = function(dir) {\\n        throw new Error(\\\"process.chdir is not supported\\\");\\n      };\\n      process.umask = function() {\\n        return 0;\\n      };\\n    }\\n  });\\n\\n  // shims/dist/index.js\\n  var import_buffer_polyfill, import_process, o;\\n  var init_dist = __esm({\\n    \\\"shims/dist/index.js\\\"() {\\n      \\\"use strict\\\";\\n      import_buffer_polyfill = __toESM(require_buffer(), 1);\\n      import_process = __toESM(require_browser(), 1);\\n      o = globalThis || void 0 || self;\\n    }\\n  });\\n\\n  // shims/banner/index.cjs\\n  var require_banner = __commonJS({\\n    \\\"shims/banner/index.cjs\\\"() {\\n      init_dist();\\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\\n      globalThis.global = globalThis.global || o;\\n      globalThis.process = globalThis.process || import_process.default;\\n    }\\n  });\\n  require_banner();\\n})();\\n/*! Bundled license information:\\n\\nieee754/index.js:\\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\\n\\nbuffer/index.js:\\n  (*!\\n   * The buffer module from node.js, for the browser.\\n   *\\n   * @author   Feross Aboukhadijeh <https://feross.org>\\n   * @license  MIT\\n   *)\\n*/\\n\\nimport {\\n  require_react_dom\\n} from \\\"./chunk-ODZQOPX5.js\\\";\\nimport {\\n  require_react\\n} from \\\"./chunk-DMLNAHRU.js\\\";\\nimport {\\n  __toESM,\\n  require_dist\\n} from \\\"./chunk-4KAQPM64.js\\\";\\n\\n// node_modules/react-router-dom/dist/index.js\\nvar import_dist3 = __toESM(require_dist());\\nvar React2 = __toESM(require_react());\\nvar ReactDOM = __toESM(require_react_dom());\\n\\n// node_modules/react-router/dist/index.js\\nvar import_dist2 = __toESM(require_dist());\\nvar React = __toESM(require_react());\\n\\n// node_modules/@remix-run/router/dist/router.js\\nvar import_dist = __toESM(require_dist());\\nfunction _extends() {\\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n    return target;\\n  };\\n  return _extends.apply(this, arguments);\\n}\\nvar Action;\\n(function(Action2) {\\n  Action2[\\\"Pop\\\"] = \\\"POP\\\";\\n  Action2[\\\"Push\\\"] = \\\"PUSH\\\";\\n  Action2[\\\"Replace\\\"] = \\\"REPLACE\\\";\\n})(Action || (Action = {}));\\nvar PopStateEventType = \\\"popstate\\\";\\nfunction createMemoryHistory(options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n  let {\\n    initialEntries = [\\\"/\\\"],\\n    initialIndex,\\n    v5Compat = false\\n  } = options;\\n  let entries;\\n  entries = initialEntries.map((entry, index2) => createMemoryLocation(entry, typeof entry === \\\"string\\\" ? null : entry.state, index2 === 0 ? \\\"default\\\" : void 0));\\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\\n  let action = Action.Pop;\\n  let listener = null;\\n  function clampIndex(n) {\\n    return Math.min(Math.max(n, 0), entries.length - 1);\\n  }\\n  function getCurrentLocation() {\\n    return entries[index];\\n  }\\n  function createMemoryLocation(to, state, key) {\\n    if (state === void 0) {\\n      state = null;\\n    }\\n    let location = createLocation(entries ? getCurrentLocation().pathname : \\\"/\\\", to, state, key);\\n    warning(location.pathname.charAt(0) === \\\"/\\\", \\\"relative pathnames are not supported in memory history: \\\" + JSON.stringify(to));\\n    return location;\\n  }\\n  function createHref(to) {\\n    return typeof to === \\\"string\\\" ? to : createPath(to);\\n  }\\n  let history = {\\n    get index() {\\n      return index;\\n    },\\n    get action() {\\n      return action;\\n    },\\n    get location() {\\n      return getCurrentLocation();\\n    },\\n    createHref,\\n    createURL(to) {\\n      return new URL(createHref(to), \\\"http://localhost\\\");\\n    },\\n    encodeLocation(to) {\\n      let path = typeof to === \\\"string\\\" ? parsePath(to) : to;\\n      return {\\n        pathname: path.pathname || \\\"\\\",\\n        search: path.search || \\\"\\\",\\n        hash: path.hash || \\\"\\\"\\n      };\\n    },\\n    push(to, state) {\\n      action = Action.Push;\\n      let nextLocation = createMemoryLocation(to, state);\\n      index += 1;\\n      entries.splice(index, entries.length, nextLocation);\\n      if (v5Compat && listener) {\\n        listener({\\n          action,\\n          location: nextLocation,\\n          delta: 1\\n        });\\n      }\\n    },\\n    replace(to, state) {\\n      action = Action.Replace;\\n      let nextLocation = createMemoryLocation(to, state);\\n      entries[index] = nextLocation;\\n      if (v5Compat && listener) {\\n        listener({\\n          action,\\n          location: nextLocation,\\n          delta: 0\\n        });\\n      }\\n    },\\n    go(delta) {\\n      action = Action.Pop;\\n      let nextIndex = clampIndex(index + delta);\\n      let nextLocation = entries[nextIndex];\\n      index = nextIndex;\\n      if (listener) {\\n        listener({\\n          action,\\n          location: nextLocation,\\n          delta\\n        });\\n      }\\n    },\\n    listen(fn) {\\n      listener = fn;\\n      return () => {\\n        listener = null;\\n      };\\n    }\\n  };\\n  return history;\\n}\\nfunction createBrowserHistory(options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n  function createBrowserLocation(window2, globalHistory) {\\n    let {\\n      pathname,\\n      search,\\n      hash\\n    } = window2.location;\\n    return createLocation(\\n      \\\"\\\",\\n      {\\n        pathname,\\n        search,\\n        hash\\n      },\\n      // state defaults to `null` because `window.history.state` does\\n      globalHistory.state && globalHistory.state.usr || null,\\n      globalHistory.state && globalHistory.state.key || \\\"default\\\"\\n    );\\n  }\\n  function createBrowserHref(window2, to) {\\n    return typeof to === \\\"string\\\" ? to : createPath(to);\\n  }\\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\\n}\\nfunction createHashHistory(options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n  function createHashLocation(window2, globalHistory) {\\n    let {\\n      pathname = \\\"/\\\",\\n      search = \\\"\\\",\\n      hash = \\\"\\\"\\n    } = parsePath(window2.location.hash.substr(1));\\n    if (!pathname.startsWith(\\\"/\\\") && !pathname.startsWith(\\\".\\\")) {\\n      pathname = \\\"/\\\" + pathname;\\n    }\\n    return createLocation(\\n      \\\"\\\",\\n      {\\n        pathname,\\n        search,\\n        hash\\n      },\\n      // state defaults to `null` because `window.history.state` does\\n      globalHistory.state && globalHistory.state.usr || null,\\n      globalHistory.state && globalHistory.state.key || \\\"default\\\"\\n    );\\n  }\\n  function createHashHref(window2, to) {\\n    let base = window2.document.querySelector(\\\"base\\\");\\n    let href = \\\"\\\";\\n    if (base && base.getAttribute(\\\"href\\\")) {\\n      let url = window2.location.href;\\n      let hashIndex = url.indexOf(\\\"#\\\");\\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\\n    }\\n    return href + \\\"#\\\" + (typeof to === \\\"string\\\" ? to : createPath(to));\\n  }\\n  function validateHashLocation(location, to) {\\n    warning(location.pathname.charAt(0) === \\\"/\\\", \\\"relative pathnames are not supported in hash history.push(\\\" + JSON.stringify(to) + \\\")\\\");\\n  }\\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\\n}\\nfunction invariant(value, message) {\\n  if (value === false || value === null || typeof value === \\\"undefined\\\") {\\n    throw new Error(message);\\n  }\\n}\\nfunction warning(cond, message) {\\n  if (!cond) {\\n    if (typeof console !== \\\"undefined\\\")\\n      console.warn(message);\\n    try {\\n      throw new Error(message);\\n    } catch (e) {\\n    }\\n  }\\n}\\nfunction createKey() {\\n  return Math.random().toString(36).substr(2, 8);\\n}\\nfunction getHistoryState(location, index) {\\n  return {\\n    usr: location.state,\\n    key: location.key,\\n    idx: index\\n  };\\n}\\nfunction createLocation(current, to, state, key) {\\n  if (state === void 0) {\\n    state = null;\\n  }\\n  let location = _extends({\\n    pathname: typeof current === \\\"string\\\" ? current : current.pathname,\\n    search: \\\"\\\",\\n    hash: \\\"\\\"\\n  }, typeof to === \\\"string\\\" ? parsePath(to) : to, {\\n    state,\\n    // TODO: This could be cleaned up.  push/replace should probably just take\\n    // full Locations now and avoid the need to run through this flow at all\\n    // But that's a pretty big refactor to the current test suite so going to\\n    // keep as is for the time being and just let any incoming keys take precedence\\n    key: to && to.key || key || createKey()\\n  });\\n  return location;\\n}\\nfunction createPath(_ref) {\\n  let {\\n    pathname = \\\"/\\\",\\n    search = \\\"\\\",\\n    hash = \\\"\\\"\\n  } = _ref;\\n  if (search && search !== \\\"?\\\")\\n    pathname += search.charAt(0) === \\\"?\\\" ? search : \\\"?\\\" + search;\\n  if (hash && hash !== \\\"#\\\")\\n    pathname += hash.charAt(0) === \\\"#\\\" ? hash : \\\"#\\\" + hash;\\n  return pathname;\\n}\\nfunction parsePath(path) {\\n  let parsedPath = {};\\n  if (path) {\\n    let hashIndex = path.indexOf(\\\"#\\\");\\n    if (hashIndex >= 0) {\\n      parsedPath.hash = path.substr(hashIndex);\\n      path = path.substr(0, hashIndex);\\n    }\\n    let searchIndex = path.indexOf(\\\"?\\\");\\n    if (searchIndex >= 0) {\\n      parsedPath.search = path.substr(searchIndex);\\n      path = path.substr(0, searchIndex);\\n    }\\n    if (path) {\\n      parsedPath.pathname = path;\\n    }\\n  }\\n  return parsedPath;\\n}\\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n  let {\\n    window: window2 = document.defaultView,\\n    v5Compat = false\\n  } = options;\\n  let globalHistory = window2.history;\\n  let action = Action.Pop;\\n  let listener = null;\\n  let index = getIndex();\\n  if (index == null) {\\n    index = 0;\\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\\n      idx: index\\n    }), \\\"\\\");\\n  }\\n  function getIndex() {\\n    let state = globalHistory.state || {\\n      idx: null\\n    };\\n    return state.idx;\\n  }\\n  function handlePop() {\\n    action = Action.Pop;\\n    let nextIndex = getIndex();\\n    let delta = nextIndex == null ? null : nextIndex - index;\\n    index = nextIndex;\\n    if (listener) {\\n      listener({\\n        action,\\n        location: history.location,\\n        delta\\n      });\\n    }\\n  }\\n  function push(to, state) {\\n    action = Action.Push;\\n    let location = createLocation(history.location, to, state);\\n    if (validateLocation)\\n      validateLocation(location, to);\\n    index = getIndex() + 1;\\n    let historyState = getHistoryState(location, index);\\n    let url = history.createHref(location);\\n    try {\\n      globalHistory.pushState(historyState, \\\"\\\", url);\\n    } catch (error) {\\n      if (error instanceof DOMException && error.name === \\\"DataCloneError\\\") {\\n        throw error;\\n      }\\n      window2.location.assign(url);\\n    }\\n    if (v5Compat && listener) {\\n      listener({\\n        action,\\n        location: history.location,\\n        delta: 1\\n      });\\n    }\\n  }\\n  function replace(to, state) {\\n    action = Action.Replace;\\n    let location = createLocation(history.location, to, state);\\n    if (validateLocation)\\n      validateLocation(location, to);\\n    index = getIndex();\\n    let historyState = getHistoryState(location, index);\\n    let url = history.createHref(location);\\n    globalHistory.replaceState(historyState, \\\"\\\", url);\\n    if (v5Compat && listener) {\\n      listener({\\n        action,\\n        location: history.location,\\n        delta: 0\\n      });\\n    }\\n  }\\n  function createURL(to) {\\n    let base = window2.location.origin !== \\\"null\\\" ? window2.location.origin : window2.location.href;\\n    let href = typeof to === \\\"string\\\" ? to : createPath(to);\\n    invariant(base, \\\"No window.location.(origin|href) available to create URL for href: \\\" + href);\\n    return new URL(href, base);\\n  }\\n  let history = {\\n    get action() {\\n      return action;\\n    },\\n    get location() {\\n      return getLocation(window2, globalHistory);\\n    },\\n    listen(fn) {\\n      if (listener) {\\n        throw new Error(\\\"A history only accepts one active listener\\\");\\n      }\\n      window2.addEventListener(PopStateEventType, handlePop);\\n      listener = fn;\\n      return () => {\\n        window2.removeEventListener(PopStateEventType, handlePop);\\n        listener = null;\\n      };\\n    },\\n    createHref(to) {\\n      return createHref(window2, to);\\n    },\\n    createURL,\\n    encodeLocation(to) {\\n      let url = createURL(to);\\n      return {\\n        pathname: url.pathname,\\n        search: url.search,\\n        hash: url.hash\\n      };\\n    },\\n    push,\\n    replace,\\n    go(n) {\\n      return globalHistory.go(n);\\n    }\\n  };\\n  return history;\\n}\\nvar ResultType;\\n(function(ResultType2) {\\n  ResultType2[\\\"data\\\"] = \\\"data\\\";\\n  ResultType2[\\\"deferred\\\"] = \\\"deferred\\\";\\n  ResultType2[\\\"redirect\\\"] = \\\"redirect\\\";\\n  ResultType2[\\\"error\\\"] = \\\"error\\\";\\n})(ResultType || (ResultType = {}));\\nvar immutableRouteKeys = /* @__PURE__ */ new Set([\\\"lazy\\\", \\\"caseSensitive\\\", \\\"path\\\", \\\"id\\\", \\\"index\\\", \\\"children\\\"]);\\nfunction isIndexRoute(route) {\\n  return route.index === true;\\n}\\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {\\n  if (parentPath === void 0) {\\n    parentPath = [];\\n  }\\n  if (manifest === void 0) {\\n    manifest = {};\\n  }\\n  return routes.map((route, index) => {\\n    let treePath = [...parentPath, index];\\n    let id = typeof route.id === \\\"string\\\" ? route.id : treePath.join(\\\"-\\\");\\n    invariant(route.index !== true || !route.children, \\\"Cannot specify children on an index route\\\");\\n    invariant(!manifest[id], 'Found a route id collision on id \\\"' + id + `\\\".  Route id's must be globally unique within Data Router usages`);\\n    if (isIndexRoute(route)) {\\n      let indexRoute = _extends({}, route, mapRouteProperties2(route), {\\n        id\\n      });\\n      manifest[id] = indexRoute;\\n      return indexRoute;\\n    } else {\\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties2(route), {\\n        id,\\n        children: void 0\\n      });\\n      manifest[id] = pathOrLayoutRoute;\\n      if (route.children) {\\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\\n      }\\n      return pathOrLayoutRoute;\\n    }\\n  });\\n}\\nfunction matchRoutes(routes, locationArg, basename) {\\n  if (basename === void 0) {\\n    basename = \\\"/\\\";\\n  }\\n  let location = typeof locationArg === \\\"string\\\" ? parsePath(locationArg) : locationArg;\\n  let pathname = stripBasename(location.pathname || \\\"/\\\", basename);\\n  if (pathname == null) {\\n    return null;\\n  }\\n  let branches = flattenRoutes(routes);\\n  rankRouteBranches(branches);\\n  let matches = null;\\n  for (let i = 0; matches == null && i < branches.length; ++i) {\\n    matches = matchRouteBranch(\\n      branches[i],\\n      // Incoming pathnames are generally encoded from either window.location\\n      // or from router.navigate, but we want to match against the unencoded\\n      // paths in the route definitions.  Memory router locations won't be\\n      // encoded here but there also shouldn't be anything to decode so this\\n      // should be a safe operation.  This avoids needing matchRoutes to be\\n      // history-aware.\\n      safelyDecodeURI(pathname)\\n    );\\n  }\\n  return matches;\\n}\\nfunction convertRouteMatchToUiMatch(match, loaderData) {\\n  let {\\n    route,\\n    pathname,\\n    params\\n  } = match;\\n  return {\\n    id: route.id,\\n    pathname,\\n    params,\\n    data: loaderData[route.id],\\n    handle: route.handle\\n  };\\n}\\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\\n  if (branches === void 0) {\\n    branches = [];\\n  }\\n  if (parentsMeta === void 0) {\\n    parentsMeta = [];\\n  }\\n  if (parentPath === void 0) {\\n    parentPath = \\\"\\\";\\n  }\\n  let flattenRoute = (route, index, relativePath) => {\\n    let meta = {\\n      relativePath: relativePath === void 0 ? route.path || \\\"\\\" : relativePath,\\n      caseSensitive: route.caseSensitive === true,\\n      childrenIndex: index,\\n      route\\n    };\\n    if (meta.relativePath.startsWith(\\\"/\\\")) {\\n      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \\\"' + meta.relativePath + '\\\" nested under path ' + ('\\\"' + parentPath + '\\\" is not valid. An absolute child route path ') + \\\"must start with the combined path of all its parent routes.\\\");\\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\\n    }\\n    let path = joinPaths([parentPath, meta.relativePath]);\\n    let routesMeta = parentsMeta.concat(meta);\\n    if (route.children && route.children.length > 0) {\\n      invariant(\\n        // Our types know better, but runtime JS may not!\\n        // @ts-expect-error\\n        route.index !== true,\\n        \\\"Index routes must not have child routes. Please remove \\\" + ('all child routes from route path \\\"' + path + '\\\".')\\n      );\\n      flattenRoutes(route.children, branches, routesMeta, path);\\n    }\\n    if (route.path == null && !route.index) {\\n      return;\\n    }\\n    branches.push({\\n      path,\\n      score: computeScore(path, route.index),\\n      routesMeta\\n    });\\n  };\\n  routes.forEach((route, index) => {\\n    var _route$path;\\n    if (route.path === \\\"\\\" || !((_route$path = route.path) != null && _route$path.includes(\\\"?\\\"))) {\\n      flattenRoute(route, index);\\n    } else {\\n      for (let exploded of explodeOptionalSegments(route.path)) {\\n        flattenRoute(route, index, exploded);\\n      }\\n    }\\n  });\\n  return branches;\\n}\\nfunction explodeOptionalSegments(path) {\\n  let segments = path.split(\\\"/\\\");\\n  if (segments.length === 0)\\n    return [];\\n  let [first, ...rest] = segments;\\n  let isOptional = first.endsWith(\\\"?\\\");\\n  let required = first.replace(/\\\\?$/, \\\"\\\");\\n  if (rest.length === 0) {\\n    return isOptional ? [required, \\\"\\\"] : [required];\\n  }\\n  let restExploded = explodeOptionalSegments(rest.join(\\\"/\\\"));\\n  let result = [];\\n  result.push(...restExploded.map((subpath) => subpath === \\\"\\\" ? required : [required, subpath].join(\\\"/\\\")));\\n  if (isOptional) {\\n    result.push(...restExploded);\\n  }\\n  return result.map((exploded) => path.startsWith(\\\"/\\\") && exploded === \\\"\\\" ? \\\"/\\\" : exploded);\\n}\\nfunction rankRouteBranches(branches) {\\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));\\n}\\nvar paramRe = /^:\\\\w+$/;\\nvar dynamicSegmentValue = 3;\\nvar indexRouteValue = 2;\\nvar emptySegmentValue = 1;\\nvar staticSegmentValue = 10;\\nvar splatPenalty = -2;\\nvar isSplat = (s) => s === \\\"*\\\";\\nfunction computeScore(path, index) {\\n  let segments = path.split(\\\"/\\\");\\n  let initialScore = segments.length;\\n  if (segments.some(isSplat)) {\\n    initialScore += splatPenalty;\\n  }\\n  if (index) {\\n    initialScore += indexRouteValue;\\n  }\\n  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \\\"\\\" ? emptySegmentValue : staticSegmentValue), initialScore);\\n}\\nfunction compareIndexes(a, b) {\\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\\n  return siblings ? (\\n    // If two routes are siblings, we should try to match the earlier sibling\\n    // first. This allows people to have fine-grained control over the matching\\n    // behavior by simply putting routes with identical paths in the order they\\n    // want them tried.\\n    a[a.length - 1] - b[b.length - 1]\\n  ) : (\\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\\n    // so they sort equally.\\n    0\\n  );\\n}\\nfunction matchRouteBranch(branch, pathname) {\\n  let {\\n    routesMeta\\n  } = branch;\\n  let matchedParams = {};\\n  let matchedPathname = \\\"/\\\";\\n  let matches = [];\\n  for (let i = 0; i < routesMeta.length; ++i) {\\n    let meta = routesMeta[i];\\n    let end = i === routesMeta.length - 1;\\n    let remainingPathname = matchedPathname === \\\"/\\\" ? pathname : pathname.slice(matchedPathname.length) || \\\"/\\\";\\n    let match = matchPath({\\n      path: meta.relativePath,\\n      caseSensitive: meta.caseSensitive,\\n      end\\n    }, remainingPathname);\\n    if (!match)\\n      return null;\\n    Object.assign(matchedParams, match.params);\\n    let route = meta.route;\\n    matches.push({\\n      // TODO: Can this as be avoided?\\n      params: matchedParams,\\n      pathname: joinPaths([matchedPathname, match.pathname]),\\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\\n      route\\n    });\\n    if (match.pathnameBase !== \\\"/\\\") {\\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\\n    }\\n  }\\n  return matches;\\n}\\nfunction generatePath(originalPath, params) {\\n  if (params === void 0) {\\n    params = {};\\n  }\\n  let path = originalPath;\\n  if (path.endsWith(\\\"*\\\") && path !== \\\"*\\\" && !path.endsWith(\\\"/*\\\")) {\\n    warning(false, 'Route path \\\"' + path + '\\\" will be treated as if it were ' + ('\\\"' + path.replace(/\\\\*$/, \\\"/*\\\") + '\\\" because the `*` character must ') + \\\"always follow a `/` in the pattern. To get rid of this warning, \\\" + ('please change the route path to \\\"' + path.replace(/\\\\*$/, \\\"/*\\\") + '\\\".'));\\n    path = path.replace(/\\\\*$/, \\\"/*\\\");\\n  }\\n  const prefix = path.startsWith(\\\"/\\\") ? \\\"/\\\" : \\\"\\\";\\n  const stringify = (p) => p == null ? \\\"\\\" : typeof p === \\\"string\\\" ? p : String(p);\\n  const segments = path.split(/\\\\/+/).map((segment, index, array) => {\\n    const isLastSegment = index === array.length - 1;\\n    if (isLastSegment && segment === \\\"*\\\") {\\n      const star = \\\"*\\\";\\n      return stringify(params[star]);\\n    }\\n    const keyMatch = segment.match(/^:(\\\\w+)(\\\\??)$/);\\n    if (keyMatch) {\\n      const [, key, optional] = keyMatch;\\n      let param = params[key];\\n      invariant(optional === \\\"?\\\" || param != null, 'Missing \\\":' + key + '\\\" param');\\n      return stringify(param);\\n    }\\n    return segment.replace(/\\\\?$/g, \\\"\\\");\\n  }).filter((segment) => !!segment);\\n  return prefix + segments.join(\\\"/\\\");\\n}\\nfunction matchPath(pattern, pathname) {\\n  if (typeof pattern === \\\"string\\\") {\\n    pattern = {\\n      path: pattern,\\n      caseSensitive: false,\\n      end: true\\n    };\\n  }\\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\\n  let match = pathname.match(matcher);\\n  if (!match)\\n    return null;\\n  let matchedPathname = match[0];\\n  let pathnameBase = matchedPathname.replace(/(.)\\\\/+$/, \\\"$1\\\");\\n  let captureGroups = match.slice(1);\\n  let params = compiledParams.reduce((memo, _ref, index) => {\\n    let {\\n      paramName,\\n      isOptional\\n    } = _ref;\\n    if (paramName === \\\"*\\\") {\\n      let splatValue = captureGroups[index] || \\\"\\\";\\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\\\/+$/, \\\"$1\\\");\\n    }\\n    const value = captureGroups[index];\\n    if (isOptional && !value) {\\n      memo[paramName] = void 0;\\n    } else {\\n      memo[paramName] = safelyDecodeURIComponent(value || \\\"\\\", paramName);\\n    }\\n    return memo;\\n  }, {});\\n  return {\\n    params,\\n    pathname: matchedPathname,\\n    pathnameBase,\\n    pattern\\n  };\\n}\\nfunction compilePath(path, caseSensitive, end) {\\n  if (caseSensitive === void 0) {\\n    caseSensitive = false;\\n  }\\n  if (end === void 0) {\\n    end = true;\\n  }\\n  warning(path === \\\"*\\\" || !path.endsWith(\\\"*\\\") || path.endsWith(\\\"/*\\\"), 'Route path \\\"' + path + '\\\" will be treated as if it were ' + ('\\\"' + path.replace(/\\\\*$/, \\\"/*\\\") + '\\\" because the `*` character must ') + \\\"always follow a `/` in the pattern. To get rid of this warning, \\\" + ('please change the route path to \\\"' + path.replace(/\\\\*$/, \\\"/*\\\") + '\\\".'));\\n  let params = [];\\n  let regexpSource = \\\"^\\\" + path.replace(/\\\\/*\\\\*?$/, \\\"\\\").replace(/^\\\\/*/, \\\"/\\\").replace(/[\\\\\\\\.*+^${}|()[\\\\]]/g, \\\"\\\\\\\\$&\\\").replace(/\\\\/:(\\\\w+)(\\\\?)?/g, (_, paramName, isOptional) => {\\n    params.push({\\n      paramName,\\n      isOptional: isOptional != null\\n    });\\n    return isOptional ? \\\"/?([^\\\\\\\\/]+)?\\\" : \\\"/([^\\\\\\\\/]+)\\\";\\n  });\\n  if (path.endsWith(\\\"*\\\")) {\\n    params.push({\\n      paramName: \\\"*\\\"\\n    });\\n    regexpSource += path === \\\"*\\\" || path === \\\"/*\\\" ? \\\"(.*)$\\\" : \\\"(?:\\\\\\\\/(.+)|\\\\\\\\/*)$\\\";\\n  } else if (end) {\\n    regexpSource += \\\"\\\\\\\\/*$\\\";\\n  } else if (path !== \\\"\\\" && path !== \\\"/\\\") {\\n    regexpSource += \\\"(?:(?=\\\\\\\\/|$))\\\";\\n  } else\\n    ;\\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \\\"i\\\");\\n  return [matcher, params];\\n}\\nfunction safelyDecodeURI(value) {\\n  try {\\n    return decodeURI(value);\\n  } catch (error) {\\n    warning(false, 'The URL path \\\"' + value + '\\\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + (\\\"encoding (\\\" + error + \\\").\\\"));\\n    return value;\\n  }\\n}\\nfunction safelyDecodeURIComponent(value, paramName) {\\n  try {\\n    return decodeURIComponent(value);\\n  } catch (error) {\\n    warning(false, 'The value for the URL param \\\"' + paramName + '\\\" will not be decoded because' + (' the string \\\"' + value + '\\\" is a malformed URL segment. This is probably') + (\\\" due to a bad percent encoding (\\\" + error + \\\").\\\"));\\n    return value;\\n  }\\n}\\nfunction stripBasename(pathname, basename) {\\n  if (basename === \\\"/\\\")\\n    return pathname;\\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\\n    return null;\\n  }\\n  let startIndex = basename.endsWith(\\\"/\\\") ? basename.length - 1 : basename.length;\\n  let nextChar = pathname.charAt(startIndex);\\n  if (nextChar && nextChar !== \\\"/\\\") {\\n    return null;\\n  }\\n  return pathname.slice(startIndex) || \\\"/\\\";\\n}\\nfunction resolvePath(to, fromPathname) {\\n  if (fromPathname === void 0) {\\n    fromPathname = \\\"/\\\";\\n  }\\n  let {\\n    pathname: toPathname,\\n    search = \\\"\\\",\\n    hash = \\\"\\\"\\n  } = typeof to === \\\"string\\\" ? parsePath(to) : to;\\n  let pathname = toPathname ? toPathname.startsWith(\\\"/\\\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\\n  return {\\n    pathname,\\n    search: normalizeSearch(search),\\n    hash: normalizeHash(hash)\\n  };\\n}\\nfunction resolvePathname(relativePath, fromPathname) {\\n  let segments = fromPathname.replace(/\\\\/+$/, \\\"\\\").split(\\\"/\\\");\\n  let relativeSegments = relativePath.split(\\\"/\\\");\\n  relativeSegments.forEach((segment) => {\\n    if (segment === \\\"..\\\") {\\n      if (segments.length > 1)\\n        segments.pop();\\n    } else if (segment !== \\\".\\\") {\\n      segments.push(segment);\\n    }\\n  });\\n  return segments.length > 1 ? segments.join(\\\"/\\\") : \\\"/\\\";\\n}\\nfunction getInvalidPathError(char, field, dest, path) {\\n  return \\\"Cannot include a '\\\" + char + \\\"' character in a manually specified \\\" + (\\\"`to.\\\" + field + \\\"` field [\\\" + JSON.stringify(path) + \\\"].  Please separate it out to the \\\") + (\\\"`to.\\\" + dest + \\\"` field. Alternatively you may provide the full path as \\\") + 'a string in <Link to=\\\"...\\\"> and the router will parse it for you.';\\n}\\nfunction getPathContributingMatches(matches) {\\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\\n}\\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\\n  let pathMatches = getPathContributingMatches(matches);\\n  if (v7_relativeSplatPath) {\\n    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\\n  }\\n  return pathMatches.map((match) => match.pathnameBase);\\n}\\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\\n  if (isPathRelative === void 0) {\\n    isPathRelative = false;\\n  }\\n  let to;\\n  if (typeof toArg === \\\"string\\\") {\\n    to = parsePath(toArg);\\n  } else {\\n    to = _extends({}, toArg);\\n    invariant(!to.pathname || !to.pathname.includes(\\\"?\\\"), getInvalidPathError(\\\"?\\\", \\\"pathname\\\", \\\"search\\\", to));\\n    invariant(!to.pathname || !to.pathname.includes(\\\"#\\\"), getInvalidPathError(\\\"#\\\", \\\"pathname\\\", \\\"hash\\\", to));\\n    invariant(!to.search || !to.search.includes(\\\"#\\\"), getInvalidPathError(\\\"#\\\", \\\"search\\\", \\\"hash\\\", to));\\n  }\\n  let isEmptyPath = toArg === \\\"\\\" || to.pathname === \\\"\\\";\\n  let toPathname = isEmptyPath ? \\\"/\\\" : to.pathname;\\n  let from;\\n  if (toPathname == null) {\\n    from = locationPathname;\\n  } else if (isPathRelative) {\\n    let fromSegments = routePathnames.length === 0 ? [] : routePathnames[routePathnames.length - 1].replace(/^\\\\//, \\\"\\\").split(\\\"/\\\");\\n    if (toPathname.startsWith(\\\"..\\\")) {\\n      let toSegments = toPathname.split(\\\"/\\\");\\n      while (toSegments[0] === \\\"..\\\") {\\n        toSegments.shift();\\n        fromSegments.pop();\\n      }\\n      to.pathname = toSegments.join(\\\"/\\\");\\n    }\\n    from = \\\"/\\\" + fromSegments.join(\\\"/\\\");\\n  } else {\\n    let routePathnameIndex = routePathnames.length - 1;\\n    if (toPathname.startsWith(\\\"..\\\")) {\\n      let toSegments = toPathname.split(\\\"/\\\");\\n      while (toSegments[0] === \\\"..\\\") {\\n        toSegments.shift();\\n        routePathnameIndex -= 1;\\n      }\\n      to.pathname = toSegments.join(\\\"/\\\");\\n    }\\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \\\"/\\\";\\n  }\\n  let path = resolvePath(to, from);\\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \\\"/\\\" && toPathname.endsWith(\\\"/\\\");\\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \\\".\\\") && locationPathname.endsWith(\\\"/\\\");\\n  if (!path.pathname.endsWith(\\\"/\\\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\\n    path.pathname += \\\"/\\\";\\n  }\\n  return path;\\n}\\nvar joinPaths = (paths) => paths.join(\\\"/\\\").replace(/\\\\/\\\\/+/g, \\\"/\\\");\\nvar normalizePathname = (pathname) => pathname.replace(/\\\\/+$/, \\\"\\\").replace(/^\\\\/*/, \\\"/\\\");\\nvar normalizeSearch = (search) => !search || search === \\\"?\\\" ? \\\"\\\" : search.startsWith(\\\"?\\\") ? search : \\\"?\\\" + search;\\nvar normalizeHash = (hash) => !hash || hash === \\\"#\\\" ? \\\"\\\" : hash.startsWith(\\\"#\\\") ? hash : \\\"#\\\" + hash;\\nvar json = function json2(data, init) {\\n  if (init === void 0) {\\n    init = {};\\n  }\\n  let responseInit = typeof init === \\\"number\\\" ? {\\n    status: init\\n  } : init;\\n  let headers = new Headers(responseInit.headers);\\n  if (!headers.has(\\\"Content-Type\\\")) {\\n    headers.set(\\\"Content-Type\\\", \\\"application/json; charset=utf-8\\\");\\n  }\\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\\n    headers\\n  }));\\n};\\nvar AbortedDeferredError = class extends Error {\\n};\\nvar DeferredData = class {\\n  constructor(data, responseInit) {\\n    this.pendingKeysSet = /* @__PURE__ */ new Set();\\n    this.subscribers = /* @__PURE__ */ new Set();\\n    this.deferredKeys = [];\\n    invariant(data && typeof data === \\\"object\\\" && !Array.isArray(data), \\\"defer() only accepts plain objects\\\");\\n    let reject;\\n    this.abortPromise = new Promise((_, r) => reject = r);\\n    this.controller = new AbortController();\\n    let onAbort = () => reject(new AbortedDeferredError(\\\"Deferred data aborted\\\"));\\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\\\"abort\\\", onAbort);\\n    this.controller.signal.addEventListener(\\\"abort\\\", onAbort);\\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\\n      let [key, value] = _ref2;\\n      return Object.assign(acc, {\\n        [key]: this.trackPromise(key, value)\\n      });\\n    }, {});\\n    if (this.done) {\\n      this.unlistenAbortSignal();\\n    }\\n    this.init = responseInit;\\n  }\\n  trackPromise(key, value) {\\n    if (!(value instanceof Promise)) {\\n      return value;\\n    }\\n    this.deferredKeys.push(key);\\n    this.pendingKeysSet.add(key);\\n    let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, void 0, data), (error) => this.onSettle(promise, key, error));\\n    promise.catch(() => {\\n    });\\n    Object.defineProperty(promise, \\\"_tracked\\\", {\\n      get: () => true\\n    });\\n    return promise;\\n  }\\n  onSettle(promise, key, error, data) {\\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\\n      this.unlistenAbortSignal();\\n      Object.defineProperty(promise, \\\"_error\\\", {\\n        get: () => error\\n      });\\n      return Promise.reject(error);\\n    }\\n    this.pendingKeysSet.delete(key);\\n    if (this.done) {\\n      this.unlistenAbortSignal();\\n    }\\n    if (error === void 0 && data === void 0) {\\n      let undefinedError = new Error('Deferred data for key \\\"' + key + '\\\" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');\\n      Object.defineProperty(promise, \\\"_error\\\", {\\n        get: () => undefinedError\\n      });\\n      this.emit(false, key);\\n      return Promise.reject(undefinedError);\\n    }\\n    if (data === void 0) {\\n      Object.defineProperty(promise, \\\"_error\\\", {\\n        get: () => error\\n      });\\n      this.emit(false, key);\\n      return Promise.reject(error);\\n    }\\n    Object.defineProperty(promise, \\\"_data\\\", {\\n      get: () => data\\n    });\\n    this.emit(false, key);\\n    return data;\\n  }\\n  emit(aborted, settledKey) {\\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\\n  }\\n  subscribe(fn) {\\n    this.subscribers.add(fn);\\n    return () => this.subscribers.delete(fn);\\n  }\\n  cancel() {\\n    this.controller.abort();\\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\\n    this.emit(true);\\n  }\\n  async resolveData(signal) {\\n    let aborted = false;\\n    if (!this.done) {\\n      let onAbort = () => this.cancel();\\n      signal.addEventListener(\\\"abort\\\", onAbort);\\n      aborted = await new Promise((resolve) => {\\n        this.subscribe((aborted2) => {\\n          signal.removeEventListener(\\\"abort\\\", onAbort);\\n          if (aborted2 || this.done) {\\n            resolve(aborted2);\\n          }\\n        });\\n      });\\n    }\\n    return aborted;\\n  }\\n  get done() {\\n    return this.pendingKeysSet.size === 0;\\n  }\\n  get unwrappedData() {\\n    invariant(this.data !== null && this.done, \\\"Can only unwrap data on initialized and settled deferreds\\\");\\n    return Object.entries(this.data).reduce((acc, _ref3) => {\\n      let [key, value] = _ref3;\\n      return Object.assign(acc, {\\n        [key]: unwrapTrackedPromise(value)\\n      });\\n    }, {});\\n  }\\n  get pendingKeys() {\\n    return Array.from(this.pendingKeysSet);\\n  }\\n};\\nfunction isTrackedPromise(value) {\\n  return value instanceof Promise && value._tracked === true;\\n}\\nfunction unwrapTrackedPromise(value) {\\n  if (!isTrackedPromise(value)) {\\n    return value;\\n  }\\n  if (value._error) {\\n    throw value._error;\\n  }\\n  return value._data;\\n}\\nvar defer = function defer2(data, init) {\\n  if (init === void 0) {\\n    init = {};\\n  }\\n  let responseInit = typeof init === \\\"number\\\" ? {\\n    status: init\\n  } : init;\\n  return new DeferredData(data, responseInit);\\n};\\nvar redirect = function redirect2(url, init) {\\n  if (init === void 0) {\\n    init = 302;\\n  }\\n  let responseInit = init;\\n  if (typeof responseInit === \\\"number\\\") {\\n    responseInit = {\\n      status: responseInit\\n    };\\n  } else if (typeof responseInit.status === \\\"undefined\\\") {\\n    responseInit.status = 302;\\n  }\\n  let headers = new Headers(responseInit.headers);\\n  headers.set(\\\"Location\\\", url);\\n  return new Response(null, _extends({}, responseInit, {\\n    headers\\n  }));\\n};\\nvar redirectDocument = (url, init) => {\\n  let response = redirect(url, init);\\n  response.headers.set(\\\"X-Remix-Reload-Document\\\", \\\"true\\\");\\n  return response;\\n};\\nvar ErrorResponseImpl = class {\\n  constructor(status, statusText, data, internal) {\\n    if (internal === void 0) {\\n      internal = false;\\n    }\\n    this.status = status;\\n    this.statusText = statusText || \\\"\\\";\\n    this.internal = internal;\\n    if (data instanceof Error) {\\n      this.data = data.toString();\\n      this.error = data;\\n    } else {\\n      this.data = data;\\n    }\\n  }\\n};\\nfunction isRouteErrorResponse(error) {\\n  return error != null && typeof error.status === \\\"number\\\" && typeof error.statusText === \\\"string\\\" && typeof error.internal === \\\"boolean\\\" && \\\"data\\\" in error;\\n}\\nvar validMutationMethodsArr = [\\\"post\\\", \\\"put\\\", \\\"patch\\\", \\\"delete\\\"];\\nvar validMutationMethods = new Set(validMutationMethodsArr);\\nvar validRequestMethodsArr = [\\\"get\\\", ...validMutationMethodsArr];\\nvar validRequestMethods = new Set(validRequestMethodsArr);\\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\\nvar IDLE_NAVIGATION = {\\n  state: \\\"idle\\\",\\n  location: void 0,\\n  formMethod: void 0,\\n  formAction: void 0,\\n  formEncType: void 0,\\n  formData: void 0,\\n  json: void 0,\\n  text: void 0\\n};\\nvar IDLE_FETCHER = {\\n  state: \\\"idle\\\",\\n  data: void 0,\\n  formMethod: void 0,\\n  formAction: void 0,\\n  formEncType: void 0,\\n  formData: void 0,\\n  json: void 0,\\n  text: void 0\\n};\\nvar IDLE_BLOCKER = {\\n  state: \\\"unblocked\\\",\\n  proceed: void 0,\\n  reset: void 0,\\n  location: void 0\\n};\\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\\\/\\\\/)/i;\\nvar defaultMapRouteProperties = (route) => ({\\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\\n});\\nvar TRANSITIONS_STORAGE_KEY = \\\"remix-router-transitions\\\";\\nfunction createRouter(init) {\\n  const routerWindow = init.window ? init.window : typeof window !== \\\"undefined\\\" ? window : void 0;\\n  const isBrowser2 = typeof routerWindow !== \\\"undefined\\\" && typeof routerWindow.document !== \\\"undefined\\\" && typeof routerWindow.document.createElement !== \\\"undefined\\\";\\n  const isServer = !isBrowser2;\\n  invariant(init.routes.length > 0, \\\"You must provide a non-empty routes array to createRouter\\\");\\n  let mapRouteProperties2;\\n  if (init.mapRouteProperties) {\\n    mapRouteProperties2 = init.mapRouteProperties;\\n  } else if (init.detectErrorBoundary) {\\n    let detectErrorBoundary = init.detectErrorBoundary;\\n    mapRouteProperties2 = (route) => ({\\n      hasErrorBoundary: detectErrorBoundary(route)\\n    });\\n  } else {\\n    mapRouteProperties2 = defaultMapRouteProperties;\\n  }\\n  let manifest = {};\\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\\n  let inFlightDataRoutes;\\n  let basename = init.basename || \\\"/\\\";\\n  let future = _extends({\\n    v7_fetcherPersist: false,\\n    v7_normalizeFormMethod: false,\\n    v7_partialHydration: false,\\n    v7_prependBasename: false,\\n    v7_relativeSplatPath: false\\n  }, init.future);\\n  let unlistenHistory = null;\\n  let subscribers = /* @__PURE__ */ new Set();\\n  let savedScrollPositions2 = null;\\n  let getScrollRestorationKey = null;\\n  let getScrollPosition = null;\\n  let initialScrollRestored = init.hydrationData != null;\\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\\n  let initialErrors = null;\\n  if (initialMatches == null) {\\n    let error = getInternalRouterError(404, {\\n      pathname: init.history.location.pathname\\n    });\\n    let {\\n      matches,\\n      route\\n    } = getShortCircuitMatches(dataRoutes);\\n    initialMatches = matches;\\n    initialErrors = {\\n      [route.id]: error\\n    };\\n  }\\n  let initialized;\\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\\n  if (hasLazyRoutes) {\\n    initialized = false;\\n  } else if (!hasLoaders) {\\n    initialized = true;\\n  } else if (future.v7_partialHydration) {\\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\\n    initialized = initialMatches.every((m) => m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== void 0 || errors && errors[m.route.id] !== void 0));\\n  } else {\\n    initialized = init.hydrationData != null;\\n  }\\n  let router;\\n  let state = {\\n    historyAction: init.history.action,\\n    location: init.history.location,\\n    matches: initialMatches,\\n    initialized,\\n    navigation: IDLE_NAVIGATION,\\n    // Don't restore on initial updateState() if we were SSR'd\\n    restoreScrollPosition: init.hydrationData != null ? false : null,\\n    preventScrollReset: false,\\n    revalidation: \\\"idle\\\",\\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\\n    fetchers: /* @__PURE__ */ new Map(),\\n    blockers: /* @__PURE__ */ new Map()\\n  };\\n  let pendingAction = Action.Pop;\\n  let pendingPreventScrollReset = false;\\n  let pendingNavigationController;\\n  let pendingViewTransitionEnabled = false;\\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\\n  let removePageHideEventListener = null;\\n  let isUninterruptedRevalidation = false;\\n  let isRevalidationRequired = false;\\n  let cancelledDeferredRoutes = [];\\n  let cancelledFetcherLoads = [];\\n  let fetchControllers = /* @__PURE__ */ new Map();\\n  let incrementingLoadId = 0;\\n  let pendingNavigationLoadId = -1;\\n  let fetchReloadIds = /* @__PURE__ */ new Map();\\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\\n  let activeFetchers = /* @__PURE__ */ new Map();\\n  let deletedFetchers = /* @__PURE__ */ new Set();\\n  let activeDeferreds = /* @__PURE__ */ new Map();\\n  let blockerFunctions = /* @__PURE__ */ new Map();\\n  let ignoreNextHistoryUpdate = false;\\n  function initialize() {\\n    unlistenHistory = init.history.listen((_ref) => {\\n      let {\\n        action: historyAction,\\n        location,\\n        delta\\n      } = _ref;\\n      if (ignoreNextHistoryUpdate) {\\n        ignoreNextHistoryUpdate = false;\\n        return;\\n      }\\n      warning(blockerFunctions.size === 0 || delta != null, \\\"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\\\");\\n      let blockerKey = shouldBlockNavigation({\\n        currentLocation: state.location,\\n        nextLocation: location,\\n        historyAction\\n      });\\n      if (blockerKey && delta != null) {\\n        ignoreNextHistoryUpdate = true;\\n        init.history.go(delta * -1);\\n        updateBlocker(blockerKey, {\\n          state: \\\"blocked\\\",\\n          location,\\n          proceed() {\\n            updateBlocker(blockerKey, {\\n              state: \\\"proceeding\\\",\\n              proceed: void 0,\\n              reset: void 0,\\n              location\\n            });\\n            init.history.go(delta);\\n          },\\n          reset() {\\n            let blockers = new Map(state.blockers);\\n            blockers.set(blockerKey, IDLE_BLOCKER);\\n            updateState({\\n              blockers\\n            });\\n          }\\n        });\\n        return;\\n      }\\n      return startNavigation(historyAction, location);\\n    });\\n    if (isBrowser2) {\\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\\n      routerWindow.addEventListener(\\\"pagehide\\\", _saveAppliedTransitions);\\n      removePageHideEventListener = () => routerWindow.removeEventListener(\\\"pagehide\\\", _saveAppliedTransitions);\\n    }\\n    if (!state.initialized) {\\n      startNavigation(Action.Pop, state.location, {\\n        initialHydration: true\\n      });\\n    }\\n    return router;\\n  }\\n  function dispose() {\\n    if (unlistenHistory) {\\n      unlistenHistory();\\n    }\\n    if (removePageHideEventListener) {\\n      removePageHideEventListener();\\n    }\\n    subscribers.clear();\\n    pendingNavigationController && pendingNavigationController.abort();\\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\\n    state.blockers.forEach((_, key) => deleteBlocker(key));\\n  }\\n  function subscribe(fn) {\\n    subscribers.add(fn);\\n    return () => subscribers.delete(fn);\\n  }\\n  function updateState(newState, opts) {\\n    if (opts === void 0) {\\n      opts = {};\\n    }\\n    state = _extends({}, state, newState);\\n    let completedFetchers = [];\\n    let deletedFetchersKeys = [];\\n    if (future.v7_fetcherPersist) {\\n      state.fetchers.forEach((fetcher, key) => {\\n        if (fetcher.state === \\\"idle\\\") {\\n          if (deletedFetchers.has(key)) {\\n            deletedFetchersKeys.push(key);\\n          } else {\\n            completedFetchers.push(key);\\n          }\\n        }\\n      });\\n    }\\n    [...subscribers].forEach((subscriber) => subscriber(state, {\\n      deletedFetchers: deletedFetchersKeys,\\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\\n      unstable_flushSync: opts.flushSync === true\\n    }));\\n    if (future.v7_fetcherPersist) {\\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\\n    }\\n  }\\n  function completeNavigation(location, newState, _temp) {\\n    var _location$state, _location$state2;\\n    let {\\n      flushSync\\n    } = _temp === void 0 ? {} : _temp;\\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \\\"loading\\\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\\n    let actionData;\\n    if (newState.actionData) {\\n      if (Object.keys(newState.actionData).length > 0) {\\n        actionData = newState.actionData;\\n      } else {\\n        actionData = null;\\n      }\\n    } else if (isActionReload) {\\n      actionData = state.actionData;\\n    } else {\\n      actionData = null;\\n    }\\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\\n    let blockers = state.blockers;\\n    if (blockers.size > 0) {\\n      blockers = new Map(blockers);\\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\\n    }\\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\\n    if (inFlightDataRoutes) {\\n      dataRoutes = inFlightDataRoutes;\\n      inFlightDataRoutes = void 0;\\n    }\\n    if (isUninterruptedRevalidation)\\n      ;\\n    else if (pendingAction === Action.Pop)\\n      ;\\n    else if (pendingAction === Action.Push) {\\n      init.history.push(location, location.state);\\n    } else if (pendingAction === Action.Replace) {\\n      init.history.replace(location, location.state);\\n    }\\n    let viewTransitionOpts;\\n    if (pendingAction === Action.Pop) {\\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\\n      if (priorPaths && priorPaths.has(location.pathname)) {\\n        viewTransitionOpts = {\\n          currentLocation: state.location,\\n          nextLocation: location\\n        };\\n      } else if (appliedViewTransitions.has(location.pathname)) {\\n        viewTransitionOpts = {\\n          currentLocation: location,\\n          nextLocation: state.location\\n        };\\n      }\\n    } else if (pendingViewTransitionEnabled) {\\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\\n      if (toPaths) {\\n        toPaths.add(location.pathname);\\n      } else {\\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\\n        appliedViewTransitions.set(state.location.pathname, toPaths);\\n      }\\n      viewTransitionOpts = {\\n        currentLocation: state.location,\\n        nextLocation: location\\n      };\\n    }\\n    updateState(_extends({}, newState, {\\n      actionData,\\n      loaderData,\\n      historyAction: pendingAction,\\n      location,\\n      initialized: true,\\n      navigation: IDLE_NAVIGATION,\\n      revalidation: \\\"idle\\\",\\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\\n      preventScrollReset,\\n      blockers\\n    }), {\\n      viewTransitionOpts,\\n      flushSync: flushSync === true\\n    });\\n    pendingAction = Action.Pop;\\n    pendingPreventScrollReset = false;\\n    pendingViewTransitionEnabled = false;\\n    isUninterruptedRevalidation = false;\\n    isRevalidationRequired = false;\\n    cancelledDeferredRoutes = [];\\n    cancelledFetcherLoads = [];\\n  }\\n  async function navigate(to, opts) {\\n    if (typeof to === \\\"number\\\") {\\n      init.history.go(to);\\n      return;\\n    }\\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\\n    let {\\n      path,\\n      submission,\\n      error\\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\\n    let currentLocation = state.location;\\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\\n    let historyAction = Action.Push;\\n    if (userReplace === true) {\\n      historyAction = Action.Replace;\\n    } else if (userReplace === false)\\n      ;\\n    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\\n      historyAction = Action.Replace;\\n    }\\n    let preventScrollReset = opts && \\\"preventScrollReset\\\" in opts ? opts.preventScrollReset === true : void 0;\\n    let flushSync = (opts && opts.unstable_flushSync) === true;\\n    let blockerKey = shouldBlockNavigation({\\n      currentLocation,\\n      nextLocation,\\n      historyAction\\n    });\\n    if (blockerKey) {\\n      updateBlocker(blockerKey, {\\n        state: \\\"blocked\\\",\\n        location: nextLocation,\\n        proceed() {\\n          updateBlocker(blockerKey, {\\n            state: \\\"proceeding\\\",\\n            proceed: void 0,\\n            reset: void 0,\\n            location: nextLocation\\n          });\\n          navigate(to, opts);\\n        },\\n        reset() {\\n          let blockers = new Map(state.blockers);\\n          blockers.set(blockerKey, IDLE_BLOCKER);\\n          updateState({\\n            blockers\\n          });\\n        }\\n      });\\n      return;\\n    }\\n    return await startNavigation(historyAction, nextLocation, {\\n      submission,\\n      // Send through the formData serialization error if we have one so we can\\n      // render at the right error boundary after we match routes\\n      pendingError: error,\\n      preventScrollReset,\\n      replace: opts && opts.replace,\\n      enableViewTransition: opts && opts.unstable_viewTransition,\\n      flushSync\\n    });\\n  }\\n  function revalidate() {\\n    interruptActiveLoads();\\n    updateState({\\n      revalidation: \\\"loading\\\"\\n    });\\n    if (state.navigation.state === \\\"submitting\\\") {\\n      return;\\n    }\\n    if (state.navigation.state === \\\"idle\\\") {\\n      startNavigation(state.historyAction, state.location, {\\n        startUninterruptedRevalidation: true\\n      });\\n      return;\\n    }\\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\\n      overrideNavigation: state.navigation\\n    });\\n  }\\n  async function startNavigation(historyAction, location, opts) {\\n    pendingNavigationController && pendingNavigationController.abort();\\n    pendingNavigationController = null;\\n    pendingAction = historyAction;\\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\\n    saveScrollPosition(state.location, state.matches);\\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\\n    let routesToUse = inFlightDataRoutes || dataRoutes;\\n    let loadingNavigation = opts && opts.overrideNavigation;\\n    let matches = matchRoutes(routesToUse, location, basename);\\n    let flushSync = (opts && opts.flushSync) === true;\\n    if (!matches) {\\n      let error = getInternalRouterError(404, {\\n        pathname: location.pathname\\n      });\\n      let {\\n        matches: notFoundMatches,\\n        route\\n      } = getShortCircuitMatches(routesToUse);\\n      cancelActiveDeferreds();\\n      completeNavigation(location, {\\n        matches: notFoundMatches,\\n        loaderData: {},\\n        errors: {\\n          [route.id]: error\\n        }\\n      }, {\\n        flushSync\\n      });\\n      return;\\n    }\\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\\n      completeNavigation(location, {\\n        matches\\n      }, {\\n        flushSync\\n      });\\n      return;\\n    }\\n    pendingNavigationController = new AbortController();\\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\\n    let pendingActionData;\\n    let pendingError;\\n    if (opts && opts.pendingError) {\\n      pendingError = {\\n        [findNearestBoundary(matches).route.id]: opts.pendingError\\n      };\\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\\n        replace: opts.replace,\\n        flushSync\\n      });\\n      if (actionOutput.shortCircuited) {\\n        return;\\n      }\\n      pendingActionData = actionOutput.pendingActionData;\\n      pendingError = actionOutput.pendingActionError;\\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\\n      flushSync = false;\\n      request = new Request(request.url, {\\n        signal: request.signal\\n      });\\n    }\\n    let {\\n      shortCircuited,\\n      loaderData,\\n      errors\\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\\n    if (shortCircuited) {\\n      return;\\n    }\\n    pendingNavigationController = null;\\n    completeNavigation(location, _extends({\\n      matches\\n    }, pendingActionData ? {\\n      actionData: pendingActionData\\n    } : {}, {\\n      loaderData,\\n      errors\\n    }));\\n  }\\n  async function handleAction(request, location, submission, matches, opts) {\\n    if (opts === void 0) {\\n      opts = {};\\n    }\\n    interruptActiveLoads();\\n    let navigation = getSubmittingNavigation(location, submission);\\n    updateState({\\n      navigation\\n    }, {\\n      flushSync: opts.flushSync === true\\n    });\\n    let result;\\n    let actionMatch = getTargetMatch(matches, location);\\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\\n      result = {\\n        type: ResultType.error,\\n        error: getInternalRouterError(405, {\\n          method: request.method,\\n          pathname: location.pathname,\\n          routeId: actionMatch.route.id\\n        })\\n      };\\n    } else {\\n      result = await callLoaderOrAction(\\\"action\\\", request, actionMatch, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\\n      if (request.signal.aborted) {\\n        return {\\n          shortCircuited: true\\n        };\\n      }\\n    }\\n    if (isRedirectResult(result)) {\\n      let replace;\\n      if (opts && opts.replace != null) {\\n        replace = opts.replace;\\n      } else {\\n        replace = result.location === state.location.pathname + state.location.search;\\n      }\\n      await startRedirectNavigation(state, result, {\\n        submission,\\n        replace\\n      });\\n      return {\\n        shortCircuited: true\\n      };\\n    }\\n    if (isErrorResult(result)) {\\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\\n      if ((opts && opts.replace) !== true) {\\n        pendingAction = Action.Push;\\n      }\\n      return {\\n        // Send back an empty object we can use to clear out any prior actionData\\n        pendingActionData: {},\\n        pendingActionError: {\\n          [boundaryMatch.route.id]: result.error\\n        }\\n      };\\n    }\\n    if (isDeferredResult(result)) {\\n      throw getInternalRouterError(400, {\\n        type: \\\"defer-action\\\"\\n      });\\n    }\\n    return {\\n      pendingActionData: {\\n        [actionMatch.route.id]: result.data\\n      }\\n    };\\n  }\\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\\n    let routesToUse = inFlightDataRoutes || dataRoutes;\\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\\n    cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));\\n    pendingNavigationLoadId = ++incrementingLoadId;\\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\\n      let updatedFetchers2 = markFetchRedirectsDone();\\n      completeNavigation(location, _extends({\\n        matches,\\n        loaderData: {},\\n        // Commit pending error if we're short circuiting\\n        errors: pendingError || null\\n      }, pendingActionData ? {\\n        actionData: pendingActionData\\n      } : {}, updatedFetchers2 ? {\\n        fetchers: new Map(state.fetchers)\\n      } : {}), {\\n        flushSync\\n      });\\n      return {\\n        shortCircuited: true\\n      };\\n    }\\n    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\\n      revalidatingFetchers.forEach((rf) => {\\n        let fetcher = state.fetchers.get(rf.key);\\n        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\\n        state.fetchers.set(rf.key, revalidatingFetcher);\\n      });\\n      let actionData = pendingActionData || state.actionData;\\n      updateState(_extends({\\n        navigation: loadingNavigation\\n      }, actionData ? Object.keys(actionData).length === 0 ? {\\n        actionData: null\\n      } : {\\n        actionData\\n      } : {}, revalidatingFetchers.length > 0 ? {\\n        fetchers: new Map(state.fetchers)\\n      } : {}), {\\n        flushSync\\n      });\\n    }\\n    revalidatingFetchers.forEach((rf) => {\\n      if (fetchControllers.has(rf.key)) {\\n        abortFetcher(rf.key);\\n      }\\n      if (rf.controller) {\\n        fetchControllers.set(rf.key, rf.controller);\\n      }\\n    });\\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\\n    if (pendingNavigationController) {\\n      pendingNavigationController.signal.addEventListener(\\\"abort\\\", abortPendingFetchRevalidations);\\n    }\\n    let {\\n      results,\\n      loaderResults,\\n      fetcherResults\\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\\n    if (request.signal.aborted) {\\n      return {\\n        shortCircuited: true\\n      };\\n    }\\n    if (pendingNavigationController) {\\n      pendingNavigationController.signal.removeEventListener(\\\"abort\\\", abortPendingFetchRevalidations);\\n    }\\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\\n    let redirect3 = findRedirect(results);\\n    if (redirect3) {\\n      if (redirect3.idx >= matchesToLoad.length) {\\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\\n        fetchRedirectIds.add(fetcherKey);\\n      }\\n      await startRedirectNavigation(state, redirect3.result, {\\n        replace\\n      });\\n      return {\\n        shortCircuited: true\\n      };\\n    }\\n    let {\\n      loaderData,\\n      errors\\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\\n    activeDeferreds.forEach((deferredData, routeId) => {\\n      deferredData.subscribe((aborted) => {\\n        if (aborted || deferredData.done) {\\n          activeDeferreds.delete(routeId);\\n        }\\n      });\\n    });\\n    let updatedFetchers = markFetchRedirectsDone();\\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\\n    return _extends({\\n      loaderData,\\n      errors\\n    }, shouldUpdateFetchers ? {\\n      fetchers: new Map(state.fetchers)\\n    } : {});\\n  }\\n  function fetch(key, routeId, href, opts) {\\n    if (isServer) {\\n      throw new Error(\\\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\\\");\\n    }\\n    if (fetchControllers.has(key))\\n      abortFetcher(key);\\n    let flushSync = (opts && opts.unstable_flushSync) === true;\\n    let routesToUse = inFlightDataRoutes || dataRoutes;\\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\\n    if (!matches) {\\n      setFetcherError(key, routeId, getInternalRouterError(404, {\\n        pathname: normalizedPath\\n      }), {\\n        flushSync\\n      });\\n      return;\\n    }\\n    let {\\n      path,\\n      submission,\\n      error\\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\\n    if (error) {\\n      setFetcherError(key, routeId, error, {\\n        flushSync\\n      });\\n      return;\\n    }\\n    let match = getTargetMatch(matches, path);\\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\\n    if (submission && isMutationMethod(submission.formMethod)) {\\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\\n      return;\\n    }\\n    fetchLoadMatches.set(key, {\\n      routeId,\\n      path\\n    });\\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\\n  }\\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\\n    interruptActiveLoads();\\n    fetchLoadMatches.delete(key);\\n    if (!match.route.action && !match.route.lazy) {\\n      let error = getInternalRouterError(405, {\\n        method: submission.formMethod,\\n        pathname: path,\\n        routeId\\n      });\\n      setFetcherError(key, routeId, error, {\\n        flushSync\\n      });\\n      return;\\n    }\\n    let existingFetcher = state.fetchers.get(key);\\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\\n      flushSync\\n    });\\n    let abortController = new AbortController();\\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\\n    fetchControllers.set(key, abortController);\\n    let originatingLoadId = incrementingLoadId;\\n    let actionResult = await callLoaderOrAction(\\\"action\\\", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\\n    if (fetchRequest.signal.aborted) {\\n      if (fetchControllers.get(key) === abortController) {\\n        fetchControllers.delete(key);\\n      }\\n      return;\\n    }\\n    if (deletedFetchers.has(key)) {\\n      updateFetcherState(key, getDoneFetcher(void 0));\\n      return;\\n    }\\n    if (isRedirectResult(actionResult)) {\\n      fetchControllers.delete(key);\\n      if (pendingNavigationLoadId > originatingLoadId) {\\n        updateFetcherState(key, getDoneFetcher(void 0));\\n        return;\\n      } else {\\n        fetchRedirectIds.add(key);\\n        updateFetcherState(key, getLoadingFetcher(submission));\\n        return startRedirectNavigation(state, actionResult, {\\n          fetcherSubmission: submission\\n        });\\n      }\\n    }\\n    if (isErrorResult(actionResult)) {\\n      setFetcherError(key, routeId, actionResult.error);\\n      return;\\n    }\\n    if (isDeferredResult(actionResult)) {\\n      throw getInternalRouterError(400, {\\n        type: \\\"defer-action\\\"\\n      });\\n    }\\n    let nextLocation = state.navigation.location || state.location;\\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\\n    let routesToUse = inFlightDataRoutes || dataRoutes;\\n    let matches = state.navigation.state !== \\\"idle\\\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\\n    invariant(matches, \\\"Didn't find any matches after fetcher action\\\");\\n    let loadId = ++incrementingLoadId;\\n    fetchReloadIds.set(key, loadId);\\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\\n    state.fetchers.set(key, loadFetcher);\\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\\n      init.history,\\n      state,\\n      matches,\\n      submission,\\n      nextLocation,\\n      false,\\n      isRevalidationRequired,\\n      cancelledDeferredRoutes,\\n      cancelledFetcherLoads,\\n      deletedFetchers,\\n      fetchLoadMatches,\\n      fetchRedirectIds,\\n      routesToUse,\\n      basename,\\n      {\\n        [match.route.id]: actionResult.data\\n      },\\n      void 0\\n      // No need to send through errors since we short circuit above\\n    );\\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\\n      let staleKey = rf.key;\\n      let existingFetcher2 = state.fetchers.get(staleKey);\\n      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\\n      state.fetchers.set(staleKey, revalidatingFetcher);\\n      if (fetchControllers.has(staleKey)) {\\n        abortFetcher(staleKey);\\n      }\\n      if (rf.controller) {\\n        fetchControllers.set(staleKey, rf.controller);\\n      }\\n    });\\n    updateState({\\n      fetchers: new Map(state.fetchers)\\n    });\\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\\n    abortController.signal.addEventListener(\\\"abort\\\", abortPendingFetchRevalidations);\\n    let {\\n      results,\\n      loaderResults,\\n      fetcherResults\\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\\n    if (abortController.signal.aborted) {\\n      return;\\n    }\\n    abortController.signal.removeEventListener(\\\"abort\\\", abortPendingFetchRevalidations);\\n    fetchReloadIds.delete(key);\\n    fetchControllers.delete(key);\\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\\n    let redirect3 = findRedirect(results);\\n    if (redirect3) {\\n      if (redirect3.idx >= matchesToLoad.length) {\\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\\n        fetchRedirectIds.add(fetcherKey);\\n      }\\n      return startRedirectNavigation(state, redirect3.result);\\n    }\\n    let {\\n      loaderData,\\n      errors\\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);\\n    if (state.fetchers.has(key)) {\\n      let doneFetcher = getDoneFetcher(actionResult.data);\\n      state.fetchers.set(key, doneFetcher);\\n    }\\n    abortStaleFetchLoads(loadId);\\n    if (state.navigation.state === \\\"loading\\\" && loadId > pendingNavigationLoadId) {\\n      invariant(pendingAction, \\\"Expected pending action\\\");\\n      pendingNavigationController && pendingNavigationController.abort();\\n      completeNavigation(state.navigation.location, {\\n        matches,\\n        loaderData,\\n        errors,\\n        fetchers: new Map(state.fetchers)\\n      });\\n    } else {\\n      updateState({\\n        errors,\\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\\n        fetchers: new Map(state.fetchers)\\n      });\\n      isRevalidationRequired = false;\\n    }\\n  }\\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\\n    let existingFetcher = state.fetchers.get(key);\\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\\n      flushSync\\n    });\\n    let abortController = new AbortController();\\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\\n    fetchControllers.set(key, abortController);\\n    let originatingLoadId = incrementingLoadId;\\n    let result = await callLoaderOrAction(\\\"loader\\\", fetchRequest, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\\n    if (isDeferredResult(result)) {\\n      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\\n    }\\n    if (fetchControllers.get(key) === abortController) {\\n      fetchControllers.delete(key);\\n    }\\n    if (fetchRequest.signal.aborted) {\\n      return;\\n    }\\n    if (deletedFetchers.has(key)) {\\n      updateFetcherState(key, getDoneFetcher(void 0));\\n      return;\\n    }\\n    if (isRedirectResult(result)) {\\n      if (pendingNavigationLoadId > originatingLoadId) {\\n        updateFetcherState(key, getDoneFetcher(void 0));\\n        return;\\n      } else {\\n        fetchRedirectIds.add(key);\\n        await startRedirectNavigation(state, result);\\n        return;\\n      }\\n    }\\n    if (isErrorResult(result)) {\\n      setFetcherError(key, routeId, result.error);\\n      return;\\n    }\\n    invariant(!isDeferredResult(result), \\\"Unhandled fetcher deferred data\\\");\\n    updateFetcherState(key, getDoneFetcher(result.data));\\n  }\\n  async function startRedirectNavigation(state2, redirect3, _temp2) {\\n    let {\\n      submission,\\n      fetcherSubmission,\\n      replace\\n    } = _temp2 === void 0 ? {} : _temp2;\\n    if (redirect3.revalidate) {\\n      isRevalidationRequired = true;\\n    }\\n    let redirectLocation = createLocation(state2.location, redirect3.location, {\\n      _isRedirect: true\\n    });\\n    invariant(redirectLocation, \\\"Expected a location on the redirect navigation\\\");\\n    if (isBrowser2) {\\n      let isDocumentReload = false;\\n      if (redirect3.reloadDocument) {\\n        isDocumentReload = true;\\n      } else if (ABSOLUTE_URL_REGEX.test(redirect3.location)) {\\n        const url = init.history.createURL(redirect3.location);\\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\\n        stripBasename(url.pathname, basename) == null;\\n      }\\n      if (isDocumentReload) {\\n        if (replace) {\\n          routerWindow.location.replace(redirect3.location);\\n        } else {\\n          routerWindow.location.assign(redirect3.location);\\n        }\\n        return;\\n      }\\n    }\\n    pendingNavigationController = null;\\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\\n    let {\\n      formMethod,\\n      formAction,\\n      formEncType\\n    } = state2.navigation;\\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\\n      submission = getSubmissionFromNavigation(state2.navigation);\\n    }\\n    let activeSubmission = submission || fetcherSubmission;\\n    if (redirectPreserveMethodStatusCodes.has(redirect3.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\\n      await startNavigation(redirectHistoryAction, redirectLocation, {\\n        submission: _extends({}, activeSubmission, {\\n          formAction: redirect3.location\\n        }),\\n        // Preserve this flag across redirects\\n        preventScrollReset: pendingPreventScrollReset\\n      });\\n    } else {\\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\\n      await startNavigation(redirectHistoryAction, redirectLocation, {\\n        overrideNavigation,\\n        // Send fetcher submissions through for shouldRevalidate\\n        fetcherSubmission,\\n        // Preserve this flag across redirects\\n        preventScrollReset: pendingPreventScrollReset\\n      });\\n    }\\n  }\\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\\n    let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction(\\\"loader\\\", request, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map((f) => {\\n      if (f.matches && f.match && f.controller) {\\n        return callLoaderOrAction(\\\"loader\\\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\\n      } else {\\n        let error = {\\n          type: ResultType.error,\\n          error: getInternalRouterError(404, {\\n            pathname: f.path\\n          })\\n        };\\n        return error;\\n      }\\n    })]);\\n    let loaderResults = results.slice(0, matchesToLoad.length);\\n    let fetcherResults = results.slice(matchesToLoad.length);\\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f) => f.match), fetcherResults, fetchersToLoad.map((f) => f.controller ? f.controller.signal : null), true)]);\\n    return {\\n      results,\\n      loaderResults,\\n      fetcherResults\\n    };\\n  }\\n  function interruptActiveLoads() {\\n    isRevalidationRequired = true;\\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\\n    fetchLoadMatches.forEach((_, key) => {\\n      if (fetchControllers.has(key)) {\\n        cancelledFetcherLoads.push(key);\\n        abortFetcher(key);\\n      }\\n    });\\n  }\\n  function updateFetcherState(key, fetcher, opts) {\\n    if (opts === void 0) {\\n      opts = {};\\n    }\\n    state.fetchers.set(key, fetcher);\\n    updateState({\\n      fetchers: new Map(state.fetchers)\\n    }, {\\n      flushSync: (opts && opts.flushSync) === true\\n    });\\n  }\\n  function setFetcherError(key, routeId, error, opts) {\\n    if (opts === void 0) {\\n      opts = {};\\n    }\\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\\n    deleteFetcher(key);\\n    updateState({\\n      errors: {\\n        [boundaryMatch.route.id]: error\\n      },\\n      fetchers: new Map(state.fetchers)\\n    }, {\\n      flushSync: (opts && opts.flushSync) === true\\n    });\\n  }\\n  function getFetcher(key) {\\n    if (future.v7_fetcherPersist) {\\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\\n      if (deletedFetchers.has(key)) {\\n        deletedFetchers.delete(key);\\n      }\\n    }\\n    return state.fetchers.get(key) || IDLE_FETCHER;\\n  }\\n  function deleteFetcher(key) {\\n    let fetcher = state.fetchers.get(key);\\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \\\"loading\\\" && fetchReloadIds.has(key))) {\\n      abortFetcher(key);\\n    }\\n    fetchLoadMatches.delete(key);\\n    fetchReloadIds.delete(key);\\n    fetchRedirectIds.delete(key);\\n    deletedFetchers.delete(key);\\n    state.fetchers.delete(key);\\n  }\\n  function deleteFetcherAndUpdateState(key) {\\n    if (future.v7_fetcherPersist) {\\n      let count = (activeFetchers.get(key) || 0) - 1;\\n      if (count <= 0) {\\n        activeFetchers.delete(key);\\n        deletedFetchers.add(key);\\n      } else {\\n        activeFetchers.set(key, count);\\n      }\\n    } else {\\n      deleteFetcher(key);\\n    }\\n    updateState({\\n      fetchers: new Map(state.fetchers)\\n    });\\n  }\\n  function abortFetcher(key) {\\n    let controller = fetchControllers.get(key);\\n    invariant(controller, \\\"Expected fetch controller: \\\" + key);\\n    controller.abort();\\n    fetchControllers.delete(key);\\n  }\\n  function markFetchersDone(keys) {\\n    for (let key of keys) {\\n      let fetcher = getFetcher(key);\\n      let doneFetcher = getDoneFetcher(fetcher.data);\\n      state.fetchers.set(key, doneFetcher);\\n    }\\n  }\\n  function markFetchRedirectsDone() {\\n    let doneKeys = [];\\n    let updatedFetchers = false;\\n    for (let key of fetchRedirectIds) {\\n      let fetcher = state.fetchers.get(key);\\n      invariant(fetcher, \\\"Expected fetcher: \\\" + key);\\n      if (fetcher.state === \\\"loading\\\") {\\n        fetchRedirectIds.delete(key);\\n        doneKeys.push(key);\\n        updatedFetchers = true;\\n      }\\n    }\\n    markFetchersDone(doneKeys);\\n    return updatedFetchers;\\n  }\\n  function abortStaleFetchLoads(landedId) {\\n    let yeetedKeys = [];\\n    for (let [key, id] of fetchReloadIds) {\\n      if (id < landedId) {\\n        let fetcher = state.fetchers.get(key);\\n        invariant(fetcher, \\\"Expected fetcher: \\\" + key);\\n        if (fetcher.state === \\\"loading\\\") {\\n          abortFetcher(key);\\n          fetchReloadIds.delete(key);\\n          yeetedKeys.push(key);\\n        }\\n      }\\n    }\\n    markFetchersDone(yeetedKeys);\\n    return yeetedKeys.length > 0;\\n  }\\n  function getBlocker(key, fn) {\\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\\n    if (blockerFunctions.get(key) !== fn) {\\n      blockerFunctions.set(key, fn);\\n    }\\n    return blocker;\\n  }\\n  function deleteBlocker(key) {\\n    state.blockers.delete(key);\\n    blockerFunctions.delete(key);\\n  }\\n  function updateBlocker(key, newBlocker) {\\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\\n    invariant(blocker.state === \\\"unblocked\\\" && newBlocker.state === \\\"blocked\\\" || blocker.state === \\\"blocked\\\" && newBlocker.state === \\\"blocked\\\" || blocker.state === \\\"blocked\\\" && newBlocker.state === \\\"proceeding\\\" || blocker.state === \\\"blocked\\\" && newBlocker.state === \\\"unblocked\\\" || blocker.state === \\\"proceeding\\\" && newBlocker.state === \\\"unblocked\\\", \\\"Invalid blocker state transition: \\\" + blocker.state + \\\" -> \\\" + newBlocker.state);\\n    let blockers = new Map(state.blockers);\\n    blockers.set(key, newBlocker);\\n    updateState({\\n      blockers\\n    });\\n  }\\n  function shouldBlockNavigation(_ref2) {\\n    let {\\n      currentLocation,\\n      nextLocation,\\n      historyAction\\n    } = _ref2;\\n    if (blockerFunctions.size === 0) {\\n      return;\\n    }\\n    if (blockerFunctions.size > 1) {\\n      warning(false, \\\"A router only supports one blocker at a time\\\");\\n    }\\n    let entries = Array.from(blockerFunctions.entries());\\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\\n    let blocker = state.blockers.get(blockerKey);\\n    if (blocker && blocker.state === \\\"proceeding\\\") {\\n      return;\\n    }\\n    if (blockerFunction({\\n      currentLocation,\\n      nextLocation,\\n      historyAction\\n    })) {\\n      return blockerKey;\\n    }\\n  }\\n  function cancelActiveDeferreds(predicate) {\\n    let cancelledRouteIds = [];\\n    activeDeferreds.forEach((dfd, routeId) => {\\n      if (!predicate || predicate(routeId)) {\\n        dfd.cancel();\\n        cancelledRouteIds.push(routeId);\\n        activeDeferreds.delete(routeId);\\n      }\\n    });\\n    return cancelledRouteIds;\\n  }\\n  function enableScrollRestoration(positions, getPosition, getKey) {\\n    savedScrollPositions2 = positions;\\n    getScrollPosition = getPosition;\\n    getScrollRestorationKey = getKey || null;\\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\\n      initialScrollRestored = true;\\n      let y = getSavedScrollPosition(state.location, state.matches);\\n      if (y != null) {\\n        updateState({\\n          restoreScrollPosition: y\\n        });\\n      }\\n    }\\n    return () => {\\n      savedScrollPositions2 = null;\\n      getScrollPosition = null;\\n      getScrollRestorationKey = null;\\n    };\\n  }\\n  function getScrollKey(location, matches) {\\n    if (getScrollRestorationKey) {\\n      let key = getScrollRestorationKey(location, matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));\\n      return key || location.key;\\n    }\\n    return location.key;\\n  }\\n  function saveScrollPosition(location, matches) {\\n    if (savedScrollPositions2 && getScrollPosition) {\\n      let key = getScrollKey(location, matches);\\n      savedScrollPositions2[key] = getScrollPosition();\\n    }\\n  }\\n  function getSavedScrollPosition(location, matches) {\\n    if (savedScrollPositions2) {\\n      let key = getScrollKey(location, matches);\\n      let y = savedScrollPositions2[key];\\n      if (typeof y === \\\"number\\\") {\\n        return y;\\n      }\\n    }\\n    return null;\\n  }\\n  function _internalSetRoutes(newRoutes) {\\n    manifest = {};\\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\\n  }\\n  router = {\\n    get basename() {\\n      return basename;\\n    },\\n    get future() {\\n      return future;\\n    },\\n    get state() {\\n      return state;\\n    },\\n    get routes() {\\n      return dataRoutes;\\n    },\\n    get window() {\\n      return routerWindow;\\n    },\\n    initialize,\\n    subscribe,\\n    enableScrollRestoration,\\n    navigate,\\n    fetch,\\n    revalidate,\\n    // Passthrough to history-aware createHref used by useHref so we get proper\\n    // hash-aware URLs in DOM paths\\n    createHref: (to) => init.history.createHref(to),\\n    encodeLocation: (to) => init.history.encodeLocation(to),\\n    getFetcher,\\n    deleteFetcher: deleteFetcherAndUpdateState,\\n    dispose,\\n    getBlocker,\\n    deleteBlocker,\\n    _internalFetchControllers: fetchControllers,\\n    _internalActiveDeferreds: activeDeferreds,\\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\\n    // updating the tree while validating the update algorithm.\\n    _internalSetRoutes\\n  };\\n  return router;\\n}\\nvar UNSAFE_DEFERRED_SYMBOL = Symbol(\\\"deferred\\\");\\nfunction isSubmissionNavigation(opts) {\\n  return opts != null && (\\\"formData\\\" in opts && opts.formData != null || \\\"body\\\" in opts && opts.body !== void 0);\\n}\\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\\n  let contextualMatches;\\n  let activeRouteMatch;\\n  if (fromRouteId) {\\n    contextualMatches = [];\\n    for (let match of matches) {\\n      contextualMatches.push(match);\\n      if (match.route.id === fromRouteId) {\\n        activeRouteMatch = match;\\n        break;\\n      }\\n    }\\n  } else {\\n    contextualMatches = matches;\\n    activeRouteMatch = matches[matches.length - 1];\\n  }\\n  let path = resolveTo(to ? to : \\\".\\\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \\\"path\\\");\\n  if (to == null) {\\n    path.search = location.search;\\n    path.hash = location.hash;\\n  }\\n  if ((to == null || to === \\\"\\\" || to === \\\".\\\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\\n    path.search = path.search ? path.search.replace(/^\\\\?/, \\\"?index&\\\") : \\\"?index\\\";\\n  }\\n  if (prependBasename && basename !== \\\"/\\\") {\\n    path.pathname = path.pathname === \\\"/\\\" ? basename : joinPaths([basename, path.pathname]);\\n  }\\n  return createPath(path);\\n}\\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\\n  if (!opts || !isSubmissionNavigation(opts)) {\\n    return {\\n      path\\n    };\\n  }\\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\\n    return {\\n      path,\\n      error: getInternalRouterError(405, {\\n        method: opts.formMethod\\n      })\\n    };\\n  }\\n  let getInvalidBodyError = () => ({\\n    path,\\n    error: getInternalRouterError(400, {\\n      type: \\\"invalid-body\\\"\\n    })\\n  });\\n  let rawFormMethod = opts.formMethod || \\\"get\\\";\\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\\n  let formAction = stripHashFromPath(path);\\n  if (opts.body !== void 0) {\\n    if (opts.formEncType === \\\"text/plain\\\") {\\n      if (!isMutationMethod(formMethod)) {\\n        return getInvalidBodyError();\\n      }\\n      let text = typeof opts.body === \\\"string\\\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\\n        Array.from(opts.body.entries()).reduce((acc, _ref3) => {\\n          let [name, value] = _ref3;\\n          return \\\"\\\" + acc + name + \\\"=\\\" + value + \\\"\\\\n\\\";\\n        }, \\\"\\\")\\n      ) : String(opts.body);\\n      return {\\n        path,\\n        submission: {\\n          formMethod,\\n          formAction,\\n          formEncType: opts.formEncType,\\n          formData: void 0,\\n          json: void 0,\\n          text\\n        }\\n      };\\n    } else if (opts.formEncType === \\\"application/json\\\") {\\n      if (!isMutationMethod(formMethod)) {\\n        return getInvalidBodyError();\\n      }\\n      try {\\n        let json3 = typeof opts.body === \\\"string\\\" ? JSON.parse(opts.body) : opts.body;\\n        return {\\n          path,\\n          submission: {\\n            formMethod,\\n            formAction,\\n            formEncType: opts.formEncType,\\n            formData: void 0,\\n            json: json3,\\n            text: void 0\\n          }\\n        };\\n      } catch (e) {\\n        return getInvalidBodyError();\\n      }\\n    }\\n  }\\n  invariant(typeof FormData === \\\"function\\\", \\\"FormData is not available in this environment\\\");\\n  let searchParams;\\n  let formData;\\n  if (opts.formData) {\\n    searchParams = convertFormDataToSearchParams(opts.formData);\\n    formData = opts.formData;\\n  } else if (opts.body instanceof FormData) {\\n    searchParams = convertFormDataToSearchParams(opts.body);\\n    formData = opts.body;\\n  } else if (opts.body instanceof URLSearchParams) {\\n    searchParams = opts.body;\\n    formData = convertSearchParamsToFormData(searchParams);\\n  } else if (opts.body == null) {\\n    searchParams = new URLSearchParams();\\n    formData = new FormData();\\n  } else {\\n    try {\\n      searchParams = new URLSearchParams(opts.body);\\n      formData = convertSearchParamsToFormData(searchParams);\\n    } catch (e) {\\n      return getInvalidBodyError();\\n    }\\n  }\\n  let submission = {\\n    formMethod,\\n    formAction,\\n    formEncType: opts && opts.formEncType || \\\"application/x-www-form-urlencoded\\\",\\n    formData,\\n    json: void 0,\\n    text: void 0\\n  };\\n  if (isMutationMethod(submission.formMethod)) {\\n    return {\\n      path,\\n      submission\\n    };\\n  }\\n  let parsedPath = parsePath(path);\\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\\n    searchParams.append(\\\"index\\\", \\\"\\\");\\n  }\\n  parsedPath.search = \\\"?\\\" + searchParams;\\n  return {\\n    path: createPath(parsedPath),\\n    submission\\n  };\\n}\\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\\n  let boundaryMatches = matches;\\n  if (boundaryId) {\\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\\n    if (index >= 0) {\\n      boundaryMatches = matches.slice(0, index);\\n    }\\n  }\\n  return boundaryMatches;\\n}\\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;\\n  let currentUrl = history.createURL(state.location);\\n  let nextUrl = history.createURL(location);\\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;\\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\\n  let navigationMatches = boundaryMatches.filter((match, index) => {\\n    if (isInitialLoad) {\\n      return isUnhydratedRoute(state, match.route);\\n    }\\n    if (match.route.lazy) {\\n      return true;\\n    }\\n    if (match.route.loader == null) {\\n      return false;\\n    }\\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id)) {\\n      return true;\\n    }\\n    let currentRouteMatch = state.matches[index];\\n    let nextRouteMatch = match;\\n    return shouldRevalidateLoader(match, _extends({\\n      currentUrl,\\n      currentParams: currentRouteMatch.params,\\n      nextUrl,\\n      nextParams: nextRouteMatch.params\\n    }, submission, {\\n      actionResult,\\n      defaultShouldRevalidate: (\\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\\n        isRevalidationRequired || // Clicked the same link, resubmitted a GET form\\n        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\\n      )\\n    }));\\n  });\\n  let revalidatingFetchers = [];\\n  fetchLoadMatches.forEach((f, key) => {\\n    if (isInitialLoad || !matches.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {\\n      return;\\n    }\\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\\n    if (!fetcherMatches) {\\n      revalidatingFetchers.push({\\n        key,\\n        routeId: f.routeId,\\n        path: f.path,\\n        matches: null,\\n        match: null,\\n        controller: null\\n      });\\n      return;\\n    }\\n    let fetcher = state.fetchers.get(key);\\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\\n    let shouldRevalidate = false;\\n    if (fetchRedirectIds.has(key)) {\\n      shouldRevalidate = false;\\n    } else if (cancelledFetcherLoads.includes(key)) {\\n      shouldRevalidate = true;\\n    } else if (fetcher && fetcher.state !== \\\"idle\\\" && fetcher.data === void 0) {\\n      shouldRevalidate = isRevalidationRequired;\\n    } else {\\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\\n        currentUrl,\\n        currentParams: state.matches[state.matches.length - 1].params,\\n        nextUrl,\\n        nextParams: matches[matches.length - 1].params\\n      }, submission, {\\n        actionResult,\\n        defaultShouldRevalidate: isRevalidationRequired\\n      }));\\n    }\\n    if (shouldRevalidate) {\\n      revalidatingFetchers.push({\\n        key,\\n        routeId: f.routeId,\\n        path: f.path,\\n        matches: fetcherMatches,\\n        match: fetcherMatch,\\n        controller: new AbortController()\\n      });\\n    }\\n  });\\n  return [navigationMatches, revalidatingFetchers];\\n}\\nfunction isUnhydratedRoute(state, route) {\\n  if (!route.loader) {\\n    return false;\\n  }\\n  if (route.loader.hydrate) {\\n    return true;\\n  }\\n  return state.loaderData[route.id] === void 0 && (!state.errors || // Loader ran but errored - don't re-run\\n  state.errors[route.id] === void 0);\\n}\\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\\n  let isNew = (\\n    // [a] -> [a, b]\\n    !currentMatch || // [a, b] -> [a, c]\\n    match.route.id !== currentMatch.route.id\\n  );\\n  let isMissingData = currentLoaderData[match.route.id] === void 0;\\n  return isNew || isMissingData;\\n}\\nfunction isNewRouteInstance(currentMatch, match) {\\n  let currentPath = currentMatch.route.path;\\n  return (\\n    // param change for this match, /users/123 -> /users/456\\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\\n    currentPath != null && currentPath.endsWith(\\\"*\\\") && currentMatch.params[\\\"*\\\"] !== match.params[\\\"*\\\"]\\n  );\\n}\\nfunction shouldRevalidateLoader(loaderMatch, arg) {\\n  if (loaderMatch.route.shouldRevalidate) {\\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\\n    if (typeof routeChoice === \\\"boolean\\\") {\\n      return routeChoice;\\n    }\\n  }\\n  return arg.defaultShouldRevalidate;\\n}\\nasync function loadLazyRouteModule(route, mapRouteProperties2, manifest) {\\n  if (!route.lazy) {\\n    return;\\n  }\\n  let lazyRoute = await route.lazy();\\n  if (!route.lazy) {\\n    return;\\n  }\\n  let routeToUpdate = manifest[route.id];\\n  invariant(routeToUpdate, \\\"No route found in manifest\\\");\\n  let routeUpdates = {};\\n  for (let lazyRouteProperty in lazyRoute) {\\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\\n    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\\n    // on the route updates\\n    lazyRouteProperty !== \\\"hasErrorBoundary\\\";\\n    warning(!isPropertyStaticallyDefined, 'Route \\\"' + routeToUpdate.id + '\\\" has a static property \\\"' + lazyRouteProperty + '\\\" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property \\\"' + lazyRouteProperty + '\\\" will be ignored.'));\\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\\n    }\\n  }\\n  Object.assign(routeToUpdate, routeUpdates);\\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties2(routeToUpdate), {\\n    lazy: void 0\\n  }));\\n}\\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename, v7_relativeSplatPath, opts) {\\n  if (opts === void 0) {\\n    opts = {};\\n  }\\n  let resultType;\\n  let result;\\n  let onReject;\\n  let runHandler = (handler) => {\\n    let reject;\\n    let abortPromise = new Promise((_, r) => reject = r);\\n    onReject = () => reject();\\n    request.signal.addEventListener(\\\"abort\\\", onReject);\\n    return Promise.race([handler({\\n      request,\\n      params: match.params,\\n      context: opts.requestContext\\n    }), abortPromise]);\\n  };\\n  try {\\n    let handler = match.route[type];\\n    if (match.route.lazy) {\\n      if (handler) {\\n        let handlerError;\\n        let values = await Promise.all([\\n          // If the handler throws, don't let it immediately bubble out,\\n          // since we need to let the lazy() execution finish so we know if this\\n          // route has a boundary that can handle the error\\n          runHandler(handler).catch((e) => {\\n            handlerError = e;\\n          }),\\n          loadLazyRouteModule(match.route, mapRouteProperties2, manifest)\\n        ]);\\n        if (handlerError) {\\n          throw handlerError;\\n        }\\n        result = values[0];\\n      } else {\\n        await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);\\n        handler = match.route[type];\\n        if (handler) {\\n          result = await runHandler(handler);\\n        } else if (type === \\\"action\\\") {\\n          let url = new URL(request.url);\\n          let pathname = url.pathname + url.search;\\n          throw getInternalRouterError(405, {\\n            method: request.method,\\n            pathname,\\n            routeId: match.route.id\\n          });\\n        } else {\\n          return {\\n            type: ResultType.data,\\n            data: void 0\\n          };\\n        }\\n      }\\n    } else if (!handler) {\\n      let url = new URL(request.url);\\n      let pathname = url.pathname + url.search;\\n      throw getInternalRouterError(404, {\\n        pathname\\n      });\\n    } else {\\n      result = await runHandler(handler);\\n    }\\n    invariant(result !== void 0, \\\"You defined \\\" + (type === \\\"action\\\" ? \\\"an action\\\" : \\\"a loader\\\") + \\\" for route \\\" + ('\\\"' + match.route.id + \\\"\\\\\\\" but didn't return anything from your `\\\" + type + \\\"` \\\") + \\\"function. Please return a value or `null`.\\\");\\n  } catch (e) {\\n    resultType = ResultType.error;\\n    result = e;\\n  } finally {\\n    if (onReject) {\\n      request.signal.removeEventListener(\\\"abort\\\", onReject);\\n    }\\n  }\\n  if (isResponse(result)) {\\n    let status = result.status;\\n    if (redirectStatusCodes.has(status)) {\\n      let location = result.headers.get(\\\"Location\\\");\\n      invariant(location, \\\"Redirects returned/thrown from loaders/actions must have a Location header\\\");\\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\\n      } else if (!opts.isStaticRequest) {\\n        let currentUrl = new URL(request.url);\\n        let url = location.startsWith(\\\"//\\\") ? new URL(currentUrl.protocol + location) : new URL(location);\\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\\n        if (url.origin === currentUrl.origin && isSameBasename) {\\n          location = url.pathname + url.search + url.hash;\\n        }\\n      }\\n      if (opts.isStaticRequest) {\\n        result.headers.set(\\\"Location\\\", location);\\n        throw result;\\n      }\\n      return {\\n        type: ResultType.redirect,\\n        status,\\n        location,\\n        revalidate: result.headers.get(\\\"X-Remix-Revalidate\\\") !== null,\\n        reloadDocument: result.headers.get(\\\"X-Remix-Reload-Document\\\") !== null\\n      };\\n    }\\n    if (opts.isRouteRequest) {\\n      let queryRouteResponse = {\\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\\n        response: result\\n      };\\n      throw queryRouteResponse;\\n    }\\n    let data;\\n    try {\\n      let contentType = result.headers.get(\\\"Content-Type\\\");\\n      if (contentType && /\\\\bapplication\\\\/json\\\\b/.test(contentType)) {\\n        data = await result.json();\\n      } else {\\n        data = await result.text();\\n      }\\n    } catch (e) {\\n      return {\\n        type: ResultType.error,\\n        error: e\\n      };\\n    }\\n    if (resultType === ResultType.error) {\\n      return {\\n        type: resultType,\\n        error: new ErrorResponseImpl(status, result.statusText, data),\\n        headers: result.headers\\n      };\\n    }\\n    return {\\n      type: ResultType.data,\\n      data,\\n      statusCode: result.status,\\n      headers: result.headers\\n    };\\n  }\\n  if (resultType === ResultType.error) {\\n    return {\\n      type: resultType,\\n      error: result\\n    };\\n  }\\n  if (isDeferredData(result)) {\\n    var _result$init, _result$init2;\\n    return {\\n      type: ResultType.deferred,\\n      deferredData: result,\\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\\n    };\\n  }\\n  return {\\n    type: ResultType.data,\\n    data: result\\n  };\\n}\\nfunction createClientSideRequest(history, location, signal, submission) {\\n  let url = history.createURL(stripHashFromPath(location)).toString();\\n  let init = {\\n    signal\\n  };\\n  if (submission && isMutationMethod(submission.formMethod)) {\\n    let {\\n      formMethod,\\n      formEncType\\n    } = submission;\\n    init.method = formMethod.toUpperCase();\\n    if (formEncType === \\\"application/json\\\") {\\n      init.headers = new Headers({\\n        \\\"Content-Type\\\": formEncType\\n      });\\n      init.body = JSON.stringify(submission.json);\\n    } else if (formEncType === \\\"text/plain\\\") {\\n      init.body = submission.text;\\n    } else if (formEncType === \\\"application/x-www-form-urlencoded\\\" && submission.formData) {\\n      init.body = convertFormDataToSearchParams(submission.formData);\\n    } else {\\n      init.body = submission.formData;\\n    }\\n  }\\n  return new Request(url, init);\\n}\\nfunction convertFormDataToSearchParams(formData) {\\n  let searchParams = new URLSearchParams();\\n  for (let [key, value] of formData.entries()) {\\n    searchParams.append(key, typeof value === \\\"string\\\" ? value : value.name);\\n  }\\n  return searchParams;\\n}\\nfunction convertSearchParamsToFormData(searchParams) {\\n  let formData = new FormData();\\n  for (let [key, value] of searchParams.entries()) {\\n    formData.append(key, value);\\n  }\\n  return formData;\\n}\\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\\n  let loaderData = {};\\n  let errors = null;\\n  let statusCode;\\n  let foundError = false;\\n  let loaderHeaders = {};\\n  results.forEach((result, index) => {\\n    let id = matchesToLoad[index].route.id;\\n    invariant(!isRedirectResult(result), \\\"Cannot handle redirect results in processLoaderData\\\");\\n    if (isErrorResult(result)) {\\n      let boundaryMatch = findNearestBoundary(matches, id);\\n      let error = result.error;\\n      if (pendingError) {\\n        error = Object.values(pendingError)[0];\\n        pendingError = void 0;\\n      }\\n      errors = errors || {};\\n      if (errors[boundaryMatch.route.id] == null) {\\n        errors[boundaryMatch.route.id] = error;\\n      }\\n      loaderData[id] = void 0;\\n      if (!foundError) {\\n        foundError = true;\\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\\n      }\\n      if (result.headers) {\\n        loaderHeaders[id] = result.headers;\\n      }\\n    } else {\\n      if (isDeferredResult(result)) {\\n        activeDeferreds.set(id, result.deferredData);\\n        loaderData[id] = result.deferredData.data;\\n      } else {\\n        loaderData[id] = result.data;\\n      }\\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\\n        statusCode = result.statusCode;\\n      }\\n      if (result.headers) {\\n        loaderHeaders[id] = result.headers;\\n      }\\n    }\\n  });\\n  if (pendingError) {\\n    errors = pendingError;\\n    loaderData[Object.keys(pendingError)[0]] = void 0;\\n  }\\n  return {\\n    loaderData,\\n    errors,\\n    statusCode: statusCode || 200,\\n    loaderHeaders\\n  };\\n}\\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\\n  let {\\n    loaderData,\\n    errors\\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\\n    let {\\n      key,\\n      match,\\n      controller\\n    } = revalidatingFetchers[index];\\n    invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, \\\"Did not find corresponding fetcher result\\\");\\n    let result = fetcherResults[index];\\n    if (controller && controller.signal.aborted) {\\n      continue;\\n    } else if (isErrorResult(result)) {\\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\\n      if (!(errors && errors[boundaryMatch.route.id])) {\\n        errors = _extends({}, errors, {\\n          [boundaryMatch.route.id]: result.error\\n        });\\n      }\\n      state.fetchers.delete(key);\\n    } else if (isRedirectResult(result)) {\\n      invariant(false, \\\"Unhandled fetcher revalidation redirect\\\");\\n    } else if (isDeferredResult(result)) {\\n      invariant(false, \\\"Unhandled fetcher deferred data\\\");\\n    } else {\\n      let doneFetcher = getDoneFetcher(result.data);\\n      state.fetchers.set(key, doneFetcher);\\n    }\\n  }\\n  return {\\n    loaderData,\\n    errors\\n  };\\n}\\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\\n  let mergedLoaderData = _extends({}, newLoaderData);\\n  for (let match of matches) {\\n    let id = match.route.id;\\n    if (newLoaderData.hasOwnProperty(id)) {\\n      if (newLoaderData[id] !== void 0) {\\n        mergedLoaderData[id] = newLoaderData[id];\\n      }\\n    } else if (loaderData[id] !== void 0 && match.route.loader) {\\n      mergedLoaderData[id] = loaderData[id];\\n    }\\n    if (errors && errors.hasOwnProperty(id)) {\\n      break;\\n    }\\n  }\\n  return mergedLoaderData;\\n}\\nfunction findNearestBoundary(matches, routeId) {\\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\\n}\\nfunction getShortCircuitMatches(routes) {\\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \\\"/\\\") || {\\n    id: \\\"__shim-error-route__\\\"\\n  };\\n  return {\\n    matches: [{\\n      params: {},\\n      pathname: \\\"\\\",\\n      pathnameBase: \\\"\\\",\\n      route\\n    }],\\n    route\\n  };\\n}\\nfunction getInternalRouterError(status, _temp5) {\\n  let {\\n    pathname,\\n    routeId,\\n    method,\\n    type\\n  } = _temp5 === void 0 ? {} : _temp5;\\n  let statusText = \\\"Unknown Server Error\\\";\\n  let errorMessage = \\\"Unknown @remix-run/router error\\\";\\n  if (status === 400) {\\n    statusText = \\\"Bad Request\\\";\\n    if (method && pathname && routeId) {\\n      errorMessage = \\\"You made a \\\" + method + ' request to \\\"' + pathname + '\\\" but ' + ('did not provide a `loader` for route \\\"' + routeId + '\\\", ') + \\\"so there is no way to handle the request.\\\";\\n    } else if (type === \\\"defer-action\\\") {\\n      errorMessage = \\\"defer() is not supported in actions\\\";\\n    } else if (type === \\\"invalid-body\\\") {\\n      errorMessage = \\\"Unable to encode submission body\\\";\\n    }\\n  } else if (status === 403) {\\n    statusText = \\\"Forbidden\\\";\\n    errorMessage = 'Route \\\"' + routeId + '\\\" does not match URL \\\"' + pathname + '\\\"';\\n  } else if (status === 404) {\\n    statusText = \\\"Not Found\\\";\\n    errorMessage = 'No route matches URL \\\"' + pathname + '\\\"';\\n  } else if (status === 405) {\\n    statusText = \\\"Method Not Allowed\\\";\\n    if (method && pathname && routeId) {\\n      errorMessage = \\\"You made a \\\" + method.toUpperCase() + ' request to \\\"' + pathname + '\\\" but ' + ('did not provide an `action` for route \\\"' + routeId + '\\\", ') + \\\"so there is no way to handle the request.\\\";\\n    } else if (method) {\\n      errorMessage = 'Invalid request method \\\"' + method.toUpperCase() + '\\\"';\\n    }\\n  }\\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\\n}\\nfunction findRedirect(results) {\\n  for (let i = results.length - 1; i >= 0; i--) {\\n    let result = results[i];\\n    if (isRedirectResult(result)) {\\n      return {\\n        result,\\n        idx: i\\n      };\\n    }\\n  }\\n}\\nfunction stripHashFromPath(path) {\\n  let parsedPath = typeof path === \\\"string\\\" ? parsePath(path) : path;\\n  return createPath(_extends({}, parsedPath, {\\n    hash: \\\"\\\"\\n  }));\\n}\\nfunction isHashChangeOnly(a, b) {\\n  if (a.pathname !== b.pathname || a.search !== b.search) {\\n    return false;\\n  }\\n  if (a.hash === \\\"\\\") {\\n    return b.hash !== \\\"\\\";\\n  } else if (a.hash === b.hash) {\\n    return true;\\n  } else if (b.hash !== \\\"\\\") {\\n    return true;\\n  }\\n  return false;\\n}\\nfunction isDeferredResult(result) {\\n  return result.type === ResultType.deferred;\\n}\\nfunction isErrorResult(result) {\\n  return result.type === ResultType.error;\\n}\\nfunction isRedirectResult(result) {\\n  return (result && result.type) === ResultType.redirect;\\n}\\nfunction isDeferredData(value) {\\n  let deferred = value;\\n  return deferred && typeof deferred === \\\"object\\\" && typeof deferred.data === \\\"object\\\" && typeof deferred.subscribe === \\\"function\\\" && typeof deferred.cancel === \\\"function\\\" && typeof deferred.resolveData === \\\"function\\\";\\n}\\nfunction isResponse(value) {\\n  return value != null && typeof value.status === \\\"number\\\" && typeof value.statusText === \\\"string\\\" && typeof value.headers === \\\"object\\\" && typeof value.body !== \\\"undefined\\\";\\n}\\nfunction isValidMethod(method) {\\n  return validRequestMethods.has(method.toLowerCase());\\n}\\nfunction isMutationMethod(method) {\\n  return validMutationMethods.has(method.toLowerCase());\\n}\\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\\n  for (let index = 0; index < results.length; index++) {\\n    let result = results[index];\\n    let match = matchesToLoad[index];\\n    if (!match) {\\n      continue;\\n    }\\n    let currentMatch = currentMatches.find((m) => m.route.id === match.route.id);\\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;\\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\\n      let signal = signals[index];\\n      invariant(signal, \\\"Expected an AbortSignal for revalidating fetcher deferred result\\\");\\n      await resolveDeferredData(result, signal, isFetcher).then((result2) => {\\n        if (result2) {\\n          results[index] = result2 || results[index];\\n        }\\n      });\\n    }\\n  }\\n}\\nasync function resolveDeferredData(result, signal, unwrap) {\\n  if (unwrap === void 0) {\\n    unwrap = false;\\n  }\\n  let aborted = await result.deferredData.resolveData(signal);\\n  if (aborted) {\\n    return;\\n  }\\n  if (unwrap) {\\n    try {\\n      return {\\n        type: ResultType.data,\\n        data: result.deferredData.unwrappedData\\n      };\\n    } catch (e) {\\n      return {\\n        type: ResultType.error,\\n        error: e\\n      };\\n    }\\n  }\\n  return {\\n    type: ResultType.data,\\n    data: result.deferredData.data\\n  };\\n}\\nfunction hasNakedIndexQuery(search) {\\n  return new URLSearchParams(search).getAll(\\\"index\\\").some((v) => v === \\\"\\\");\\n}\\nfunction getTargetMatch(matches, location) {\\n  let search = typeof location === \\\"string\\\" ? parsePath(location).search : location.search;\\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \\\"\\\")) {\\n    return matches[matches.length - 1];\\n  }\\n  let pathMatches = getPathContributingMatches(matches);\\n  return pathMatches[pathMatches.length - 1];\\n}\\nfunction getSubmissionFromNavigation(navigation) {\\n  let {\\n    formMethod,\\n    formAction,\\n    formEncType,\\n    text,\\n    formData,\\n    json: json3\\n  } = navigation;\\n  if (!formMethod || !formAction || !formEncType) {\\n    return;\\n  }\\n  if (text != null) {\\n    return {\\n      formMethod,\\n      formAction,\\n      formEncType,\\n      formData: void 0,\\n      json: void 0,\\n      text\\n    };\\n  } else if (formData != null) {\\n    return {\\n      formMethod,\\n      formAction,\\n      formEncType,\\n      formData,\\n      json: void 0,\\n      text: void 0\\n    };\\n  } else if (json3 !== void 0) {\\n    return {\\n      formMethod,\\n      formAction,\\n      formEncType,\\n      formData: void 0,\\n      json: json3,\\n      text: void 0\\n    };\\n  }\\n}\\nfunction getLoadingNavigation(location, submission) {\\n  if (submission) {\\n    let navigation = {\\n      state: \\\"loading\\\",\\n      location,\\n      formMethod: submission.formMethod,\\n      formAction: submission.formAction,\\n      formEncType: submission.formEncType,\\n      formData: submission.formData,\\n      json: submission.json,\\n      text: submission.text\\n    };\\n    return navigation;\\n  } else {\\n    let navigation = {\\n      state: \\\"loading\\\",\\n      location,\\n      formMethod: void 0,\\n      formAction: void 0,\\n      formEncType: void 0,\\n      formData: void 0,\\n      json: void 0,\\n      text: void 0\\n    };\\n    return navigation;\\n  }\\n}\\nfunction getSubmittingNavigation(location, submission) {\\n  let navigation = {\\n    state: \\\"submitting\\\",\\n    location,\\n    formMethod: submission.formMethod,\\n    formAction: submission.formAction,\\n    formEncType: submission.formEncType,\\n    formData: submission.formData,\\n    json: submission.json,\\n    text: submission.text\\n  };\\n  return navigation;\\n}\\nfunction getLoadingFetcher(submission, data) {\\n  if (submission) {\\n    let fetcher = {\\n      state: \\\"loading\\\",\\n      formMethod: submission.formMethod,\\n      formAction: submission.formAction,\\n      formEncType: submission.formEncType,\\n      formData: submission.formData,\\n      json: submission.json,\\n      text: submission.text,\\n      data\\n    };\\n    return fetcher;\\n  } else {\\n    let fetcher = {\\n      state: \\\"loading\\\",\\n      formMethod: void 0,\\n      formAction: void 0,\\n      formEncType: void 0,\\n      formData: void 0,\\n      json: void 0,\\n      text: void 0,\\n      data\\n    };\\n    return fetcher;\\n  }\\n}\\nfunction getSubmittingFetcher(submission, existingFetcher) {\\n  let fetcher = {\\n    state: \\\"submitting\\\",\\n    formMethod: submission.formMethod,\\n    formAction: submission.formAction,\\n    formEncType: submission.formEncType,\\n    formData: submission.formData,\\n    json: submission.json,\\n    text: submission.text,\\n    data: existingFetcher ? existingFetcher.data : void 0\\n  };\\n  return fetcher;\\n}\\nfunction getDoneFetcher(data) {\\n  let fetcher = {\\n    state: \\\"idle\\\",\\n    formMethod: void 0,\\n    formAction: void 0,\\n    formEncType: void 0,\\n    formData: void 0,\\n    json: void 0,\\n    text: void 0,\\n    data\\n  };\\n  return fetcher;\\n}\\nfunction restoreAppliedTransitions(_window, transitions) {\\n  try {\\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\\n    if (sessionPositions) {\\n      let json3 = JSON.parse(sessionPositions);\\n      for (let [k, v] of Object.entries(json3 || {})) {\\n        if (v && Array.isArray(v)) {\\n          transitions.set(k, new Set(v || []));\\n        }\\n      }\\n    }\\n  } catch (e) {\\n  }\\n}\\nfunction persistAppliedTransitions(_window, transitions) {\\n  if (transitions.size > 0) {\\n    let json3 = {};\\n    for (let [k, v] of transitions) {\\n      json3[k] = [...v];\\n    }\\n    try {\\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json3));\\n    } catch (error) {\\n      warning(false, \\\"Failed to save applied view transitions in sessionStorage (\\\" + error + \\\").\\\");\\n    }\\n  }\\n}\\n\\n// node_modules/react-router/dist/index.js\\nfunction _extends2() {\\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n    return target;\\n  };\\n  return _extends2.apply(this, arguments);\\n}\\nvar DataRouterContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  DataRouterContext.displayName = \\\"DataRouter\\\";\\n}\\nvar DataRouterStateContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  DataRouterStateContext.displayName = \\\"DataRouterState\\\";\\n}\\nvar AwaitContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  AwaitContext.displayName = \\\"Await\\\";\\n}\\nvar NavigationContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  NavigationContext.displayName = \\\"Navigation\\\";\\n}\\nvar LocationContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  LocationContext.displayName = \\\"Location\\\";\\n}\\nvar RouteContext = React.createContext({\\n  outlet: null,\\n  matches: [],\\n  isDataRoute: false\\n});\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  RouteContext.displayName = \\\"Route\\\";\\n}\\nvar RouteErrorContext = React.createContext(null);\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  RouteErrorContext.displayName = \\\"RouteError\\\";\\n}\\nfunction useHref(to, _temp) {\\n  let {\\n    relative\\n  } = _temp === void 0 ? {} : _temp;\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useHref() may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  let {\\n    basename,\\n    navigator\\n  } = React.useContext(NavigationContext);\\n  let {\\n    hash,\\n    pathname,\\n    search\\n  } = useResolvedPath(to, {\\n    relative\\n  });\\n  let joinedPathname = pathname;\\n  if (basename !== \\\"/\\\") {\\n    joinedPathname = pathname === \\\"/\\\" ? basename : joinPaths([basename, pathname]);\\n  }\\n  return navigator.createHref({\\n    pathname: joinedPathname,\\n    search,\\n    hash\\n  });\\n}\\nfunction useInRouterContext() {\\n  return React.useContext(LocationContext) != null;\\n}\\nfunction useLocation() {\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useLocation() may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  return React.useContext(LocationContext).location;\\n}\\nfunction useNavigationType() {\\n  return React.useContext(LocationContext).navigationType;\\n}\\nfunction useMatch(pattern) {\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useMatch() may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  let {\\n    pathname\\n  } = useLocation();\\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\\n}\\nvar navigateEffectWarning = \\\"You should call navigate() in a React.useEffect(), not when your component is first rendered.\\\";\\nfunction useIsomorphicLayoutEffect(cb) {\\n  let isStatic = React.useContext(NavigationContext).static;\\n  if (!isStatic) {\\n    React.useLayoutEffect(cb);\\n  }\\n}\\nfunction useNavigate() {\\n  let {\\n    isDataRoute\\n  } = React.useContext(RouteContext);\\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\\n}\\nfunction useNavigateUnstable() {\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useNavigate() may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  let dataRouterContext = React.useContext(DataRouterContext);\\n  let {\\n    basename,\\n    future,\\n    navigator\\n  } = React.useContext(NavigationContext);\\n  let {\\n    matches\\n  } = React.useContext(RouteContext);\\n  let {\\n    pathname: locationPathname\\n  } = useLocation();\\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\\n  let activeRef = React.useRef(false);\\n  useIsomorphicLayoutEffect(() => {\\n    activeRef.current = true;\\n  });\\n  let navigate = React.useCallback(function(to, options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(activeRef.current, navigateEffectWarning) : void 0;\\n    if (!activeRef.current)\\n      return;\\n    if (typeof to === \\\"number\\\") {\\n      navigator.go(to);\\n      return;\\n    }\\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \\\"path\\\");\\n    if (dataRouterContext == null && basename !== \\\"/\\\") {\\n      path.pathname = path.pathname === \\\"/\\\" ? basename : joinPaths([basename, path.pathname]);\\n    }\\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\\n  return navigate;\\n}\\nvar OutletContext = React.createContext(null);\\nfunction useOutletContext() {\\n  return React.useContext(OutletContext);\\n}\\nfunction useOutlet(context) {\\n  let outlet = React.useContext(RouteContext).outlet;\\n  if (outlet) {\\n    return React.createElement(OutletContext.Provider, {\\n      value: context\\n    }, outlet);\\n  }\\n  return outlet;\\n}\\nfunction useParams() {\\n  let {\\n    matches\\n  } = React.useContext(RouteContext);\\n  let routeMatch = matches[matches.length - 1];\\n  return routeMatch ? routeMatch.params : {};\\n}\\nfunction useResolvedPath(to, _temp2) {\\n  let {\\n    relative\\n  } = _temp2 === void 0 ? {} : _temp2;\\n  let {\\n    future\\n  } = React.useContext(NavigationContext);\\n  let {\\n    matches\\n  } = React.useContext(RouteContext);\\n  let {\\n    pathname: locationPathname\\n  } = useLocation();\\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \\\"path\\\"), [to, routePathnamesJson, locationPathname, relative]);\\n}\\nfunction useRoutes(routes, locationArg) {\\n  return useRoutesImpl(routes, locationArg);\\n}\\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of the\\n    // router loaded. We can help them understand how to avoid that.\\n    \\\"useRoutes() may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  let {\\n    navigator\\n  } = React.useContext(NavigationContext);\\n  let {\\n    matches: parentMatches\\n  } = React.useContext(RouteContext);\\n  let routeMatch = parentMatches[parentMatches.length - 1];\\n  let parentParams = routeMatch ? routeMatch.params : {};\\n  let parentPathname = routeMatch ? routeMatch.pathname : \\\"/\\\";\\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \\\"/\\\";\\n  let parentRoute = routeMatch && routeMatch.route;\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    let parentPath = parentRoute && parentRoute.path || \\\"\\\";\\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\\\"*\\\"), \\\"You rendered descendant <Routes> (or called `useRoutes()`) at \\\" + ('\\\"' + parentPathname + '\\\" (under <Route path=\\\"' + parentPath + '\\\">) but the ') + `parent route path has no trailing \\\"*\\\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\\n\\n` + ('Please change the parent <Route path=\\\"' + parentPath + '\\\"> to <Route ') + ('path=\\\"' + (parentPath === \\\"/\\\" ? \\\"*\\\" : parentPath + \\\"/*\\\") + '\\\">.'));\\n  }\\n  let locationFromContext = useLocation();\\n  let location;\\n  if (locationArg) {\\n    var _parsedLocationArg$pa;\\n    let parsedLocationArg = typeof locationArg === \\\"string\\\" ? parsePath(locationArg) : locationArg;\\n    !(parentPathnameBase === \\\"/\\\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was \\\" + ('matched by all parent routes. The current pathname base is \\\"' + parentPathnameBase + '\\\" ') + ('but pathname \\\"' + parsedLocationArg.pathname + '\\\" was given in the `location` prop.')) : invariant(false) : void 0;\\n    location = parsedLocationArg;\\n  } else {\\n    location = locationFromContext;\\n  }\\n  let pathname = location.pathname || \\\"/\\\";\\n  let remainingPathname = parentPathnameBase === \\\"/\\\" ? pathname : pathname.slice(parentPathnameBase.length) || \\\"/\\\";\\n  let matches = matchRoutes(routes, {\\n    pathname: remainingPathname\\n  });\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(parentRoute || matches != null, 'No routes matched location \\\"' + location.pathname + location.search + location.hash + '\\\" ') : void 0;\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location \\\"' + location.pathname + location.search + location.hash + '\\\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.') : void 0;\\n  }\\n  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {\\n    params: Object.assign({}, parentParams, match.params),\\n    pathname: joinPaths([\\n      parentPathnameBase,\\n      // Re-encode pathnames that were decoded inside matchRoutes\\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\\n    ]),\\n    pathnameBase: match.pathnameBase === \\\"/\\\" ? parentPathnameBase : joinPaths([\\n      parentPathnameBase,\\n      // Re-encode pathnames that were decoded inside matchRoutes\\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\\n    ])\\n  })), parentMatches, dataRouterState, future);\\n  if (locationArg && renderedMatches) {\\n    return React.createElement(LocationContext.Provider, {\\n      value: {\\n        location: _extends2({\\n          pathname: \\\"/\\\",\\n          search: \\\"\\\",\\n          hash: \\\"\\\",\\n          state: null,\\n          key: \\\"default\\\"\\n        }, location),\\n        navigationType: Action.Pop\\n      }\\n    }, renderedMatches);\\n  }\\n  return renderedMatches;\\n}\\nfunction DefaultErrorComponent() {\\n  let error = useRouteError();\\n  let message = isRouteErrorResponse(error) ? error.status + \\\" \\\" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\\n  let stack = error instanceof Error ? error.stack : null;\\n  let lightgrey = \\\"rgba(200,200,200, 0.5)\\\";\\n  let preStyles = {\\n    padding: \\\"0.5rem\\\",\\n    backgroundColor: lightgrey\\n  };\\n  let codeStyles = {\\n    padding: \\\"2px 4px\\\",\\n    backgroundColor: lightgrey\\n  };\\n  let devInfo = null;\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    console.error(\\\"Error handled by React Router default ErrorBoundary:\\\", error);\\n    devInfo = React.createElement(React.Fragment, null, React.createElement(\\\"p\\\", null, \\\" Hey developer \\\"), React.createElement(\\\"p\\\", null, \\\"You can provide a way better UX than this when your app throws errors by providing your own \\\", React.createElement(\\\"code\\\", {\\n      style: codeStyles\\n    }, \\\"ErrorBoundary\\\"), \\\" or\\\", \\\" \\\", React.createElement(\\\"code\\\", {\\n      style: codeStyles\\n    }, \\\"errorElement\\\"), \\\" prop on your route.\\\"));\\n  }\\n  return React.createElement(React.Fragment, null, React.createElement(\\\"h2\\\", null, \\\"Unexpected Application Error!\\\"), React.createElement(\\\"h3\\\", {\\n    style: {\\n      fontStyle: \\\"italic\\\"\\n    }\\n  }, message), stack ? React.createElement(\\\"pre\\\", {\\n    style: preStyles\\n  }, stack) : null, devInfo);\\n}\\nvar defaultErrorElement = React.createElement(DefaultErrorComponent, null);\\nvar RenderErrorBoundary = class extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      location: props.location,\\n      revalidation: props.revalidation,\\n      error: props.error\\n    };\\n  }\\n  static getDerivedStateFromError(error) {\\n    return {\\n      error\\n    };\\n  }\\n  static getDerivedStateFromProps(props, state) {\\n    if (state.location !== props.location || state.revalidation !== \\\"idle\\\" && props.revalidation === \\\"idle\\\") {\\n      return {\\n        error: props.error,\\n        location: props.location,\\n        revalidation: props.revalidation\\n      };\\n    }\\n    return {\\n      error: props.error !== void 0 ? props.error : state.error,\\n      location: state.location,\\n      revalidation: props.revalidation || state.revalidation\\n    };\\n  }\\n  componentDidCatch(error, errorInfo) {\\n    console.error(\\\"React Router caught the following error during render\\\", error, errorInfo);\\n  }\\n  render() {\\n    return this.state.error !== void 0 ? React.createElement(RouteContext.Provider, {\\n      value: this.props.routeContext\\n    }, React.createElement(RouteErrorContext.Provider, {\\n      value: this.state.error,\\n      children: this.props.component\\n    })) : this.props.children;\\n  }\\n};\\nfunction RenderedRoute(_ref) {\\n  let {\\n    routeContext,\\n    match,\\n    children\\n  } = _ref;\\n  let dataRouterContext = React.useContext(DataRouterContext);\\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\\n  }\\n  return React.createElement(RouteContext.Provider, {\\n    value: routeContext\\n  }, children);\\n}\\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\\n  var _dataRouterState2;\\n  if (parentMatches === void 0) {\\n    parentMatches = [];\\n  }\\n  if (dataRouterState === void 0) {\\n    dataRouterState = null;\\n  }\\n  if (future === void 0) {\\n    future = null;\\n  }\\n  if (matches == null) {\\n    var _dataRouterState;\\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\\n      matches = dataRouterState.matches;\\n    } else {\\n      return null;\\n    }\\n  }\\n  let renderedMatches = matches;\\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\\n  if (errors != null) {\\n    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"Could not find a matching route for errors on route IDs: \\\" + Object.keys(errors).join(\\\",\\\")) : invariant(false) : void 0;\\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\\n  }\\n  let renderFallback = false;\\n  let fallbackIndex = -1;\\n  if (dataRouterState && future && future.v7_partialHydration) {\\n    for (let i = 0; i < renderedMatches.length; i++) {\\n      let match = renderedMatches[i];\\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\\n        fallbackIndex = i;\\n      }\\n      if (match.route.loader && match.route.id && dataRouterState.loaderData[match.route.id] === void 0 && (!dataRouterState.errors || dataRouterState.errors[match.route.id] === void 0)) {\\n        renderFallback = true;\\n        if (fallbackIndex >= 0) {\\n          renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\\n        } else {\\n          renderedMatches = [renderedMatches[0]];\\n        }\\n        break;\\n      }\\n    }\\n  }\\n  return renderedMatches.reduceRight((outlet, match, index) => {\\n    let error;\\n    let shouldRenderHydrateFallback = false;\\n    let errorElement = null;\\n    let hydrateFallbackElement = null;\\n    if (dataRouterState) {\\n      error = errors && match.route.id ? errors[match.route.id] : void 0;\\n      errorElement = match.route.errorElement || defaultErrorElement;\\n      if (renderFallback) {\\n        if (fallbackIndex < 0 && index === 0) {\\n          warningOnce(\\\"route-fallback\\\", false, \\\"No `HydrateFallback` element provided to render during initial hydration\\\");\\n          shouldRenderHydrateFallback = true;\\n          hydrateFallbackElement = null;\\n        } else if (fallbackIndex === index) {\\n          shouldRenderHydrateFallback = true;\\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\\n        }\\n      }\\n    }\\n    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\\n    let getChildren = () => {\\n      let children;\\n      if (error) {\\n        children = errorElement;\\n      } else if (shouldRenderHydrateFallback) {\\n        children = hydrateFallbackElement;\\n      } else if (match.route.Component) {\\n        children = React.createElement(match.route.Component, null);\\n      } else if (match.route.element) {\\n        children = match.route.element;\\n      } else {\\n        children = outlet;\\n      }\\n      return React.createElement(RenderedRoute, {\\n        match,\\n        routeContext: {\\n          outlet,\\n          matches: matches2,\\n          isDataRoute: dataRouterState != null\\n        },\\n        children\\n      });\\n    };\\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React.createElement(RenderErrorBoundary, {\\n      location: dataRouterState.location,\\n      revalidation: dataRouterState.revalidation,\\n      component: errorElement,\\n      error,\\n      children: getChildren(),\\n      routeContext: {\\n        outlet: null,\\n        matches: matches2,\\n        isDataRoute: true\\n      }\\n    }) : getChildren();\\n  }, null);\\n}\\nvar DataRouterHook = function(DataRouterHook3) {\\n  DataRouterHook3[\\\"UseBlocker\\\"] = \\\"useBlocker\\\";\\n  DataRouterHook3[\\\"UseRevalidator\\\"] = \\\"useRevalidator\\\";\\n  DataRouterHook3[\\\"UseNavigateStable\\\"] = \\\"useNavigate\\\";\\n  return DataRouterHook3;\\n}(DataRouterHook || {});\\nvar DataRouterStateHook = function(DataRouterStateHook3) {\\n  DataRouterStateHook3[\\\"UseBlocker\\\"] = \\\"useBlocker\\\";\\n  DataRouterStateHook3[\\\"UseLoaderData\\\"] = \\\"useLoaderData\\\";\\n  DataRouterStateHook3[\\\"UseActionData\\\"] = \\\"useActionData\\\";\\n  DataRouterStateHook3[\\\"UseRouteError\\\"] = \\\"useRouteError\\\";\\n  DataRouterStateHook3[\\\"UseNavigation\\\"] = \\\"useNavigation\\\";\\n  DataRouterStateHook3[\\\"UseRouteLoaderData\\\"] = \\\"useRouteLoaderData\\\";\\n  DataRouterStateHook3[\\\"UseMatches\\\"] = \\\"useMatches\\\";\\n  DataRouterStateHook3[\\\"UseRevalidator\\\"] = \\\"useRevalidator\\\";\\n  DataRouterStateHook3[\\\"UseNavigateStable\\\"] = \\\"useNavigate\\\";\\n  DataRouterStateHook3[\\\"UseRouteId\\\"] = \\\"useRouteId\\\";\\n  return DataRouterStateHook3;\\n}(DataRouterStateHook || {});\\nfunction getDataRouterConsoleError(hookName) {\\n  return hookName + \\\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\\\";\\n}\\nfunction useDataRouterContext(hookName) {\\n  let ctx = React.useContext(DataRouterContext);\\n  !ctx ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\\n  return ctx;\\n}\\nfunction useDataRouterState(hookName) {\\n  let state = React.useContext(DataRouterStateContext);\\n  !state ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\\n  return state;\\n}\\nfunction useRouteContext(hookName) {\\n  let route = React.useContext(RouteContext);\\n  !route ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\\n  return route;\\n}\\nfunction useCurrentRouteId(hookName) {\\n  let route = useRouteContext(hookName);\\n  let thisRoute = route.matches[route.matches.length - 1];\\n  !thisRoute.route.id ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, hookName + ' can only be used on routes that contain a unique \\\"id\\\"') : invariant(false) : void 0;\\n  return thisRoute.route.id;\\n}\\nfunction useRouteId() {\\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\\n}\\nfunction useNavigation() {\\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\\n  return state.navigation;\\n}\\nfunction useRevalidator() {\\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\\n  return React.useMemo(() => ({\\n    revalidate: dataRouterContext.router.revalidate,\\n    state: state.revalidation\\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\\n}\\nfunction useMatches() {\\n  let {\\n    matches,\\n    loaderData\\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\\n  return React.useMemo(() => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\\n}\\nfunction useLoaderData() {\\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\\n  if (state.errors && state.errors[routeId] != null) {\\n    console.error(\\\"You cannot `useLoaderData` in an errorElement (routeId: \\\" + routeId + \\\")\\\");\\n    return void 0;\\n  }\\n  return state.loaderData[routeId];\\n}\\nfunction useRouteLoaderData(routeId) {\\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\\n  return state.loaderData[routeId];\\n}\\nfunction useActionData() {\\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\\n  return state.actionData ? state.actionData[routeId] : void 0;\\n}\\nfunction useRouteError() {\\n  var _state$errors;\\n  let error = React.useContext(RouteErrorContext);\\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\\n  if (error !== void 0) {\\n    return error;\\n  }\\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\\n}\\nfunction useAsyncValue() {\\n  let value = React.useContext(AwaitContext);\\n  return value == null ? void 0 : value._data;\\n}\\nfunction useAsyncError() {\\n  let value = React.useContext(AwaitContext);\\n  return value == null ? void 0 : value._error;\\n}\\nvar blockerId = 0;\\nfunction useBlocker(shouldBlock) {\\n  let {\\n    router,\\n    basename\\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\\n  let [blockerKey, setBlockerKey] = React.useState(\\\"\\\");\\n  let blockerFunction = React.useCallback((arg) => {\\n    if (typeof shouldBlock !== \\\"function\\\") {\\n      return !!shouldBlock;\\n    }\\n    if (basename === \\\"/\\\") {\\n      return shouldBlock(arg);\\n    }\\n    let {\\n      currentLocation,\\n      nextLocation,\\n      historyAction\\n    } = arg;\\n    return shouldBlock({\\n      currentLocation: _extends2({}, currentLocation, {\\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\\n      }),\\n      nextLocation: _extends2({}, nextLocation, {\\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\\n      }),\\n      historyAction\\n    });\\n  }, [basename, shouldBlock]);\\n  React.useEffect(() => {\\n    let key = String(++blockerId);\\n    setBlockerKey(key);\\n    return () => router.deleteBlocker(key);\\n  }, [router]);\\n  React.useEffect(() => {\\n    if (blockerKey !== \\\"\\\") {\\n      router.getBlocker(blockerKey, blockerFunction);\\n    }\\n  }, [router, blockerKey, blockerFunction]);\\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\\n}\\nfunction useNavigateStable() {\\n  let {\\n    router\\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\\n  let activeRef = React.useRef(false);\\n  useIsomorphicLayoutEffect(() => {\\n    activeRef.current = true;\\n  });\\n  let navigate = React.useCallback(function(to, options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(activeRef.current, navigateEffectWarning) : void 0;\\n    if (!activeRef.current)\\n      return;\\n    if (typeof to === \\\"number\\\") {\\n      router.navigate(to);\\n    } else {\\n      router.navigate(to, _extends2({\\n        fromRouteId: id\\n      }, options));\\n    }\\n  }, [router, id]);\\n  return navigate;\\n}\\nvar alreadyWarned = {};\\nfunction warningOnce(key, cond, message) {\\n  if (!cond && !alreadyWarned[key]) {\\n    alreadyWarned[key] = true;\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(false, message) : void 0;\\n  }\\n}\\nvar START_TRANSITION = \\\"startTransition\\\";\\nvar startTransitionImpl = React[START_TRANSITION];\\nfunction MemoryRouter(_ref3) {\\n  let {\\n    basename,\\n    children,\\n    initialEntries,\\n    initialIndex,\\n    future\\n  } = _ref3;\\n  let historyRef = React.useRef();\\n  if (historyRef.current == null) {\\n    historyRef.current = createMemoryHistory({\\n      initialEntries,\\n      initialIndex,\\n      v5Compat: true\\n    });\\n  }\\n  let history = historyRef.current;\\n  let [state, setStateImpl] = React.useState({\\n    action: history.action,\\n    location: history.location\\n  });\\n  let {\\n    v7_startTransition\\n  } = future || {};\\n  let setState = React.useCallback((newState) => {\\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\\n  }, [setStateImpl, v7_startTransition]);\\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\\n  return React.createElement(Router, {\\n    basename,\\n    children,\\n    location: state.location,\\n    navigationType: state.action,\\n    navigator: history,\\n    future\\n  });\\n}\\nfunction Navigate(_ref4) {\\n  let {\\n    to,\\n    replace,\\n    state,\\n    relative\\n  } = _ref4;\\n  !useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(\\n    false,\\n    // TODO: This error is probably because they somehow have 2 versions of\\n    // the router loaded. We can help them understand how to avoid that.\\n    \\\"<Navigate> may be used only in the context of a <Router> component.\\\"\\n  ) : invariant(false) : void 0;\\n  let {\\n    future,\\n    static: isStatic\\n  } = React.useContext(NavigationContext);\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(!isStatic, \\\"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\\\") : void 0;\\n  let {\\n    matches\\n  } = React.useContext(RouteContext);\\n  let {\\n    pathname: locationPathname\\n  } = useLocation();\\n  let navigate = useNavigate();\\n  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \\\"path\\\");\\n  let jsonPath = JSON.stringify(path);\\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\\n    replace,\\n    state,\\n    relative\\n  }), [navigate, jsonPath, relative, replace, state]);\\n  return null;\\n}\\nfunction Outlet(props) {\\n  return useOutlet(props.context);\\n}\\nfunction Route(_props) {\\n  process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.\\\") : invariant(false);\\n}\\nfunction Router(_ref5) {\\n  let {\\n    basename: basenameProp = \\\"/\\\",\\n    children = null,\\n    location: locationProp,\\n    navigationType = Action.Pop,\\n    navigator,\\n    static: staticProp = false,\\n    future\\n  } = _ref5;\\n  !!useInRouterContext() ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.\\\") : invariant(false) : void 0;\\n  let basename = basenameProp.replace(/^\\\\/*/, \\\"/\\\");\\n  let navigationContext = React.useMemo(() => ({\\n    basename,\\n    navigator,\\n    static: staticProp,\\n    future: _extends2({\\n      v7_relativeSplatPath: false\\n    }, future)\\n  }), [basename, future, navigator, staticProp]);\\n  if (typeof locationProp === \\\"string\\\") {\\n    locationProp = parsePath(locationProp);\\n  }\\n  let {\\n    pathname = \\\"/\\\",\\n    search = \\\"\\\",\\n    hash = \\\"\\\",\\n    state = null,\\n    key = \\\"default\\\"\\n  } = locationProp;\\n  let locationContext = React.useMemo(() => {\\n    let trailingPathname = stripBasename(pathname, basename);\\n    if (trailingPathname == null) {\\n      return null;\\n    }\\n    return {\\n      location: {\\n        pathname: trailingPathname,\\n        search,\\n        hash,\\n        state,\\n        key\\n      },\\n      navigationType\\n    };\\n  }, [basename, pathname, search, hash, state, key, navigationType]);\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(locationContext != null, '<Router basename=\\\"' + basename + '\\\"> is not able to match the URL ' + ('\\\"' + pathname + search + hash + '\\\" because it does not start with the ') + \\\"basename, so the <Router> won't render anything.\\\") : void 0;\\n  if (locationContext == null) {\\n    return null;\\n  }\\n  return React.createElement(NavigationContext.Provider, {\\n    value: navigationContext\\n  }, React.createElement(LocationContext.Provider, {\\n    children,\\n    value: locationContext\\n  }));\\n}\\nfunction Routes(_ref6) {\\n  let {\\n    children,\\n    location\\n  } = _ref6;\\n  return useRoutes(createRoutesFromChildren(children), location);\\n}\\nfunction Await(_ref7) {\\n  let {\\n    children,\\n    errorElement,\\n    resolve\\n  } = _ref7;\\n  return React.createElement(AwaitErrorBoundary, {\\n    resolve,\\n    errorElement\\n  }, React.createElement(ResolveAwait, null, children));\\n}\\nvar AwaitRenderStatus = function(AwaitRenderStatus2) {\\n  AwaitRenderStatus2[AwaitRenderStatus2[\\\"pending\\\"] = 0] = \\\"pending\\\";\\n  AwaitRenderStatus2[AwaitRenderStatus2[\\\"success\\\"] = 1] = \\\"success\\\";\\n  AwaitRenderStatus2[AwaitRenderStatus2[\\\"error\\\"] = 2] = \\\"error\\\";\\n  return AwaitRenderStatus2;\\n}(AwaitRenderStatus || {});\\nvar neverSettledPromise = new Promise(() => {\\n});\\nvar AwaitErrorBoundary = class extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      error: null\\n    };\\n  }\\n  static getDerivedStateFromError(error) {\\n    return {\\n      error\\n    };\\n  }\\n  componentDidCatch(error, errorInfo) {\\n    console.error(\\\"<Await> caught the following error during render\\\", error, errorInfo);\\n  }\\n  render() {\\n    let {\\n      children,\\n      errorElement,\\n      resolve\\n    } = this.props;\\n    let promise = null;\\n    let status = AwaitRenderStatus.pending;\\n    if (!(resolve instanceof Promise)) {\\n      status = AwaitRenderStatus.success;\\n      promise = Promise.resolve();\\n      Object.defineProperty(promise, \\\"_tracked\\\", {\\n        get: () => true\\n      });\\n      Object.defineProperty(promise, \\\"_data\\\", {\\n        get: () => resolve\\n      });\\n    } else if (this.state.error) {\\n      status = AwaitRenderStatus.error;\\n      let renderError = this.state.error;\\n      promise = Promise.reject().catch(() => {\\n      });\\n      Object.defineProperty(promise, \\\"_tracked\\\", {\\n        get: () => true\\n      });\\n      Object.defineProperty(promise, \\\"_error\\\", {\\n        get: () => renderError\\n      });\\n    } else if (resolve._tracked) {\\n      promise = resolve;\\n      status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\\n    } else {\\n      status = AwaitRenderStatus.pending;\\n      Object.defineProperty(resolve, \\\"_tracked\\\", {\\n        get: () => true\\n      });\\n      promise = resolve.then((data) => Object.defineProperty(resolve, \\\"_data\\\", {\\n        get: () => data\\n      }), (error) => Object.defineProperty(resolve, \\\"_error\\\", {\\n        get: () => error\\n      }));\\n    }\\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\\n      throw neverSettledPromise;\\n    }\\n    if (status === AwaitRenderStatus.error && !errorElement) {\\n      throw promise._error;\\n    }\\n    if (status === AwaitRenderStatus.error) {\\n      return React.createElement(AwaitContext.Provider, {\\n        value: promise,\\n        children: errorElement\\n      });\\n    }\\n    if (status === AwaitRenderStatus.success) {\\n      return React.createElement(AwaitContext.Provider, {\\n        value: promise,\\n        children\\n      });\\n    }\\n    throw promise;\\n  }\\n};\\nfunction ResolveAwait(_ref8) {\\n  let {\\n    children\\n  } = _ref8;\\n  let data = useAsyncValue();\\n  let toRender = typeof children === \\\"function\\\" ? children(data) : children;\\n  return React.createElement(React.Fragment, null, toRender);\\n}\\nfunction createRoutesFromChildren(children, parentPath) {\\n  if (parentPath === void 0) {\\n    parentPath = [];\\n  }\\n  let routes = [];\\n  React.Children.forEach(children, (element, index) => {\\n    if (!React.isValidElement(element)) {\\n      return;\\n    }\\n    let treePath = [...parentPath, index];\\n    if (element.type === React.Fragment) {\\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\\n      return;\\n    }\\n    !(element.type === Route) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"[\\\" + (typeof element.type === \\\"string\\\" ? element.type : element.type.name) + \\\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\\\") : invariant(false) : void 0;\\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"An index route cannot have child routes.\\\") : invariant(false) : void 0;\\n    let route = {\\n      id: element.props.id || treePath.join(\\\"-\\\"),\\n      caseSensitive: element.props.caseSensitive,\\n      element: element.props.element,\\n      Component: element.props.Component,\\n      index: element.props.index,\\n      path: element.props.path,\\n      loader: element.props.loader,\\n      action: element.props.action,\\n      errorElement: element.props.errorElement,\\n      ErrorBoundary: element.props.ErrorBoundary,\\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\\n      shouldRevalidate: element.props.shouldRevalidate,\\n      handle: element.props.handle,\\n      lazy: element.props.lazy\\n    };\\n    if (element.props.children) {\\n      route.children = createRoutesFromChildren(element.props.children, treePath);\\n    }\\n    routes.push(route);\\n  });\\n  return routes;\\n}\\nfunction renderMatches(matches) {\\n  return _renderMatches(matches);\\n}\\nfunction mapRouteProperties(route) {\\n  let updates = {\\n    // Note: this check also occurs in createRoutesFromChildren so update\\n    // there if you change this -- please and thank you!\\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\\n  };\\n  if (route.Component) {\\n    if (process.env.NODE_ENV !== \\\"production\\\") {\\n      if (route.element) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(false, \\\"You should not include both `Component` and `element` on your route - `Component` will be used.\\\") : void 0;\\n      }\\n    }\\n    Object.assign(updates, {\\n      element: React.createElement(route.Component),\\n      Component: void 0\\n    });\\n  }\\n  if (route.HydrateFallback) {\\n    if (process.env.NODE_ENV !== \\\"production\\\") {\\n      if (route.hydrateFallbackElement) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(false, \\\"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\\\") : void 0;\\n      }\\n    }\\n    Object.assign(updates, {\\n      hydrateFallbackElement: React.createElement(route.HydrateFallback),\\n      HydrateFallback: void 0\\n    });\\n  }\\n  if (route.ErrorBoundary) {\\n    if (process.env.NODE_ENV !== \\\"production\\\") {\\n      if (route.errorElement) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(false, \\\"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\\\") : void 0;\\n      }\\n    }\\n    Object.assign(updates, {\\n      errorElement: React.createElement(route.ErrorBoundary),\\n      ErrorBoundary: void 0\\n    });\\n  }\\n  return updates;\\n}\\nfunction createMemoryRouter(routes, opts) {\\n  return createRouter({\\n    basename: opts == null ? void 0 : opts.basename,\\n    future: _extends2({}, opts == null ? void 0 : opts.future, {\\n      v7_prependBasename: true\\n    }),\\n    history: createMemoryHistory({\\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\\n      initialIndex: opts == null ? void 0 : opts.initialIndex\\n    }),\\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\\n    routes,\\n    mapRouteProperties\\n  }).initialize();\\n}\\n\\n// node_modules/react-router-dom/dist/index.js\\nfunction _extends3() {\\n  _extends3 = Object.assign ? Object.assign.bind() : function(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n    return target;\\n  };\\n  return _extends3.apply(this, arguments);\\n}\\nfunction _objectWithoutPropertiesLoose(source, excluded) {\\n  if (source == null)\\n    return {};\\n  var target = {};\\n  var sourceKeys = Object.keys(source);\\n  var key, i;\\n  for (i = 0; i < sourceKeys.length; i++) {\\n    key = sourceKeys[i];\\n    if (excluded.indexOf(key) >= 0)\\n      continue;\\n    target[key] = source[key];\\n  }\\n  return target;\\n}\\nvar defaultMethod = \\\"get\\\";\\nvar defaultEncType = \\\"application/x-www-form-urlencoded\\\";\\nfunction isHtmlElement(object) {\\n  return object != null && typeof object.tagName === \\\"string\\\";\\n}\\nfunction isButtonElement(object) {\\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \\\"button\\\";\\n}\\nfunction isFormElement(object) {\\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \\\"form\\\";\\n}\\nfunction isInputElement(object) {\\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \\\"input\\\";\\n}\\nfunction isModifiedEvent(event) {\\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\\n}\\nfunction shouldProcessLinkClick(event, target) {\\n  return event.button === 0 && // Ignore everything but left clicks\\n  (!target || target === \\\"_self\\\") && // Let browser handle \\\"target=_blank\\\" etc.\\n  !isModifiedEvent(event);\\n}\\nfunction createSearchParams(init) {\\n  if (init === void 0) {\\n    init = \\\"\\\";\\n  }\\n  return new URLSearchParams(typeof init === \\\"string\\\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\\n    let value = init[key];\\n    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);\\n  }, []));\\n}\\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\\n  let searchParams = createSearchParams(locationSearch);\\n  if (defaultSearchParams) {\\n    defaultSearchParams.forEach((_, key) => {\\n      if (!searchParams.has(key)) {\\n        defaultSearchParams.getAll(key).forEach((value) => {\\n          searchParams.append(key, value);\\n        });\\n      }\\n    });\\n  }\\n  return searchParams;\\n}\\nvar _formDataSupportsSubmitter = null;\\nfunction isFormDataSubmitterSupported() {\\n  if (_formDataSupportsSubmitter === null) {\\n    try {\\n      new FormData(\\n        document.createElement(\\\"form\\\"),\\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\\n        0\\n      );\\n      _formDataSupportsSubmitter = false;\\n    } catch (e) {\\n      _formDataSupportsSubmitter = true;\\n    }\\n  }\\n  return _formDataSupportsSubmitter;\\n}\\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\\\"application/x-www-form-urlencoded\\\", \\\"multipart/form-data\\\", \\\"text/plain\\\"]);\\nfunction getFormEncType(encType) {\\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(false, '\\\"' + encType + '\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \\\"' + defaultEncType + '\\\"')) : void 0;\\n    return null;\\n  }\\n  return encType;\\n}\\nfunction getFormSubmissionInfo(target, basename) {\\n  let method;\\n  let action;\\n  let encType;\\n  let formData;\\n  let body;\\n  if (isFormElement(target)) {\\n    let attr = target.getAttribute(\\\"action\\\");\\n    action = attr ? stripBasename(attr, basename) : null;\\n    method = target.getAttribute(\\\"method\\\") || defaultMethod;\\n    encType = getFormEncType(target.getAttribute(\\\"enctype\\\")) || defaultEncType;\\n    formData = new FormData(target);\\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \\\"submit\\\" || target.type === \\\"image\\\")) {\\n    let form = target.form;\\n    if (form == null) {\\n      throw new Error('Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>');\\n    }\\n    let attr = target.getAttribute(\\\"formaction\\\") || form.getAttribute(\\\"action\\\");\\n    action = attr ? stripBasename(attr, basename) : null;\\n    method = target.getAttribute(\\\"formmethod\\\") || form.getAttribute(\\\"method\\\") || defaultMethod;\\n    encType = getFormEncType(target.getAttribute(\\\"formenctype\\\")) || getFormEncType(form.getAttribute(\\\"enctype\\\")) || defaultEncType;\\n    formData = new FormData(form, target);\\n    if (!isFormDataSubmitterSupported()) {\\n      let {\\n        name,\\n        type,\\n        value\\n      } = target;\\n      if (type === \\\"image\\\") {\\n        let prefix = name ? name + \\\".\\\" : \\\"\\\";\\n        formData.append(prefix + \\\"x\\\", \\\"0\\\");\\n        formData.append(prefix + \\\"y\\\", \\\"0\\\");\\n      } else if (name) {\\n        formData.append(name, value);\\n      }\\n    }\\n  } else if (isHtmlElement(target)) {\\n    throw new Error('Cannot submit element that is not <form>, <button>, or <input type=\\\"submit|image\\\">');\\n  } else {\\n    method = defaultMethod;\\n    action = null;\\n    encType = defaultEncType;\\n    body = target;\\n  }\\n  if (formData && encType === \\\"text/plain\\\") {\\n    body = formData;\\n    formData = void 0;\\n  }\\n  return {\\n    action,\\n    method: method.toLowerCase(),\\n    encType,\\n    formData,\\n    body\\n  };\\n}\\nvar _excluded = [\\\"onClick\\\", \\\"relative\\\", \\\"reloadDocument\\\", \\\"replace\\\", \\\"state\\\", \\\"target\\\", \\\"to\\\", \\\"preventScrollReset\\\", \\\"unstable_viewTransition\\\"];\\nvar _excluded2 = [\\\"aria-current\\\", \\\"caseSensitive\\\", \\\"className\\\", \\\"end\\\", \\\"style\\\", \\\"to\\\", \\\"unstable_viewTransition\\\", \\\"children\\\"];\\nvar _excluded3 = [\\\"fetcherKey\\\", \\\"navigate\\\", \\\"reloadDocument\\\", \\\"replace\\\", \\\"state\\\", \\\"method\\\", \\\"action\\\", \\\"onSubmit\\\", \\\"relative\\\", \\\"preventScrollReset\\\", \\\"unstable_viewTransition\\\"];\\nfunction createBrowserRouter(routes, opts) {\\n  return createRouter({\\n    basename: opts == null ? void 0 : opts.basename,\\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\\n      v7_prependBasename: true\\n    }),\\n    history: createBrowserHistory({\\n      window: opts == null ? void 0 : opts.window\\n    }),\\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\\n    routes,\\n    mapRouteProperties,\\n    window: opts == null ? void 0 : opts.window\\n  }).initialize();\\n}\\nfunction createHashRouter(routes, opts) {\\n  return createRouter({\\n    basename: opts == null ? void 0 : opts.basename,\\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\\n      v7_prependBasename: true\\n    }),\\n    history: createHashHistory({\\n      window: opts == null ? void 0 : opts.window\\n    }),\\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\\n    routes,\\n    mapRouteProperties,\\n    window: opts == null ? void 0 : opts.window\\n  }).initialize();\\n}\\nfunction parseHydrationData() {\\n  var _window;\\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\\n  if (state && state.errors) {\\n    state = _extends3({}, state, {\\n      errors: deserializeErrors(state.errors)\\n    });\\n  }\\n  return state;\\n}\\nfunction deserializeErrors(errors) {\\n  if (!errors)\\n    return null;\\n  let entries = Object.entries(errors);\\n  let serialized = {};\\n  for (let [key, val] of entries) {\\n    if (val && val.__type === \\\"RouteErrorResponse\\\") {\\n      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\\n    } else if (val && val.__type === \\\"Error\\\") {\\n      if (val.__subType) {\\n        let ErrorConstructor = window[val.__subType];\\n        if (typeof ErrorConstructor === \\\"function\\\") {\\n          try {\\n            let error = new ErrorConstructor(val.message);\\n            error.stack = \\\"\\\";\\n            serialized[key] = error;\\n          } catch (e) {\\n          }\\n        }\\n      }\\n      if (serialized[key] == null) {\\n        let error = new Error(val.message);\\n        error.stack = \\\"\\\";\\n        serialized[key] = error;\\n      }\\n    } else {\\n      serialized[key] = val;\\n    }\\n  }\\n  return serialized;\\n}\\nvar ViewTransitionContext = React2.createContext({\\n  isTransitioning: false\\n});\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  ViewTransitionContext.displayName = \\\"ViewTransition\\\";\\n}\\nvar FetchersContext = React2.createContext(/* @__PURE__ */ new Map());\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  FetchersContext.displayName = \\\"Fetchers\\\";\\n}\\nvar START_TRANSITION2 = \\\"startTransition\\\";\\nvar startTransitionImpl2 = React2[START_TRANSITION2];\\nvar FLUSH_SYNC = \\\"flushSync\\\";\\nvar flushSyncImpl = ReactDOM[FLUSH_SYNC];\\nfunction startTransitionSafe(cb) {\\n  if (startTransitionImpl2) {\\n    startTransitionImpl2(cb);\\n  } else {\\n    cb();\\n  }\\n}\\nfunction flushSyncSafe(cb) {\\n  if (flushSyncImpl) {\\n    flushSyncImpl(cb);\\n  } else {\\n    cb();\\n  }\\n}\\nvar Deferred = class {\\n  constructor() {\\n    this.status = \\\"pending\\\";\\n    this.promise = new Promise((resolve, reject) => {\\n      this.resolve = (value) => {\\n        if (this.status === \\\"pending\\\") {\\n          this.status = \\\"resolved\\\";\\n          resolve(value);\\n        }\\n      };\\n      this.reject = (reason) => {\\n        if (this.status === \\\"pending\\\") {\\n          this.status = \\\"rejected\\\";\\n          reject(reason);\\n        }\\n      };\\n    });\\n  }\\n};\\nfunction RouterProvider(_ref) {\\n  let {\\n    fallbackElement,\\n    router,\\n    future\\n  } = _ref;\\n  let [state, setStateImpl] = React2.useState(router.state);\\n  let [pendingState, setPendingState] = React2.useState();\\n  let [vtContext, setVtContext] = React2.useState({\\n    isTransitioning: false\\n  });\\n  let [renderDfd, setRenderDfd] = React2.useState();\\n  let [transition, setTransition] = React2.useState();\\n  let [interruption, setInterruption] = React2.useState();\\n  let fetcherData = React2.useRef(/* @__PURE__ */ new Map());\\n  let {\\n    v7_startTransition\\n  } = future || {};\\n  let optInStartTransition = React2.useCallback((cb) => {\\n    if (v7_startTransition) {\\n      startTransitionSafe(cb);\\n    } else {\\n      cb();\\n    }\\n  }, [v7_startTransition]);\\n  let setState = React2.useCallback((newState, _ref2) => {\\n    let {\\n      deletedFetchers,\\n      unstable_flushSync: flushSync,\\n      unstable_viewTransitionOpts: viewTransitionOpts\\n    } = _ref2;\\n    deletedFetchers.forEach((key) => fetcherData.current.delete(key));\\n    newState.fetchers.forEach((fetcher, key) => {\\n      if (fetcher.data !== void 0) {\\n        fetcherData.current.set(key, fetcher.data);\\n      }\\n    });\\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \\\"function\\\";\\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\\n      if (flushSync) {\\n        flushSyncSafe(() => setStateImpl(newState));\\n      } else {\\n        optInStartTransition(() => setStateImpl(newState));\\n      }\\n      return;\\n    }\\n    if (flushSync) {\\n      flushSyncSafe(() => {\\n        if (transition) {\\n          renderDfd && renderDfd.resolve();\\n          transition.skipTransition();\\n        }\\n        setVtContext({\\n          isTransitioning: true,\\n          flushSync: true,\\n          currentLocation: viewTransitionOpts.currentLocation,\\n          nextLocation: viewTransitionOpts.nextLocation\\n        });\\n      });\\n      let t = router.window.document.startViewTransition(() => {\\n        flushSyncSafe(() => setStateImpl(newState));\\n      });\\n      t.finished.finally(() => {\\n        flushSyncSafe(() => {\\n          setRenderDfd(void 0);\\n          setTransition(void 0);\\n          setPendingState(void 0);\\n          setVtContext({\\n            isTransitioning: false\\n          });\\n        });\\n      });\\n      flushSyncSafe(() => setTransition(t));\\n      return;\\n    }\\n    if (transition) {\\n      renderDfd && renderDfd.resolve();\\n      transition.skipTransition();\\n      setInterruption({\\n        state: newState,\\n        currentLocation: viewTransitionOpts.currentLocation,\\n        nextLocation: viewTransitionOpts.nextLocation\\n      });\\n    } else {\\n      setPendingState(newState);\\n      setVtContext({\\n        isTransitioning: true,\\n        flushSync: false,\\n        currentLocation: viewTransitionOpts.currentLocation,\\n        nextLocation: viewTransitionOpts.nextLocation\\n      });\\n    }\\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\\n  React2.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\\n  React2.useEffect(() => {\\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\\n      setRenderDfd(new Deferred());\\n    }\\n  }, [vtContext]);\\n  React2.useEffect(() => {\\n    if (renderDfd && pendingState && router.window) {\\n      let newState = pendingState;\\n      let renderPromise = renderDfd.promise;\\n      let transition2 = router.window.document.startViewTransition(async () => {\\n        optInStartTransition(() => setStateImpl(newState));\\n        await renderPromise;\\n      });\\n      transition2.finished.finally(() => {\\n        setRenderDfd(void 0);\\n        setTransition(void 0);\\n        setPendingState(void 0);\\n        setVtContext({\\n          isTransitioning: false\\n        });\\n      });\\n      setTransition(transition2);\\n    }\\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\\n  React2.useEffect(() => {\\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\\n      renderDfd.resolve();\\n    }\\n  }, [renderDfd, transition, state.location, pendingState]);\\n  React2.useEffect(() => {\\n    if (!vtContext.isTransitioning && interruption) {\\n      setPendingState(interruption.state);\\n      setVtContext({\\n        isTransitioning: true,\\n        flushSync: false,\\n        currentLocation: interruption.currentLocation,\\n        nextLocation: interruption.nextLocation\\n      });\\n      setInterruption(void 0);\\n    }\\n  }, [vtContext.isTransitioning, interruption]);\\n  React2.useEffect(() => {\\n    process.env.NODE_ENV !== \\\"production\\\" ? warning(fallbackElement == null || !router.future.v7_partialHydration, \\\"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead\\\") : void 0;\\n  }, []);\\n  let navigator = React2.useMemo(() => {\\n    return {\\n      createHref: router.createHref,\\n      encodeLocation: router.encodeLocation,\\n      go: (n) => router.navigate(n),\\n      push: (to, state2, opts) => router.navigate(to, {\\n        state: state2,\\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\\n      }),\\n      replace: (to, state2, opts) => router.navigate(to, {\\n        replace: true,\\n        state: state2,\\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\\n      })\\n    };\\n  }, [router]);\\n  let basename = router.basename || \\\"/\\\";\\n  let dataRouterContext = React2.useMemo(() => ({\\n    router,\\n    navigator,\\n    static: false,\\n    basename\\n  }), [router, navigator, basename]);\\n  return React2.createElement(React2.Fragment, null, React2.createElement(DataRouterContext.Provider, {\\n    value: dataRouterContext\\n  }, React2.createElement(DataRouterStateContext.Provider, {\\n    value: state\\n  }, React2.createElement(FetchersContext.Provider, {\\n    value: fetcherData.current\\n  }, React2.createElement(ViewTransitionContext.Provider, {\\n    value: vtContext\\n  }, React2.createElement(Router, {\\n    basename,\\n    location: state.location,\\n    navigationType: state.historyAction,\\n    navigator,\\n    future: {\\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\\n    }\\n  }, state.initialized || router.future.v7_partialHydration ? React2.createElement(DataRoutes, {\\n    routes: router.routes,\\n    future: router.future,\\n    state\\n  }) : fallbackElement))))), null);\\n}\\nfunction DataRoutes(_ref3) {\\n  let {\\n    routes,\\n    future,\\n    state\\n  } = _ref3;\\n  return useRoutesImpl(routes, void 0, state, future);\\n}\\nfunction BrowserRouter(_ref4) {\\n  let {\\n    basename,\\n    children,\\n    future,\\n    window: window2\\n  } = _ref4;\\n  let historyRef = React2.useRef();\\n  if (historyRef.current == null) {\\n    historyRef.current = createBrowserHistory({\\n      window: window2,\\n      v5Compat: true\\n    });\\n  }\\n  let history = historyRef.current;\\n  let [state, setStateImpl] = React2.useState({\\n    action: history.action,\\n    location: history.location\\n  });\\n  let {\\n    v7_startTransition\\n  } = future || {};\\n  let setState = React2.useCallback((newState) => {\\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\\n  }, [setStateImpl, v7_startTransition]);\\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\\n  return React2.createElement(Router, {\\n    basename,\\n    children,\\n    location: state.location,\\n    navigationType: state.action,\\n    navigator: history,\\n    future\\n  });\\n}\\nfunction HashRouter(_ref5) {\\n  let {\\n    basename,\\n    children,\\n    future,\\n    window: window2\\n  } = _ref5;\\n  let historyRef = React2.useRef();\\n  if (historyRef.current == null) {\\n    historyRef.current = createHashHistory({\\n      window: window2,\\n      v5Compat: true\\n    });\\n  }\\n  let history = historyRef.current;\\n  let [state, setStateImpl] = React2.useState({\\n    action: history.action,\\n    location: history.location\\n  });\\n  let {\\n    v7_startTransition\\n  } = future || {};\\n  let setState = React2.useCallback((newState) => {\\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\\n  }, [setStateImpl, v7_startTransition]);\\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\\n  return React2.createElement(Router, {\\n    basename,\\n    children,\\n    location: state.location,\\n    navigationType: state.action,\\n    navigator: history,\\n    future\\n  });\\n}\\nfunction HistoryRouter(_ref6) {\\n  let {\\n    basename,\\n    children,\\n    future,\\n    history\\n  } = _ref6;\\n  let [state, setStateImpl] = React2.useState({\\n    action: history.action,\\n    location: history.location\\n  });\\n  let {\\n    v7_startTransition\\n  } = future || {};\\n  let setState = React2.useCallback((newState) => {\\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\\n  }, [setStateImpl, v7_startTransition]);\\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\\n  return React2.createElement(Router, {\\n    basename,\\n    children,\\n    location: state.location,\\n    navigationType: state.action,\\n    navigator: history,\\n    future\\n  });\\n}\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  HistoryRouter.displayName = \\\"unstable_HistoryRouter\\\";\\n}\\nvar isBrowser = typeof window !== \\\"undefined\\\" && typeof window.document !== \\\"undefined\\\" && typeof window.document.createElement !== \\\"undefined\\\";\\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\\\/\\\\/)/i;\\nvar Link = React2.forwardRef(function LinkWithRef(_ref7, ref) {\\n  let {\\n    onClick,\\n    relative,\\n    reloadDocument,\\n    replace,\\n    state,\\n    target,\\n    to,\\n    preventScrollReset,\\n    unstable_viewTransition\\n  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\\n  let {\\n    basename\\n  } = React2.useContext(NavigationContext);\\n  let absoluteHref;\\n  let isExternal = false;\\n  if (typeof to === \\\"string\\\" && ABSOLUTE_URL_REGEX2.test(to)) {\\n    absoluteHref = to;\\n    if (isBrowser) {\\n      try {\\n        let currentUrl = new URL(window.location.href);\\n        let targetUrl = to.startsWith(\\\"//\\\") ? new URL(currentUrl.protocol + to) : new URL(to);\\n        let path = stripBasename(targetUrl.pathname, basename);\\n        if (targetUrl.origin === currentUrl.origin && path != null) {\\n          to = path + targetUrl.search + targetUrl.hash;\\n        } else {\\n          isExternal = true;\\n        }\\n      } catch (e) {\\n        process.env.NODE_ENV !== \\\"production\\\" ? warning(false, '<Link to=\\\"' + to + '\\\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;\\n      }\\n    }\\n  }\\n  let href = useHref(to, {\\n    relative\\n  });\\n  let internalOnClick = useLinkClickHandler(to, {\\n    replace,\\n    state,\\n    target,\\n    preventScrollReset,\\n    relative,\\n    unstable_viewTransition\\n  });\\n  function handleClick(event) {\\n    if (onClick)\\n      onClick(event);\\n    if (!event.defaultPrevented) {\\n      internalOnClick(event);\\n    }\\n  }\\n  return (\\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\\n    React2.createElement(\\\"a\\\", _extends3({}, rest, {\\n      href: absoluteHref || href,\\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\\n      ref,\\n      target\\n    }))\\n  );\\n});\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  Link.displayName = \\\"Link\\\";\\n}\\nvar NavLink = React2.forwardRef(function NavLinkWithRef(_ref8, ref) {\\n  let {\\n    \\\"aria-current\\\": ariaCurrentProp = \\\"page\\\",\\n    caseSensitive = false,\\n    className: classNameProp = \\\"\\\",\\n    end = false,\\n    style: styleProp,\\n    to,\\n    unstable_viewTransition,\\n    children\\n  } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\\n  let path = useResolvedPath(to, {\\n    relative: rest.relative\\n  });\\n  let location = useLocation();\\n  let routerState = React2.useContext(DataRouterStateContext);\\n  let {\\n    navigator\\n  } = React2.useContext(NavigationContext);\\n  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  useViewTransitionState(path) && unstable_viewTransition === true;\\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\\n  let locationPathname = location.pathname;\\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\\n  if (!caseSensitive) {\\n    locationPathname = locationPathname.toLowerCase();\\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\\n    toPathname = toPathname.toLowerCase();\\n  }\\n  const endSlashPosition = toPathname !== \\\"/\\\" && toPathname.endsWith(\\\"/\\\") ? toPathname.length - 1 : toPathname.length;\\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \\\"/\\\";\\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \\\"/\\\");\\n  let renderProps = {\\n    isActive,\\n    isPending,\\n    isTransitioning\\n  };\\n  let ariaCurrent = isActive ? ariaCurrentProp : void 0;\\n  let className;\\n  if (typeof classNameProp === \\\"function\\\") {\\n    className = classNameProp(renderProps);\\n  } else {\\n    className = [classNameProp, isActive ? \\\"active\\\" : null, isPending ? \\\"pending\\\" : null, isTransitioning ? \\\"transitioning\\\" : null].filter(Boolean).join(\\\" \\\");\\n  }\\n  let style = typeof styleProp === \\\"function\\\" ? styleProp(renderProps) : styleProp;\\n  return React2.createElement(Link, _extends3({}, rest, {\\n    \\\"aria-current\\\": ariaCurrent,\\n    className,\\n    ref,\\n    style,\\n    to,\\n    unstable_viewTransition\\n  }), typeof children === \\\"function\\\" ? children(renderProps) : children);\\n});\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  NavLink.displayName = \\\"NavLink\\\";\\n}\\nvar Form = React2.forwardRef((_ref9, forwardedRef) => {\\n  let {\\n    fetcherKey,\\n    navigate,\\n    reloadDocument,\\n    replace,\\n    state,\\n    method = defaultMethod,\\n    action,\\n    onSubmit,\\n    relative,\\n    preventScrollReset,\\n    unstable_viewTransition\\n  } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\\n  let submit = useSubmit();\\n  let formAction = useFormAction(action, {\\n    relative\\n  });\\n  let formMethod = method.toLowerCase() === \\\"get\\\" ? \\\"get\\\" : \\\"post\\\";\\n  let submitHandler = (event) => {\\n    onSubmit && onSubmit(event);\\n    if (event.defaultPrevented)\\n      return;\\n    event.preventDefault();\\n    let submitter = event.nativeEvent.submitter;\\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\\\"formmethod\\\")) || method;\\n    submit(submitter || event.currentTarget, {\\n      fetcherKey,\\n      method: submitMethod,\\n      navigate,\\n      replace,\\n      state,\\n      relative,\\n      preventScrollReset,\\n      unstable_viewTransition\\n    });\\n  };\\n  return React2.createElement(\\\"form\\\", _extends3({\\n    ref: forwardedRef,\\n    method: formMethod,\\n    action: formAction,\\n    onSubmit: reloadDocument ? onSubmit : submitHandler\\n  }, props));\\n});\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  Form.displayName = \\\"Form\\\";\\n}\\nfunction ScrollRestoration(_ref10) {\\n  let {\\n    getKey,\\n    storageKey\\n  } = _ref10;\\n  useScrollRestoration({\\n    getKey,\\n    storageKey\\n  });\\n  return null;\\n}\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  ScrollRestoration.displayName = \\\"ScrollRestoration\\\";\\n}\\nvar DataRouterHook2;\\n(function(DataRouterHook3) {\\n  DataRouterHook3[\\\"UseScrollRestoration\\\"] = \\\"useScrollRestoration\\\";\\n  DataRouterHook3[\\\"UseSubmit\\\"] = \\\"useSubmit\\\";\\n  DataRouterHook3[\\\"UseSubmitFetcher\\\"] = \\\"useSubmitFetcher\\\";\\n  DataRouterHook3[\\\"UseFetcher\\\"] = \\\"useFetcher\\\";\\n  DataRouterHook3[\\\"useViewTransitionState\\\"] = \\\"useViewTransitionState\\\";\\n})(DataRouterHook2 || (DataRouterHook2 = {}));\\nvar DataRouterStateHook2;\\n(function(DataRouterStateHook3) {\\n  DataRouterStateHook3[\\\"UseFetcher\\\"] = \\\"useFetcher\\\";\\n  DataRouterStateHook3[\\\"UseFetchers\\\"] = \\\"useFetchers\\\";\\n  DataRouterStateHook3[\\\"UseScrollRestoration\\\"] = \\\"useScrollRestoration\\\";\\n})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));\\nfunction getDataRouterConsoleError2(hookName) {\\n  return hookName + \\\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\\\";\\n}\\nfunction useDataRouterContext2(hookName) {\\n  let ctx = React2.useContext(DataRouterContext);\\n  !ctx ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\\n  return ctx;\\n}\\nfunction useDataRouterState2(hookName) {\\n  let state = React2.useContext(DataRouterStateContext);\\n  !state ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\\n  return state;\\n}\\nfunction useLinkClickHandler(to, _temp) {\\n  let {\\n    target,\\n    replace: replaceProp,\\n    state,\\n    preventScrollReset,\\n    relative,\\n    unstable_viewTransition\\n  } = _temp === void 0 ? {} : _temp;\\n  let navigate = useNavigate();\\n  let location = useLocation();\\n  let path = useResolvedPath(to, {\\n    relative\\n  });\\n  return React2.useCallback((event) => {\\n    if (shouldProcessLinkClick(event, target)) {\\n      event.preventDefault();\\n      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\\n      navigate(to, {\\n        replace,\\n        state,\\n        preventScrollReset,\\n        relative,\\n        unstable_viewTransition\\n      });\\n    }\\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\\n}\\nfunction useSearchParams(defaultInit) {\\n  process.env.NODE_ENV !== \\\"production\\\" ? warning(typeof URLSearchParams !== \\\"undefined\\\", \\\"You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\\\\n\\\\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.\\\") : void 0;\\n  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit));\\n  let hasSetSearchParamsRef = React2.useRef(false);\\n  let location = useLocation();\\n  let searchParams = React2.useMemo(() => (\\n    // Only merge in the defaults if we haven't yet called setSearchParams.\\n    // Once we call that we want those to take precedence, otherwise you can't\\n    // remove a param with setSearchParams({}) if it has an initial value\\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)\\n  ), [location.search]);\\n  let navigate = useNavigate();\\n  let setSearchParams = React2.useCallback((nextInit, navigateOptions) => {\\n    const newSearchParams = createSearchParams(typeof nextInit === \\\"function\\\" ? nextInit(searchParams) : nextInit);\\n    hasSetSearchParamsRef.current = true;\\n    navigate(\\\"?\\\" + newSearchParams, navigateOptions);\\n  }, [navigate, searchParams]);\\n  return [searchParams, setSearchParams];\\n}\\nfunction validateClientSideSubmission() {\\n  if (typeof document === \\\"undefined\\\") {\\n    throw new Error(\\\"You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.\\\");\\n  }\\n}\\nvar fetcherId = 0;\\nvar getUniqueFetcherId = () => \\\"__\\\" + String(++fetcherId) + \\\"__\\\";\\nfunction useSubmit() {\\n  let {\\n    router\\n  } = useDataRouterContext2(DataRouterHook2.UseSubmit);\\n  let {\\n    basename\\n  } = React2.useContext(NavigationContext);\\n  let currentRouteId = useRouteId();\\n  return React2.useCallback(function(target, options) {\\n    if (options === void 0) {\\n      options = {};\\n    }\\n    validateClientSideSubmission();\\n    let {\\n      action,\\n      method,\\n      encType,\\n      formData,\\n      body\\n    } = getFormSubmissionInfo(target, basename);\\n    if (options.navigate === false) {\\n      let key = options.fetcherKey || getUniqueFetcherId();\\n      router.fetch(key, currentRouteId, options.action || action, {\\n        preventScrollReset: options.preventScrollReset,\\n        formData,\\n        body,\\n        formMethod: options.method || method,\\n        formEncType: options.encType || encType,\\n        unstable_flushSync: options.unstable_flushSync\\n      });\\n    } else {\\n      router.navigate(options.action || action, {\\n        preventScrollReset: options.preventScrollReset,\\n        formData,\\n        body,\\n        formMethod: options.method || method,\\n        formEncType: options.encType || encType,\\n        replace: options.replace,\\n        state: options.state,\\n        fromRouteId: currentRouteId,\\n        unstable_flushSync: options.unstable_flushSync,\\n        unstable_viewTransition: options.unstable_viewTransition\\n      });\\n    }\\n  }, [router, basename, currentRouteId]);\\n}\\nfunction useFormAction(action, _temp2) {\\n  let {\\n    relative\\n  } = _temp2 === void 0 ? {} : _temp2;\\n  let {\\n    basename\\n  } = React2.useContext(NavigationContext);\\n  let routeContext = React2.useContext(RouteContext);\\n  !routeContext ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"useFormAction must be used inside a RouteContext\\\") : invariant(false) : void 0;\\n  let [match] = routeContext.matches.slice(-1);\\n  let path = _extends3({}, useResolvedPath(action ? action : \\\".\\\", {\\n    relative\\n  }));\\n  let location = useLocation();\\n  if (action == null) {\\n    path.search = location.search;\\n    let params = new URLSearchParams(path.search);\\n    if (params.has(\\\"index\\\") && params.get(\\\"index\\\") === \\\"\\\") {\\n      params.delete(\\\"index\\\");\\n      path.search = params.toString() ? \\\"?\\\" + params.toString() : \\\"\\\";\\n    }\\n  }\\n  if ((!action || action === \\\".\\\") && match.route.index) {\\n    path.search = path.search ? path.search.replace(/^\\\\?/, \\\"?index&\\\") : \\\"?index\\\";\\n  }\\n  if (basename !== \\\"/\\\") {\\n    path.pathname = path.pathname === \\\"/\\\" ? basename : joinPaths([basename, path.pathname]);\\n  }\\n  return createPath(path);\\n}\\nfunction useFetcher(_temp3) {\\n  var _route$matches;\\n  let {\\n    key\\n  } = _temp3 === void 0 ? {} : _temp3;\\n  let {\\n    router\\n  } = useDataRouterContext2(DataRouterHook2.UseFetcher);\\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetcher);\\n  let fetcherData = React2.useContext(FetchersContext);\\n  let route = React2.useContext(RouteContext);\\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\\n  !fetcherData ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"useFetcher must be used inside a FetchersContext\\\") : invariant(false) : void 0;\\n  !route ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"useFetcher must be used inside a RouteContext\\\") : invariant(false) : void 0;\\n  !(routeId != null) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, 'useFetcher can only be used on routes that contain a unique \\\"id\\\"') : invariant(false) : void 0;\\n  let [fetcherKey, setFetcherKey] = React2.useState(key || \\\"\\\");\\n  if (key && key !== fetcherKey) {\\n    setFetcherKey(key);\\n  } else if (!fetcherKey) {\\n    setFetcherKey(getUniqueFetcherId());\\n  }\\n  React2.useEffect(() => {\\n    router.getFetcher(fetcherKey);\\n    return () => {\\n      router.deleteFetcher(fetcherKey);\\n    };\\n  }, [router, fetcherKey]);\\n  let load = React2.useCallback((href, opts) => {\\n    !routeId ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"No routeId available for fetcher.load()\\\") : invariant(false) : void 0;\\n    router.fetch(fetcherKey, routeId, href, opts);\\n  }, [fetcherKey, routeId, router]);\\n  let submitImpl = useSubmit();\\n  let submit = React2.useCallback((target, opts) => {\\n    submitImpl(target, _extends3({}, opts, {\\n      navigate: false,\\n      fetcherKey\\n    }));\\n  }, [fetcherKey, submitImpl]);\\n  let FetcherForm = React2.useMemo(() => {\\n    let FetcherForm2 = React2.forwardRef((props, ref) => {\\n      return React2.createElement(Form, _extends3({}, props, {\\n        navigate: false,\\n        fetcherKey,\\n        ref\\n      }));\\n    });\\n    if (process.env.NODE_ENV !== \\\"production\\\") {\\n      FetcherForm2.displayName = \\\"fetcher.Form\\\";\\n    }\\n    return FetcherForm2;\\n  }, [fetcherKey]);\\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\\n  let data = fetcherData.get(fetcherKey);\\n  let fetcherWithComponents = React2.useMemo(() => _extends3({\\n    Form: FetcherForm,\\n    submit,\\n    load\\n  }, fetcher, {\\n    data\\n  }), [FetcherForm, submit, load, fetcher, data]);\\n  return fetcherWithComponents;\\n}\\nfunction useFetchers() {\\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetchers);\\n  return Array.from(state.fetchers.entries()).map((_ref11) => {\\n    let [key, fetcher] = _ref11;\\n    return _extends3({}, fetcher, {\\n      key\\n    });\\n  });\\n}\\nvar SCROLL_RESTORATION_STORAGE_KEY = \\\"react-router-scroll-positions\\\";\\nvar savedScrollPositions = {};\\nfunction useScrollRestoration(_temp4) {\\n  let {\\n    getKey,\\n    storageKey\\n  } = _temp4 === void 0 ? {} : _temp4;\\n  let {\\n    router\\n  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);\\n  let {\\n    restoreScrollPosition,\\n    preventScrollReset\\n  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);\\n  let {\\n    basename\\n  } = React2.useContext(NavigationContext);\\n  let location = useLocation();\\n  let matches = useMatches();\\n  let navigation = useNavigation();\\n  React2.useEffect(() => {\\n    window.history.scrollRestoration = \\\"manual\\\";\\n    return () => {\\n      window.history.scrollRestoration = \\\"auto\\\";\\n    };\\n  }, []);\\n  usePageHide(React2.useCallback(() => {\\n    if (navigation.state === \\\"idle\\\") {\\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\\n      savedScrollPositions[key] = window.scrollY;\\n    }\\n    try {\\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\\n    } catch (error) {\\n      process.env.NODE_ENV !== \\\"production\\\" ? warning(false, \\\"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\\\" + error + \\\").\\\") : void 0;\\n    }\\n    window.history.scrollRestoration = \\\"auto\\\";\\n  }, [storageKey, getKey, navigation.state, location, matches]));\\n  if (typeof document !== \\\"undefined\\\") {\\n    React2.useLayoutEffect(() => {\\n      try {\\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\\n        if (sessionPositions) {\\n          savedScrollPositions = JSON.parse(sessionPositions);\\n        }\\n      } catch (e) {\\n      }\\n    }, [storageKey]);\\n    React2.useLayoutEffect(() => {\\n      let getKeyWithoutBasename = getKey && basename !== \\\"/\\\" ? (location2, matches2) => getKey(\\n        // Strip the basename to match useLocation()\\n        _extends3({}, location2, {\\n          pathname: stripBasename(location2.pathname, basename) || location2.pathname\\n        }),\\n        matches2\\n      ) : getKey;\\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\\n      return () => disableScrollRestoration && disableScrollRestoration();\\n    }, [router, basename, getKey]);\\n    React2.useLayoutEffect(() => {\\n      if (restoreScrollPosition === false) {\\n        return;\\n      }\\n      if (typeof restoreScrollPosition === \\\"number\\\") {\\n        window.scrollTo(0, restoreScrollPosition);\\n        return;\\n      }\\n      if (location.hash) {\\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\\n        if (el) {\\n          el.scrollIntoView();\\n          return;\\n        }\\n      }\\n      if (preventScrollReset === true) {\\n        return;\\n      }\\n      window.scrollTo(0, 0);\\n    }, [location, restoreScrollPosition, preventScrollReset]);\\n  }\\n}\\nfunction useBeforeUnload(callback, options) {\\n  let {\\n    capture\\n  } = options || {};\\n  React2.useEffect(() => {\\n    let opts = capture != null ? {\\n      capture\\n    } : void 0;\\n    window.addEventListener(\\\"beforeunload\\\", callback, opts);\\n    return () => {\\n      window.removeEventListener(\\\"beforeunload\\\", callback, opts);\\n    };\\n  }, [callback, capture]);\\n}\\nfunction usePageHide(callback, options) {\\n  let {\\n    capture\\n  } = options || {};\\n  React2.useEffect(() => {\\n    let opts = capture != null ? {\\n      capture\\n    } : void 0;\\n    window.addEventListener(\\\"pagehide\\\", callback, opts);\\n    return () => {\\n      window.removeEventListener(\\\"pagehide\\\", callback, opts);\\n    };\\n  }, [callback, capture]);\\n}\\nfunction usePrompt(_ref12) {\\n  let {\\n    when,\\n    message\\n  } = _ref12;\\n  let blocker = useBlocker(when);\\n  React2.useEffect(() => {\\n    if (blocker.state === \\\"blocked\\\") {\\n      let proceed = window.confirm(message);\\n      if (proceed) {\\n        setTimeout(blocker.proceed, 0);\\n      } else {\\n        blocker.reset();\\n      }\\n    }\\n  }, [blocker, message]);\\n  React2.useEffect(() => {\\n    if (blocker.state === \\\"blocked\\\" && !when) {\\n      blocker.reset();\\n    }\\n  }, [blocker, when]);\\n}\\nfunction useViewTransitionState(to, opts) {\\n  if (opts === void 0) {\\n    opts = {};\\n  }\\n  let vtContext = React2.useContext(ViewTransitionContext);\\n  !(vtContext != null) ? process.env.NODE_ENV !== \\\"production\\\" ? invariant(false, \\\"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\\\") : invariant(false) : void 0;\\n  let {\\n    basename\\n  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);\\n  let path = useResolvedPath(to, {\\n    relative: opts.relative\\n  });\\n  if (!vtContext.isTransitioning) {\\n    return false;\\n  }\\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\\n}\\nexport {\\n  AbortedDeferredError,\\n  Await,\\n  BrowserRouter,\\n  Form,\\n  HashRouter,\\n  Link,\\n  MemoryRouter,\\n  NavLink,\\n  Navigate,\\n  Action as NavigationType,\\n  Outlet,\\n  Route,\\n  Router,\\n  RouterProvider,\\n  Routes,\\n  ScrollRestoration,\\n  DataRouterContext as UNSAFE_DataRouterContext,\\n  DataRouterStateContext as UNSAFE_DataRouterStateContext,\\n  FetchersContext as UNSAFE_FetchersContext,\\n  LocationContext as UNSAFE_LocationContext,\\n  NavigationContext as UNSAFE_NavigationContext,\\n  RouteContext as UNSAFE_RouteContext,\\n  ViewTransitionContext as UNSAFE_ViewTransitionContext,\\n  useRouteId as UNSAFE_useRouteId,\\n  useScrollRestoration as UNSAFE_useScrollRestoration,\\n  createBrowserRouter,\\n  createHashRouter,\\n  createMemoryRouter,\\n  createPath,\\n  createRoutesFromChildren,\\n  createRoutesFromChildren as createRoutesFromElements,\\n  createSearchParams,\\n  defer,\\n  generatePath,\\n  isRouteErrorResponse,\\n  json,\\n  matchPath,\\n  matchRoutes,\\n  parsePath,\\n  redirect,\\n  redirectDocument,\\n  renderMatches,\\n  resolvePath,\\n  HistoryRouter as unstable_HistoryRouter,\\n  usePrompt as unstable_usePrompt,\\n  useViewTransitionState as unstable_useViewTransitionState,\\n  useActionData,\\n  useAsyncError,\\n  useAsyncValue,\\n  useBeforeUnload,\\n  useBlocker,\\n  useFetcher,\\n  useFetchers,\\n  useFormAction,\\n  useHref,\\n  useInRouterContext,\\n  useLinkClickHandler,\\n  useLoaderData,\\n  useLocation,\\n  useMatch,\\n  useMatches,\\n  useNavigate,\\n  useNavigation,\\n  useNavigationType,\\n  useOutlet,\\n  useOutletContext,\\n  useParams,\\n  useResolvedPath,\\n  useRevalidator,\\n  useRouteError,\\n  useRouteLoaderData,\\n  useRoutes,\\n  useSearchParams,\\n  useSubmit\\n};\\n/*! Bundled license information:\\n\\n@remix-run/router/dist/router.js:\\n  (**\\n   * @remix-run/router v1.14.0\\n   *\\n   * Copyright (c) Remix Software Inc.\\n   *\\n   * This source code is licensed under the MIT license found in the\\n   * LICENSE.md file in the root directory of this source tree.\\n   *\\n   * @license MIT\\n   *)\\n\\nreact-router/dist/index.js:\\n  (**\\n   * React Router v6.21.0\\n   *\\n   * Copyright (c) Remix Software Inc.\\n   *\\n   * This source code is licensed under the MIT license found in the\\n   * LICENSE.md file in the root directory of this source tree.\\n   *\\n   * @license MIT\\n   *)\\n\\nreact-router-dom/dist/index.js:\\n  (**\\n   * React Router DOM v6.21.0\\n   *\\n   * Copyright (c) Remix Software Inc.\\n   *\\n   * This source code is licensed under the MIT license found in the\\n   * LICENSE.md file in the root directory of this source tree.\\n   *\\n   * @license MIT\\n   *)\\n*/\\n//# sourceMappingURL=react-router-dom.js.map\\n\"],\n  \"mappings\": \"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\",\n  \"names\": [\"__toESM\", \"process\"]\n}\n"
    },
    {
      "name": "vite:import-analysis",
      "result": "\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var require_base64_js = __commonJS({\n    \"node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n      var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      for (i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n      var i;\n      var len;\n      revLookup[\"-\".charCodeAt(0)] = 62;\n      revLookup[\"_\".charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len2 = b64.length;\n        if (len2 % 4 > 0) {\n          throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        }\n        var validLen = b64.indexOf(\"=\");\n        if (validLen === -1)\n          validLen = len2;\n        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i2;\n        for (i2 = 0; i2 < len2; i2 += 4) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n          arr[curByte++] = tmp >> 16 & 255;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n          arr[curByte++] = tmp & 255;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 255;\n          arr[curByte++] = tmp & 255;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i2 = start; i2 < end; i2 += 3) {\n          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join(\"\");\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len2 = uint8.length;\n        var extraBytes = len2 % 3;\n        var parts = [];\n        var maxChunkLength = 16383;\n        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n        }\n        if (extraBytes === 1) {\n          tmp = uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n          );\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n          parts.push(\n            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n          );\n        }\n        return parts.join(\"\");\n      }\n    }\n  });\n  var require_ieee754 = __commonJS({\n    \"node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\"(exports) {\n      init_dist();\n      exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s2 = buffer[offset + i];\n        i += d;\n        e = s2 & (1 << -nBits) - 1;\n        s2 >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n        }\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s2 ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n        }\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n        }\n        buffer[offset + i - d] |= s2 * 128;\n      };\n    }\n  });\n  var require_buffer = __commonJS({\n    \"node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js\"(exports) {\n      \"use strict\";\n      init_dist();\n      var base64 = require_base64_js();\n      var ieee754 = require_ieee754();\n      var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n      exports.Buffer = Buffer2;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      var K_MAX_LENGTH = 2147483647;\n      exports.kMaxLength = K_MAX_LENGTH;\n      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\n          \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n        );\n      }\n      function typedArraySupport() {\n        try {\n          const arr = new GlobalUint8Array(1);\n          const proto = { foo: function() {\n            return 42;\n          } };\n          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n          Object.setPrototypeOf(arr, proto);\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n      Object.defineProperty(Buffer2.prototype, \"parent\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.buffer;\n        }\n      });\n      Object.defineProperty(Buffer2.prototype, \"offset\", {\n        enumerable: true,\n        get: function() {\n          if (!Buffer2.isBuffer(this))\n            return void 0;\n          return this.byteOffset;\n        }\n      });\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        const buf = new GlobalUint8Array(length);\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function Buffer2(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          if (typeof encodingOrOffset === \"string\") {\n            throw new TypeError(\n              'The \"string\" argument must be of type string. Received type number'\n            );\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n      Buffer2.poolSize = 8192;\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === \"string\") {\n          return fromString(value, encodingOrOffset);\n        }\n        if (GlobalArrayBuffer.isView(value)) {\n          return fromArrayView(value);\n        }\n        if (value == null) {\n          throw new TypeError(\n            \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n          );\n        }\n        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof GlobalSharedArrayBuffer !== \"undefined\" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === \"number\") {\n          throw new TypeError(\n            'The \"value\" argument must not be of type number. Received type number'\n          );\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer2.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n          return b;\n        if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n          return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n        }\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      Buffer2.from = function(value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);\n      Object.setPrototypeOf(Buffer2, GlobalUint8Array);\n      function assertSize(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== void 0) {\n          return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n      Buffer2.alloc = function(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n      Buffer2.allocUnsafe = function(size) {\n        return allocUnsafe(size);\n      };\n      Buffer2.allocUnsafeSlow = function(size) {\n        return allocUnsafe(size);\n      };\n      function fromString(string, encoding) {\n        if (typeof encoding !== \"string\" || encoding === \"\") {\n          encoding = \"utf8\";\n        }\n        if (!Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        const length = byteLength(string, encoding) | 0;\n        let buf = createBuffer(length);\n        const actual = buf.write(string, encoding);\n        if (actual !== length) {\n          buf = buf.slice(0, actual);\n        }\n        return buf;\n      }\n      function fromArrayLike(array) {\n        const length = array.length < 0 ? 0 : checked(array.length) | 0;\n        const buf = createBuffer(length);\n        for (let i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n      function fromArrayView(arrayView) {\n        if (isInstance(arrayView, GlobalUint8Array)) {\n          const copy = new GlobalUint8Array(arrayView);\n          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n        }\n        return fromArrayLike(arrayView);\n      }\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n        let buf;\n        if (byteOffset === void 0 && length === void 0) {\n          buf = new GlobalUint8Array(array);\n        } else if (length === void 0) {\n          buf = new GlobalUint8Array(array, byteOffset);\n        } else {\n          buf = new GlobalUint8Array(array, byteOffset, length);\n        }\n        Object.setPrototypeOf(buf, Buffer2.prototype);\n        return buf;\n      }\n      function fromObject(obj) {\n        if (Buffer2.isBuffer(obj)) {\n          const len = checked(obj.length) | 0;\n          const buf = createBuffer(len);\n          if (buf.length === 0) {\n            return buf;\n          }\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n        if (obj.length !== void 0) {\n          if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n        if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n      function checked(length) {\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n        }\n        return length | 0;\n      }\n      function SlowBuffer(length) {\n        if (+length != length) {\n          length = 0;\n        }\n        return Buffer2.alloc(+length);\n      }\n      Buffer2.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n      };\n      Buffer2.compare = function compare(a, b) {\n        if (isInstance(a, GlobalUint8Array))\n          a = Buffer2.from(a, a.offset, a.byteLength);\n        if (isInstance(b, GlobalUint8Array))\n          b = Buffer2.from(b, b.offset, b.byteLength);\n        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n          throw new TypeError(\n            'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n          );\n        }\n        if (a === b)\n          return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      Buffer2.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return true;\n          default:\n            return false;\n        }\n      };\n      Buffer2.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n          return Buffer2.alloc(0);\n        }\n        let i;\n        if (length === void 0) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n        const buffer = Buffer2.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          let buf = list[i];\n          if (isInstance(buf, GlobalUint8Array)) {\n            if (pos + buf.length > buffer.length) {\n              if (!Buffer2.isBuffer(buf))\n                buf = Buffer2.from(buf);\n              buf.copy(buffer, pos);\n            } else {\n              GlobalUint8Array.prototype.set.call(\n                buffer,\n                buf,\n                pos\n              );\n            }\n          } else if (!Buffer2.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          } else {\n            buf.copy(buffer, pos);\n          }\n          pos += buf.length;\n        }\n        return buffer;\n      };\n      function byteLength(string, encoding) {\n        if (Buffer2.isBuffer(string)) {\n          return string.length;\n        }\n        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n          );\n        }\n        const len = string.length;\n        const mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0)\n          return 0;\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return len;\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return len * 2;\n            case \"hex\":\n              return len >>> 1;\n            case \"base64\":\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n              }\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.byteLength = byteLength;\n      function slowToString(encoding, start, end) {\n        let loweredCase = false;\n        if (start === void 0 || start < 0) {\n          start = 0;\n        }\n        if (start > this.length) {\n          return \"\";\n        }\n        if (end === void 0 || end > this.length) {\n          end = this.length;\n        }\n        if (end <= 0) {\n          return \"\";\n        }\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n          return \"\";\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        while (true) {\n          switch (encoding) {\n            case \"hex\":\n              return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Slice(this, start, end);\n            case \"ascii\":\n              return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n              return latin1Slice(this, start, end);\n            case \"base64\":\n              return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return utf16leSlice(this, start, end);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (encoding + \"\").toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n      Buffer2.prototype._isBuffer = true;\n      function swap(b, n, m) {\n        const i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n      Buffer2.prototype.swap16 = function swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n        }\n        for (let i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap32 = function swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n        }\n        for (let i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n      Buffer2.prototype.swap64 = function swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n        }\n        for (let i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n      Buffer2.prototype.toString = function toString() {\n        const length = this.length;\n        if (length === 0)\n          return \"\";\n        if (arguments.length === 0)\n          return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n      Buffer2.prototype.equals = function equals(b) {\n        if (!Buffer2.isBuffer(b))\n          throw new TypeError(\"Argument must be a Buffer\");\n        if (this === b)\n          return true;\n        return Buffer2.compare(this, b) === 0;\n      };\n      Buffer2.prototype.inspect = function inspect() {\n        let str = \"\";\n        const max = exports.INSPECT_MAX_BYTES;\n        str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n        if (this.length > max)\n          str += \" ... \";\n        return \"<Buffer \" + str + \">\";\n      };\n      if (customInspectSymbol) {\n        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n      }\n      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, GlobalUint8Array)) {\n          target = Buffer2.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer2.isBuffer(target)) {\n          throw new TypeError(\n            'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n          );\n        }\n        if (start === void 0) {\n          start = 0;\n        }\n        if (end === void 0) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === void 0) {\n          thisStart = 0;\n        }\n        if (thisEnd === void 0) {\n          thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError(\"out of range index\");\n        }\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n          return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n        if (x < y)\n          return -1;\n        if (y < x)\n          return 1;\n        return 0;\n      };\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        if (buffer.length === 0)\n          return -1;\n        if (typeof byteOffset === \"string\") {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 2147483647) {\n          byteOffset = 2147483647;\n        } else if (byteOffset < -2147483648) {\n          byteOffset = -2147483648;\n        }\n        byteOffset = +byteOffset;\n        if (numberIsNaN(byteOffset)) {\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n        if (byteOffset < 0)\n          byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir)\n            return -1;\n          else\n            byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir)\n            byteOffset = 0;\n          else\n            return -1;\n        }\n        if (typeof val === \"string\") {\n          val = Buffer2.from(val, encoding);\n        }\n        if (Buffer2.isBuffer(val)) {\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n          if (typeof GlobalUint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        let indexSize = 1;\n        let arrLength = arr.length;\n        let valLength = val.length;\n        if (encoding !== void 0) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n        function read(buf, i2) {\n          if (indexSize === 1) {\n            return buf[i2];\n          } else {\n            return buf.readUInt16BE(i2 * indexSize);\n          }\n        }\n        let i;\n        if (dir) {\n          let foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1)\n                foundIndex = i;\n              if (i - foundIndex + 1 === valLength)\n                return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1)\n                i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found)\n              return i;\n          }\n        }\n        return -1;\n      }\n      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        const remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n        const strLen = string.length;\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        let i;\n        for (i = 0; i < length; ++i) {\n          const parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed))\n            return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n      Buffer2.prototype.write = function write(string, offset, length, encoding) {\n        if (offset === void 0) {\n          encoding = \"utf8\";\n          length = this.length;\n          offset = 0;\n        } else if (length === void 0 && typeof offset === \"string\") {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === void 0)\n              encoding = \"utf8\";\n          } else {\n            encoding = length;\n            length = void 0;\n          }\n        } else {\n          throw new Error(\n            \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n          );\n        }\n        const remaining = this.length - offset;\n        if (length === void 0 || length > remaining)\n          length = remaining;\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError(\"Attempt to write outside buffer bounds\");\n        }\n        if (!encoding)\n          encoding = \"utf8\";\n        let loweredCase = false;\n        for (; ; ) {\n          switch (encoding) {\n            case \"hex\":\n              return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n              return utf8Write(this, string, offset, length);\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n              return asciiWrite(this, string, offset, length);\n            case \"base64\":\n              return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n              return ucs2Write(this, string, offset, length);\n            default:\n              if (loweredCase)\n                throw new TypeError(\"Unknown encoding: \" + encoding);\n              encoding = (\"\" + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n      Buffer2.prototype.toJSON = function toJSON() {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        const res = [];\n        let i = start;\n        while (i < end) {\n          const firstByte = buf[i];\n          let codePoint = null;\n          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n          if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                  if (tempCodePoint > 127) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n            }\n          }\n          if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n          } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n          }\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n        return decodeCodePointsArray(res);\n      }\n      var MAX_ARGUMENTS_LENGTH = 4096;\n      function decodeCodePointsArray(codePoints) {\n        const len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints);\n        }\n        let res = \"\";\n        let i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n          );\n        }\n        return res;\n      }\n      function asciiSlice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 127);\n        }\n        return ret;\n      }\n      function latin1Slice(buf, start, end) {\n        let ret = \"\";\n        end = Math.min(buf.length, end);\n        for (let i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n      function hexSlice(buf, start, end) {\n        const len = buf.length;\n        if (!start || start < 0)\n          start = 0;\n        if (!end || end < 0 || end > len)\n          end = len;\n        let out = \"\";\n        for (let i = start; i < end; ++i) {\n          out += hexSliceLookupTable[buf[i]];\n        }\n        return out;\n      }\n      function utf16leSlice(buf, start, end) {\n        const bytes = buf.slice(start, end);\n        let res = \"\";\n        for (let i = 0; i < bytes.length - 1; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n      Buffer2.prototype.slice = function slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === void 0 ? len : ~~end;\n        if (start < 0) {\n          start += len;\n          if (start < 0)\n            start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n        if (end < 0) {\n          end += len;\n          if (end < 0)\n            end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n        if (end < start)\n          end = start;\n        const newBuf = this.subarray(start, end);\n        Object.setPrototypeOf(newBuf, Buffer2.prototype);\n        return newBuf;\n      };\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0)\n          throw new RangeError(\"offset is not uint\");\n        if (offset + ext > length)\n          throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength2, this.length);\n        }\n        let val = this[offset + --byteLength2];\n        let mul = 1;\n        while (byteLength2 > 0 && (mul *= 256)) {\n          val += this[offset + --byteLength2] * mul;\n        }\n        return val;\n      };\n      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n      };\n      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n      });\n      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n      });\n      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength2 && (mul *= 256)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert)\n          checkOffset(offset, byteLength2, this.length);\n        let i = byteLength2;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 256)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 128;\n        if (val >= mul)\n          val -= Math.pow(2, 8 * byteLength2);\n        return val;\n      };\n      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 128))\n          return this[offset];\n        return (255 - this[offset] + 1) * -1;\n      };\n      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset] | this[offset + 1] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | this[offset] << 8;\n        return val & 32768 ? val | 4294901760 : val;\n      };\n      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n      });\n      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, \"offset\");\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === void 0 || last === void 0) {\n          boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n      });\n      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer2.isBuffer(buf))\n          throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min)\n          throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n      }\n      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength2 = byteLength2 >>> 0;\n        if (!noAssert) {\n          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n          checkInt(this, value, offset, byteLength2, maxBytes, 0);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          this[offset + i] = value / mul & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 255, 0);\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 65535, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 4294967295, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      function wrtBigUInt64LE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        lo = lo >> 8;\n        buf[offset++] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        hi = hi >> 8;\n        buf[offset++] = hi;\n        return offset;\n      }\n      function wrtBigUInt64BE(buf, value, offset, min, max) {\n        checkIntBI(value, min, max, buf, offset, 7);\n        let lo = Number(value & BigInt(4294967295));\n        buf[offset + 7] = lo;\n        lo = lo >> 8;\n        buf[offset + 6] = lo;\n        lo = lo >> 8;\n        buf[offset + 5] = lo;\n        lo = lo >> 8;\n        buf[offset + 4] = lo;\n        let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n        buf[offset + 3] = hi;\n        hi = hi >> 8;\n        buf[offset + 2] = hi;\n        hi = hi >> 8;\n        buf[offset + 1] = hi;\n        hi = hi >> 8;\n        buf[offset] = hi;\n        return offset + 8;\n      }\n      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n      });\n      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 255;\n        while (++i < byteLength2 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          const limit = Math.pow(2, 8 * byteLength2 - 1);\n          checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n        }\n        let i = byteLength2 - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 255;\n        while (--i >= 0 && (mul *= 256)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 255;\n        }\n        return offset + byteLength2;\n      };\n      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 1, 127, -128);\n        if (value < 0)\n          value = 255 + value + 1;\n        this[offset] = value & 255;\n        return offset + 1;\n      };\n      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 2, 32767, -32768);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 255;\n        return offset + 2;\n      };\n      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        this[offset] = value & 255;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert)\n          checkInt(this, value, offset, 4, 2147483647, -2147483648);\n        if (value < 0)\n          value = 4294967295 + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 255;\n        return offset + 4;\n      };\n      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n      });\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length)\n          throw new RangeError(\"Index out of range\");\n        if (offset < 0)\n          throw new RangeError(\"Index out of range\");\n      }\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer2.isBuffer(target))\n          throw new TypeError(\"argument should be a Buffer\");\n        if (!start)\n          start = 0;\n        if (!end && end !== 0)\n          end = this.length;\n        if (targetStart >= target.length)\n          targetStart = target.length;\n        if (!targetStart)\n          targetStart = 0;\n        if (end > 0 && end < start)\n          end = start;\n        if (end === start)\n          return 0;\n        if (target.length === 0 || this.length === 0)\n          return 0;\n        if (targetStart < 0) {\n          throw new RangeError(\"targetStart out of bounds\");\n        }\n        if (start < 0 || start >= this.length)\n          throw new RangeError(\"Index out of range\");\n        if (end < 0)\n          throw new RangeError(\"sourceEnd out of bounds\");\n        if (end > this.length)\n          end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === \"function\") {\n          this.copyWithin(targetStart, start, end);\n        } else {\n          GlobalUint8Array.prototype.set.call(\n            target,\n            this.subarray(start, end),\n            targetStart\n          );\n        }\n        return len;\n      };\n      Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n        if (typeof val === \"string\") {\n          if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== void 0 && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n          }\n          if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          }\n          if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n              val = code;\n            }\n          }\n        } else if (typeof val === \"number\") {\n          val = val & 255;\n        } else if (typeof val === \"boolean\") {\n          val = Number(val);\n        }\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError(\"Out of range index\");\n        }\n        if (end <= start) {\n          return this;\n        }\n        start = start >>> 0;\n        end = end === void 0 ? this.length : end >>> 0;\n        if (!val)\n          val = 0;\n        let i;\n        if (typeof val === \"number\") {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n          const len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n        return this;\n      };\n      var errors = {};\n      function E(sym, getMessage, Base) {\n        errors[sym] = class NodeError extends Base {\n          constructor() {\n            super();\n            Object.defineProperty(this, \"message\", {\n              value: getMessage.apply(this, arguments),\n              writable: true,\n              configurable: true\n            });\n            this.name = `${this.name} [${sym}]`;\n            this.stack;\n            delete this.name;\n          }\n          get code() {\n            return sym;\n          }\n          set code(value) {\n            Object.defineProperty(this, \"code\", {\n              configurable: true,\n              enumerable: true,\n              value,\n              writable: true\n            });\n          }\n          toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n          }\n        };\n      }\n      E(\n        \"ERR_BUFFER_OUT_OF_BOUNDS\",\n        function(name) {\n          if (name) {\n            return `${name} is outside of buffer bounds`;\n          }\n          return \"Attempt to access memory outside buffer bounds\";\n        },\n        RangeError\n      );\n      E(\n        \"ERR_INVALID_ARG_TYPE\",\n        function(name, actual) {\n          return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n        },\n        TypeError\n      );\n      E(\n        \"ERR_OUT_OF_RANGE\",\n        function(str, range, input) {\n          let msg = `The value of \"${str}\" is out of range.`;\n          let received = input;\n          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n            received = addNumericalSeparator(String(input));\n          } else if (typeof input === \"bigint\") {\n            received = String(input);\n            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n              received = addNumericalSeparator(received);\n            }\n            received += \"n\";\n          }\n          msg += ` It must be ${range}. Received ${received}`;\n          return msg;\n        },\n        RangeError\n      );\n      function addNumericalSeparator(val) {\n        let res = \"\";\n        let i = val.length;\n        const start = val[0] === \"-\" ? 1 : 0;\n        for (; i >= start + 4; i -= 3) {\n          res = `_${val.slice(i - 3, i)}${res}`;\n        }\n        return `${val.slice(0, i)}${res}`;\n      }\n      function checkBounds(buf, offset, byteLength2) {\n        validateNumber(offset, \"offset\");\n        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n          boundsError(offset, buf.length - (byteLength2 + 1));\n        }\n      }\n      function checkIntBI(value, min, max, buf, offset, byteLength2) {\n        if (value > max || value < min) {\n          const n = typeof min === \"bigint\" ? \"n\" : \"\";\n          let range;\n          if (byteLength2 > 3) {\n            if (min === 0 || min === BigInt(0)) {\n              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n            } else {\n              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n            }\n          } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n          }\n          throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n        }\n        checkBounds(buf, offset, byteLength2);\n      }\n      function validateNumber(value, name) {\n        if (typeof value !== \"number\") {\n          throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n        }\n      }\n      function boundsError(value, length, type) {\n        if (Math.floor(value) !== value) {\n          validateNumber(value, type);\n          throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n        }\n        if (length < 0) {\n          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\n          type || \"offset\",\n          `>= ${type ? 1 : 0} and <= ${length}`,\n          value\n        );\n      }\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n      function base64clean(str) {\n        str = str.split(\"=\")[0];\n        str = str.trim().replace(INVALID_BASE64_RE, \"\");\n        if (str.length < 2)\n          return \"\";\n        while (str.length % 4 !== 0) {\n          str = str + \"=\";\n        }\n        return str;\n      }\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        let codePoint;\n        const length = string.length;\n        let leadSurrogate = null;\n        const bytes = [];\n        for (let i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n          if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n              if (codePoint > 56319) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              } else if (i + 1 === length) {\n                if ((units -= 3) > -1)\n                  bytes.push(239, 191, 189);\n                continue;\n              }\n              leadSurrogate = codePoint;\n              continue;\n            }\n            if (codePoint < 56320) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              leadSurrogate = codePoint;\n              continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n          } else if (leadSurrogate) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n          }\n          leadSurrogate = null;\n          if (codePoint < 128) {\n            if ((units -= 1) < 0)\n              break;\n            bytes.push(codePoint);\n          } else if (codePoint < 2048) {\n            if ((units -= 2) < 0)\n              break;\n            bytes.push(\n              codePoint >> 6 | 192,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 65536) {\n            if ((units -= 3) < 0)\n              break;\n            bytes.push(\n              codePoint >> 12 | 224,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0)\n              break;\n            bytes.push(\n              codePoint >> 18 | 240,\n              codePoint >> 12 & 63 | 128,\n              codePoint >> 6 & 63 | 128,\n              codePoint & 63 | 128\n            );\n          } else {\n            throw new Error(\"Invalid code point\");\n          }\n        }\n        return bytes;\n      }\n      function asciiToBytes(str) {\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          byteArray.push(str.charCodeAt(i) & 255);\n        }\n        return byteArray;\n      }\n      function utf16leToBytes(str, units) {\n        let c, hi, lo;\n        const byteArray = [];\n        for (let i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0)\n            break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n        return byteArray;\n      }\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n      function blitBuffer(src, dst, offset, length) {\n        let i;\n        for (i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length)\n            break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n      function isInstance(obj, type) {\n        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        return obj !== obj;\n      }\n      var hexSliceLookupTable = function() {\n        const alphabet = \"0123456789abcdef\";\n        const table = new Array(256);\n        for (let i = 0; i < 16; ++i) {\n          const i16 = i * 16;\n          for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n          }\n        }\n        return table;\n      }();\n      function defineBigIntMethod(fn) {\n        return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n      }\n      function BufferBigIntNotDefined() {\n        throw new Error(\"BigInt not supported\");\n      }\n    }\n  });\n  var require_browser = __commonJS({\n    \"node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\"(exports, module) {\n      init_dist();\n      var process2 = module.exports = {};\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function defaultClearTimeout() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      (function() {\n        try {\n          if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          return setTimeout(fun, 0);\n        }\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e2) {\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          return clearTimeout(marker);\n        }\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            return cachedClearTimeout.call(null, marker);\n          } catch (e2) {\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process2.nextTick = function(fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      process2.title = \"browser\";\n      process2.browser = true;\n      process2.env = {};\n      process2.argv = [];\n      process2.version = \"\";\n      process2.versions = {};\n      function noop() {\n      }\n      process2.on = noop;\n      process2.addListener = noop;\n      process2.once = noop;\n      process2.off = noop;\n      process2.removeListener = noop;\n      process2.removeAllListeners = noop;\n      process2.emit = noop;\n      process2.prependListener = noop;\n      process2.prependOnceListener = noop;\n      process2.listeners = function(name) {\n        return [];\n      };\n      process2.binding = function(name) {\n        throw new Error(\"process.binding is not supported\");\n      };\n      process2.cwd = function() {\n        return \"/\";\n      };\n      process2.chdir = function(dir) {\n        throw new Error(\"process.chdir is not supported\");\n      };\n      process2.umask = function() {\n        return 0;\n      };\n    }\n  });\n  var import_buffer_polyfill, import_process, o;\n  var init_dist = __esm({\n    \"shims/dist/index.js\"() {\n      \"use strict\";\n      import_buffer_polyfill = __toESM2(require_buffer(), 1);\n      import_process = __toESM2(require_browser(), 1);\n      o = globalThis || void 0 || self;\n    }\n  });\n  var require_banner = __commonJS({\n    \"shims/banner/index.cjs\"() {\n      init_dist();\n      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;\n      globalThis.global = globalThis.global || o;\n      globalThis.process = globalThis.process || import_process.default;\n    }\n  });\n  require_banner();\n})();\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\nimport {\n  require_react_dom\n} from \"/node_modules/.vite/deps/chunk-ODZQOPX5.js?v=988c63e5\";\nimport {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-DMLNAHRU.js?v=988c63e5\";\nimport {\n  __toESM,\n  require_dist\n} from \"/node_modules/.vite/deps/chunk-4KAQPM64.js?v=988c63e5\";\nvar import_dist3 = __toESM(require_dist());\nvar React2 = __toESM(require_react());\nvar ReactDOM = __toESM(require_react_dom());\nvar import_dist2 = __toESM(require_dist());\nvar React = __toESM(require_react());\nvar import_dist = __toESM(require_dist());\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar Action;\n(function(Action2) {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries;\n  entries = initialEntries.map((entry, index2) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window2, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window2.location;\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substr(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      {\n        pathname,\n        search,\n        hash\n      },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\")\n      console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window: window2 = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window2.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation)\n      validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    let base = window2.location.origin !== \"null\" ? window2.location.origin : window2.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\nvar ResultType;\n(function(ResultType2) {\n  ResultType2[\"data\"] = \"data\";\n  ResultType2[\"deferred\"] = \"deferred\";\n  ResultType2[\"redirect\"] = \"redirect\";\n  ResultType2[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nvar immutableRouteKeys = /* @__PURE__ */ new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], 'Found a route id collision on id \"' + id + `\".  Route id's must be globally unique within Data Router usages`);\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties2(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties2(route), {\n        id,\n        children: void 0\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".')\n      );\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0)\n    return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(...restExploded.map((subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map((exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));\n}\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match)\n      return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n      return stringify(param);\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match)\n    return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = void 0;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else\n    ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\")\n    return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1)\n        segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n  let pathMatches = getPathContributingMatches(matches);\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n  }\n  return pathMatches.map((match) => match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames.length === 0 ? [] : routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar json = function json2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nvar AbortedDeferredError = class extends Error {\n};\nvar DeferredData = class {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = /* @__PURE__ */ new Set();\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, void 0, data), (error) => this.onSettle(promise, key, error));\n    promise.catch(() => {\n    });\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      this.unlistenAbortSignal();\n    }\n    if (error === void 0 && data === void 0) {\n      let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === void 0) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted2) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted2 || this.done) {\n            resolve(aborted2);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n};\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nvar defer = function defer2(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\nvar redirect = function redirect2(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nvar validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser2;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties2;\n  if (init.mapRouteProperties) {\n    mapRouteProperties2 = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties2 = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties2 = defaultMapRouteProperties;\n  }\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false\n  }, init.future);\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    initialized = false;\n  } else if (!hasLoaders) {\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    initialized = initialMatches.every((m) => m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== void 0 || errors && errors[m.route.id] !== void 0));\n  } else {\n    initialized = init.hydrationData != null;\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = Action.Pop;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledDeferredRoutes = [];\n  let cancelledFetcherLoads = [];\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let deletedFetchers = /* @__PURE__ */ new Set();\n  let activeDeferreds = /* @__PURE__ */ new Map();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let ignoreNextHistoryUpdate = false;\n  function initialize() {\n    unlistenHistory = init.history.listen((_ref) => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: void 0,\n              reset: void 0,\n              location\n            });\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            deletedFetchersKeys.push(key);\n          } else {\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    [...subscribers].forEach((subscriber) => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation)\n      ;\n    else if (pendingAction === Action.Pop)\n      ;\n    else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === Action.Pop) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false)\n      ;\n    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers2 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect3.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key))\n      abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      {\n        [match.route.id]: actionResult.data\n      },\n      void 0\n      // No need to send through errors since we short circuit above\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    let redirect3 = findRedirect(results);\n    if (redirect3) {\n      if (redirect3.idx >= matchesToLoad.length) {\n        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect3.result);\n    }\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n    if (isDeferredResult(result)) {\n      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n    }\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(state2, redirect3, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect3.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state2.location, redirect3.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect3.reloadDocument) {\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect3.location)) {\n        const url = init.history.createURL(redirect3.location);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect3.location);\n        } else {\n          routerWindow.location.assign(redirect3.location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state2.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state2.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect3.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect3.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map((f) => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties2, basename, future.v7_relativeSplatPath);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f) => f.match), fetcherResults, fetchersToLoad.map((f) => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\nvar UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n          let [name, value] = _ref3;\n          return \"\" + acc + name + \"=\" + value + \"\\n\";\n        }, \"\")\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json3 = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json: json3,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (isInitialLoad) {\n      return isUnhydratedRoute(state, match.route);\n    }\n    if (match.route.lazy) {\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id)) {\n      return true;\n    }\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate: (\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n      )\n    }));\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (isInitialLoad || !matches.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0) {\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isUnhydratedRoute(state, route) {\n  if (!route.loader) {\n    return false;\n  }\n  if (route.loader.hydrate) {\n    return true;\n  }\n  return state.loaderData[route.id] === void 0 && (!state.errors || // Loader ran but errored - don't re-run\n  state.errors[route.id] === void 0);\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = currentLoaderData[match.route.id] === void 0;\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nasync function loadLazyRouteModule(route, mapRouteProperties2, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  Object.assign(routeToUpdate, routeUpdates);\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties2(routeToUpdate), {\n    lazy: void 0\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename, v7_relativeSplatPath, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        let handlerError;\n        let values = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties2, manifest)\n        ]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);\n        handler = match.route[type];\n        if (handler) {\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return {\n            type: ResultType.data,\n            data: void 0\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== void 0, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n      } else if (!opts.isStaticRequest) {\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        data = await result.json();\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      loaderData[id] = void 0;\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = void 0;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    if (controller && controller.signal.aborted) {\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== void 0) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== void 0 && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = 'No route matches URL \"' + pathname + '\"';\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find((m) => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then((result2) => {\n        if (result2) {\n          results[index] = result2 || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json: json3\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json3 !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: json3,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json3 = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json3 || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json3 = {};\n    for (let [k, v] of transitions) {\n      json3[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json3));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\nfunction _extends2() {\n  _extends2 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nvar DataRouterContext = React.createContext(null);\nif (true) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nvar DataRouterStateContext = React.createContext(null);\nif (true) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nvar AwaitContext = React.createContext(null);\nif (true) {\n  AwaitContext.displayName = \"Await\";\n}\nvar NavigationContext = React.createContext(null);\nif (true) {\n  NavigationContext.displayName = \"Navigation\";\n}\nvar LocationContext = React.createContext(null);\nif (true) {\n  LocationContext.displayName = \"Location\";\n}\nvar RouteContext = React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (true) {\n  RouteContext.displayName = \"Route\";\n}\nvar RouteErrorContext = React.createContext(null);\nif (true) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\nvar navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\";\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    React.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    future,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    true ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nvar OutletContext = React.createContext(null);\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    future\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (true) {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + `parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n` + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (true) {\n    true ? warning(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : void 0;\n    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.') : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n    ]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n      parentPathnameBase,\n      // Re-encode pathnames that were decoded inside matchRoutes\n      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n    ])\n  })), parentMatches, dataRouterState, future);\n  if (locationArg && renderedMatches) {\n    return React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends2({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (true) {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = React.createElement(React.Fragment, null, React.createElement(\"p\", null, \" Hey developer \"), React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return React.createElement(React.Fragment, null, React.createElement(\"h2\", null, \"Unexpected Application Error!\"), React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nvar defaultErrorElement = React.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error !== void 0 ? React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n};\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (future === void 0) {\n    future = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? true ? invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState && future && future.v7_partialHydration) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.loader && match.route.id && dataRouterState.loaderData[match.route.id] === void 0 && (!dataRouterState.errors || dataRouterState.errors[match.route.id] === void 0)) {\n        renderFallback = true;\n        if (fallbackIndex >= 0) {\n          renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n        } else {\n          renderedMatches = [renderedMatches[0]];\n        }\n        break;\n      }\n    }\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error;\n    let shouldRenderHydrateFallback = false;\n    let errorElement = null;\n    let hydrateFallbackElement = null;\n    if (dataRouterState) {\n      error = errors && match.route.id ? errors[match.route.id] : void 0;\n      errorElement = match.route.errorElement || defaultErrorElement;\n      if (renderFallback) {\n        if (fallbackIndex < 0 && index === 0) {\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = null;\n        } else if (fallbackIndex === index) {\n          shouldRenderHydrateFallback = true;\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n        }\n      }\n    }\n    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (shouldRenderHydrateFallback) {\n        children = hydrateFallbackElement;\n      } else if (match.route.Component) {\n        children = React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return React.createElement(RenderedRoute, {\n        match,\n        routeContext: {\n          outlet,\n          matches: matches2,\n          isDataRoute: dataRouterState != null\n        },\n        children\n      });\n    };\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches: matches2,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = function(DataRouterHook3) {\n  DataRouterHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook3;\n}(DataRouterHook || {});\nvar DataRouterStateHook = function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook3[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook3[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook3[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook3[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook3[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook3[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook3[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook3[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook3[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook3;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return void 0;\n  }\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n  if (error !== void 0) {\n    return error;\n  }\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback((arg) => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends2({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends2({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function(to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    true ? warning(activeRef.current, navigateEffectWarning) : void 0;\n    if (!activeRef.current)\n      return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends2({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    true ? warning(false, message) : void 0;\n  }\n}\nvar START_TRANSITION = \"startTransition\";\nvar startTransitionImpl = React[START_TRANSITION];\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? true ? invariant(\n    false,\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\"\n  ) : invariant(false) : void 0;\n  let {\n    future,\n    static: isStatic\n  } = React.useContext(NavigationContext);\n  true ? warning(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(_props) {\n  true ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false);\n}\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false,\n    future\n  } = _ref5;\n  !!useInRouterContext() ? true ? invariant(false, \"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.\") : invariant(false) : void 0;\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp,\n    future: _extends2({\n      v7_relativeSplatPath: false\n    }, future)\n  }), [basename, future, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  true ? warning(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, React.createElement(LocationContext.Provider, {\n    children,\n    value: locationContext\n  }));\n}\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return React.createElement(AwaitErrorBoundary, {\n    resolve,\n    errorElement\n  }, React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = function(AwaitRenderStatus2) {\n  AwaitRenderStatus2[AwaitRenderStatus2[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus2[AwaitRenderStatus2[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus2;\n}(AwaitRenderStatus || {});\nvar neverSettledPromise = new Promise(() => {\n});\nvar AwaitErrorBoundary = class extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then((data) => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), (error) => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      return React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children\n      });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return React.createElement(React.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? true ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? true ? invariant(false, \"An index route cannot have child routes.\") : invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (true) {\n      if (route.element) {\n        true ? warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: React.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (true) {\n      if (route.hydrateFallbackElement) {\n        true ? warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: React.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (true) {\n      if (route.errorElement) {\n        true ? warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends2({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\nfunction _extends3() {\n  _extends3 = Object.assign ? Object.assign.bind() : function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends3.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    true ? warning(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error('Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">');\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\nvar _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"];\nvar _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"];\nvar _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends3({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends3({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors)\n    return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nvar ViewTransitionContext = React2.createContext({\n  isTransitioning: false\n});\nif (true) {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nvar FetchersContext = React2.createContext(/* @__PURE__ */ new Map());\nif (true) {\n  FetchersContext.displayName = \"Fetchers\";\n}\nvar START_TRANSITION2 = \"startTransition\";\nvar startTransitionImpl2 = React2[START_TRANSITION2];\nvar FLUSH_SYNC = \"flushSync\";\nvar flushSyncImpl = ReactDOM[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl2) {\n    startTransitionImpl2(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React2.useState(router.state);\n  let [pendingState, setPendingState] = React2.useState();\n  let [vtContext, setVtContext] = React2.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React2.useState();\n  let [transition, setTransition] = React2.useState();\n  let [interruption, setInterruption] = React2.useState();\n  let fetcherData = React2.useRef(/* @__PURE__ */ new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React2.useCallback((cb) => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React2.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== void 0) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    if (flushSync) {\n      flushSyncSafe(() => {\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(void 0);\n          setTransition(void 0);\n          setPendingState(void 0);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    if (transition) {\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  React2.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React2.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition2);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  React2.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  React2.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  React2.useEffect(() => {\n    true ? warning(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead\") : void 0;\n  }, []);\n  let navigator = React2.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React2.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  return React2.createElement(React2.Fragment, null, React2.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, React2.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, React2.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, React2.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, React2.createElement(Router, {\n    basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator,\n    future: {\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\n    }\n  }, state.initialized || router.future.v7_partialHydration ? React2.createElement(DataRoutes, {\n    routes: router.routes,\n    future: router.future,\n    state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    future,\n    state\n  } = _ref3;\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref4;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window: window2\n  } = _ref5;\n  let historyRef = React2.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window: window2,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React2.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React2.useCallback((newState) => {\n    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return React2.createElement(Router, {\n    basename,\n    children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history,\n    future\n  });\n}\nif (true) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React2.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n    onClick,\n    relative,\n    reloadDocument,\n    replace,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to)) {\n    absoluteHref = to;\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        true ? warning(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;\n      }\n    }\n  }\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick)\n      onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React2.createElement(\"a\", _extends3({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref,\n      target\n    }))\n  );\n});\nif (true) {\n  Link.displayName = \"Link\";\n}\nvar NavLink = React2.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    unstable_viewTransition,\n    children\n  } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React2.useContext(DataRouterStateContext);\n  let {\n    navigator\n  } = React2.useContext(NavigationContext);\n  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return React2.createElement(Link, _extends3({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className,\n    ref,\n    style,\n    to,\n    unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n  NavLink.displayName = \"NavLink\";\n}\nvar Form = React2.forwardRef((_ref9, forwardedRef) => {\n  let {\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    unstable_viewTransition\n  } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = (event) => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented)\n      return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return React2.createElement(\"form\", _extends3({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (true) {\n  Form.displayName = \"Form\";\n}\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (true) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\nvar DataRouterHook2;\n(function(DataRouterHook3) {\n  DataRouterHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook3[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook3[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook3[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook2 || (DataRouterHook2 = {}));\nvar DataRouterStateHook2;\n(function(DataRouterStateHook3) {\n  DataRouterStateHook3[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook3[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook3[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));\nfunction getDataRouterConsoleError2(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext2(hookName) {\n  let ctx = React2.useContext(DataRouterContext);\n  !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = React2.useContext(DataRouterStateContext);\n  !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;\n  return state;\n}\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React2.useCallback((event) => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\nfunction useSearchParams(defaultInit) {\n  true ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\\n\\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.\") : void 0;\n  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React2.useRef(false);\n  let location = useLocation();\n  let searchParams = React2.useMemo(() => (\n    // Only merge in the defaults if we haven't yet called setSearchParams.\n    // Once we call that we want those to take precedence, otherwise you can't\n    // remove a param with setSearchParams({}) if it has an initial value\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)\n  ), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React2.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseSubmit);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return React2.useCallback(function(target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let routeContext = React2.useContext(RouteContext);\n  !routeContext ? true ? invariant(false, \"useFormAction must be used inside a RouteContext\") : invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  let path = _extends3({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseFetcher);\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetcher);\n  let fetcherData = React2.useContext(FetchersContext);\n  let route = React2.useContext(RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? true ? invariant(false, \"useFetcher must be used inside a FetchersContext\") : invariant(false) : void 0;\n  !route ? true ? invariant(false, \"useFetcher must be used inside a RouteContext\") : invariant(false) : void 0;\n  !(routeId != null) ? true ? invariant(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : invariant(false) : void 0;\n  let [fetcherKey, setFetcherKey] = React2.useState(key || \"\");\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  React2.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  let load = React2.useCallback((href, opts) => {\n    !routeId ? true ? invariant(false, \"No routeId available for fetcher.load()\") : invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React2.useCallback((target, opts) => {\n    submitImpl(target, _extends3({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React2.useMemo(() => {\n    let FetcherForm2 = React2.forwardRef((props, ref) => {\n      return React2.createElement(Form, _extends3({}, props, {\n        navigate: false,\n        fetcherKey,\n        ref\n      }));\n    });\n    if (true) {\n      FetcherForm2.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React2.useMemo(() => _extends3({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(DataRouterStateHook2.UseFetchers);\n  return Array.from(state.fetchers.entries()).map((_ref11) => {\n    let [key, fetcher] = _ref11;\n    return _extends3({}, fetcher, {\n      key\n    });\n  });\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);\n  let {\n    basename\n  } = React2.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  React2.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(React2.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      true ? warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  if (typeof document !== \"undefined\") {\n    React2.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    React2.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location2, matches2) => getKey(\n        // Strip the basename to match useLocation()\n        _extends3({}, location2, {\n          pathname: stripBasename(location2.pathname, basename) || location2.pathname\n        }),\n        matches2\n      ) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    React2.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React2.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React2.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React2.useContext(ViewTransitionContext);\n  !(vtContext != null) ? true ? invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\") : invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\nexport {\n  AbortedDeferredError,\n  Await,\n  BrowserRouter,\n  Form,\n  HashRouter,\n  Link,\n  MemoryRouter,\n  NavLink,\n  Navigate,\n  Action as NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  ScrollRestoration,\n  DataRouterContext as UNSAFE_DataRouterContext,\n  DataRouterStateContext as UNSAFE_DataRouterStateContext,\n  FetchersContext as UNSAFE_FetchersContext,\n  LocationContext as UNSAFE_LocationContext,\n  NavigationContext as UNSAFE_NavigationContext,\n  RouteContext as UNSAFE_RouteContext,\n  ViewTransitionContext as UNSAFE_ViewTransitionContext,\n  useRouteId as UNSAFE_useRouteId,\n  useScrollRestoration as UNSAFE_useScrollRestoration,\n  createBrowserRouter,\n  createHashRouter,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromChildren as createRoutesFromElements,\n  createSearchParams,\n  defer,\n  generatePath,\n  isRouteErrorResponse,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  redirectDocument,\n  renderMatches,\n  resolvePath,\n  HistoryRouter as unstable_HistoryRouter,\n  usePrompt as unstable_usePrompt,\n  useViewTransitionState as unstable_useViewTransitionState,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useBeforeUnload,\n  useBlocker,\n  useFetcher,\n  useFetchers,\n  useFormAction,\n  useHref,\n  useInRouterContext,\n  useLinkClickHandler,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n  useSearchParams,\n  useSubmit\n};\n/*! Bundled license information:\n\n@remix-run/router/dist/router.js:\n  (**\n   * @remix-run/router v1.14.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router/dist/index.js:\n  (**\n   * React Router v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n\nreact-router-dom/dist/index.js:\n  (**\n   * React Router DOM v6.21.0\n   *\n   * Copyright (c) Remix Software Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n*/\n",
      "start": 1703474742428,
      "end": 1703474742430,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
