<extensionManifest><groupId>org.apache.nifi</groupId><artifactId>nifi-avro-nar</artifactId><version>2.0.0-SNAPSHOT</version><parentNar><groupId>org.apache.nifi</groupId><artifactId>nifi-standard-services-api-nar</artifactId><version>2.0.0-SNAPSHOT</version></parentNar><systemApiVersion>2.0.0-SNAPSHOT</systemApiVersion><buildInfo><tag>HEAD</tag><branch>main</branch><revision>f352857</revision></buildInfo><extensions><extension><name>org.apache.nifi.processors.avro.ConvertAvroToJSON</name><type>PROCESSOR</type><description>Converts a Binary Avro record into a JSON object. This processor provides a direct mapping of an Avro field to a JSON field, such that the resulting JSON will have the same hierarchical structure as the Avro document. Note that the Avro schema information will be lost, as this is not a translation from binary Avro to JSON formatted Avro. The output JSON is encoded the UTF-8 encoding. If an incoming FlowFile contains a stream of multiple Avro records, the resultant FlowFile will contain a JSON Array containing all of the Avro records or a sequence of JSON Objects.  If an incoming FlowFile does not contain any records, an empty JSON object is the output. Empty/Single Avro record FlowFile inputs are optionally wrapped in a container as dictated by 'Wrap Single Record'</description><tags><tag>avro</tag><tag>convert</tag><tag>json</tag></tags><properties><property><name>JSON container options</name><displayName>JSON container options</displayName><description>Determines how stream of records is exposed: either as a sequence of single Objects (none) (i.e. writing every Object to a new line), or as an array of Objects (array).</description><defaultValue>array</defaultValue><allowableValues><allowableValue><displayName>none</displayName><value>none</value><description></description></allowableValue><allowableValue><displayName>array</displayName><value>array</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Wrap Single Record</name><displayName>Wrap Single Record</displayName><description>Determines if the resulting output for empty records or a single record should be wrapped in a container array as specified by 'JSON container options'</description><defaultValue>false</defaultValue><allowableValues><allowableValue><displayName>true</displayName><value>true</value><description></description></allowableValue><allowableValue><displayName>false</displayName><value>false</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Avro schema</name><displayName>Avro schema</displayName><description>If the Avro records do not contain the schema (datum only), it must be specified here.</description><required>false</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property></properties><relationships><relationship><name>success</name><description>A FlowFile is routed to this relationship after it has been converted to JSON</description><autoTerminated>false</autoTerminated></relationship><relationship><name>failure</name><description>A FlowFile is routed to this relationship if it cannot be parsed as Avro or cannot be converted to JSON for any reason</description><autoTerminated>false</autoTerminated></relationship></relationships><writesAttributes><writesAttribute><name>mime.type</name><description>Sets the mime type to application/json</description></writesAttribute></writesAttributes><supportsBatching>true</supportsBatching><sideEffectFree>true</sideEffectFree><inputRequirement>INPUT_REQUIRED</inputRequirement></extension><extension><name>org.apache.nifi.processors.avro.ExtractAvroMetadata</name><type>PROCESSOR</type><description>Extracts metadata from the header of an Avro datafile.</description><tags><tag>avro</tag><tag>schema</tag><tag>metadata</tag></tags><properties><property><name>Fingerprint Algorithm</name><displayName>Fingerprint Algorithm</displayName><description>The algorithm used to generate the schema fingerprint. Available choices are based on the Avro recommended practices for fingerprint generation.</description><defaultValue>CRC-64-AVRO</defaultValue><allowableValues><allowableValue><displayName>CRC-64-AVRO</displayName><value>CRC-64-AVRO</value><description></description></allowableValue><allowableValue><displayName>MD5</displayName><value>MD5</value><description></description></allowableValue><allowableValue><displayName>SHA-256</displayName><value>SHA-256</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Metadata Keys</name><displayName>Metadata Keys</displayName><description>A comma-separated list of keys indicating key/value pairs to extract from the Avro file header. The key 'avro.schema' can be used to extract the full schema in JSON format, and 'avro.codec' can be used to extract the codec name if one exists.</description><required>false</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Count Items</name><displayName>Count Items</displayName><description>If true the number of items in the datafile will be counted and stored in a FlowFile attribute 'item.count'. The counting is done by reading blocks and getting the number of items for each block, thus avoiding de-serializing. The items being counted will be the top-level items in the datafile. For example, with a schema of type record the items will be the records, and for a schema of type Array the items will be the arrays (not the number of entries in each array).</description><defaultValue>false</defaultValue><allowableValues><allowableValue><displayName>true</displayName><value>true</value><description></description></allowableValue><allowableValue><displayName>false</displayName><value>false</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property></properties><relationships><relationship><name>success</name><description>A FlowFile is routed to this relationship after metadata has been extracted.</description><autoTerminated>false</autoTerminated></relationship><relationship><name>failure</name><description>A FlowFile is routed to this relationship if it cannot be parsed as Avro or metadata cannot be extracted for any reason</description><autoTerminated>false</autoTerminated></relationship></relationships><writesAttributes><writesAttribute><name>schema.type</name><description>The type of the schema (i.e. record, enum, etc.).</description></writesAttribute><writesAttribute><name>schema.name</name><description>Contains the name when the type is a record, enum or fixed, otherwise contains the name of the primitive type.</description></writesAttribute><writesAttribute><name>schema.fingerprint</name><description>The result of the Fingerprint Algorithm as a Hex string.</description></writesAttribute><writesAttribute><name>item.count</name><description>The total number of items in the datafile, only written if Count Items is set to true.</description></writesAttribute></writesAttributes><supportsBatching>true</supportsBatching><sideEffectFree>true</sideEffectFree><inputRequirement>INPUT_REQUIRED</inputRequirement></extension><extension><name>org.apache.nifi.processors.avro.SplitAvro</name><type>PROCESSOR</type><description>Splits a binary encoded Avro datafile into smaller files based on the configured Output Size. The Output Strategy determines if the smaller files will be Avro datafiles, or bare Avro records with metadata in the FlowFile attributes. The output will always be binary encoded.</description><tags><tag>avro</tag><tag>split</tag></tags><properties><property><name>Split Strategy</name><displayName>Split Strategy</displayName><description>The strategy for splitting the incoming datafile. The Record strategy will read the incoming datafile by de-serializing each record.</description><defaultValue>Record</defaultValue><allowableValues><allowableValue><displayName>Record</displayName><value>Record</value><description>Split at Record boundaries</description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Output Size</name><displayName>Output Size</displayName><description>The number of Avro records to include per split file. In cases where the incoming file has less records than the Output Size, or when the total number of records does not divide evenly by the Output Size, it is possible to get a split file with less records.</description><defaultValue>1</defaultValue><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Output Strategy</name><displayName>Output Strategy</displayName><description>Determines the format of the output. Either Avro Datafile, or bare record. Bare record output is only intended for use with systems that already require it, and shouldn't be needed for normal use.</description><defaultValue>Datafile</defaultValue><allowableValues><allowableValue><displayName>Datafile</displayName><value>Datafile</value><description>Avro's object container file format</description></allowableValue><allowableValue><displayName>Bare Record</displayName><value>Bare Record</value><description>Bare Avro records</description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Transfer Metadata</name><displayName>Transfer Metadata</displayName><description>Whether or not to transfer metadata from the parent datafile to the children. If the Output Strategy is Bare Record, then the metadata will be stored as FlowFile attributes, otherwise it will be in the Datafile header.</description><defaultValue>true</defaultValue><allowableValues><allowableValue><displayName>true</displayName><value>true</value><description></description></allowableValue><allowableValue><displayName>false</displayName><value>false</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property></properties><relationships><relationship><name>failure</name><description>If a FlowFile fails processing for any reason (for example, the FlowFile is not valid Avro), it will be routed to this relationship</description><autoTerminated>false</autoTerminated></relationship><relationship><name>original</name><description>The original FlowFile that was split. If the FlowFile fails processing, nothing will be sent to this relationship</description><autoTerminated>false</autoTerminated></relationship><relationship><name>split</name><description>All new files split from the original FlowFile will be routed to this relationship</description><autoTerminated>false</autoTerminated></relationship></relationships><writesAttributes><writesAttribute><name>fragment.identifier</name><description>All split FlowFiles produced from the same parent FlowFile will have the same randomly generated UUID added for this attribute</description></writesAttribute><writesAttribute><name>fragment.index</name><description>A one-up number that indicates the ordering of the split FlowFiles that were created from a single parent FlowFile</description></writesAttribute><writesAttribute><name>fragment.count</name><description>The number of split FlowFiles generated from the parent FlowFile</description></writesAttribute><writesAttribute><name>segment.original.filename </name><description>The filename of the parent FlowFile</description></writesAttribute></writesAttributes><supportsBatching>true</supportsBatching><sideEffectFree>true</sideEffectFree><inputRequirement>INPUT_REQUIRED</inputRequirement><systemResourceConsiderations><systemResourceConsideration><resource>MEMORY</resource><description>An instance of this component can cause high usage of this system resource.  Multiple instances or high concurrency settings may result a degradation of performance.</description></systemResourceConsideration></systemResourceConsiderations></extension></extensions></extensionManifest>